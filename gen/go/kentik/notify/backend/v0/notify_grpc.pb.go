// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package notify

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NotifyClient is the client API for Notify service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotifyClient interface {
	SearchNotifications(ctx context.Context, in *NotificationsRequest, opts ...grpc.CallOption) (*NotificationsResponse, error)
	ListNotifications(ctx context.Context, in *NotificationsRequest, opts ...grpc.CallOption) (*NotificationsResponse, error)
	// deprecated
	StreamNotifications(ctx context.Context, in *NotificationsRequest, opts ...grpc.CallOption) (Notify_StreamNotificationsClient, error)
	// Note: internally can publish notifications directly to Kafka.
	CreateNotificationEvent(ctx context.Context, in *NotificationEvent, opts ...grpc.CallOption) (*NotificationEventResponse, error)
	SearchDeliveryResults(ctx context.Context, in *DeliveryResultsRequest, opts ...grpc.CallOption) (*DeliveryResultsResponse, error)
	CreateNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	ListNotificationChannels(ctx context.Context, in *NotificationChannelsRequest, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	SearchNotificationChannels(ctx context.Context, in *NotificationChannelsRequest, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	GetNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelResponse, error)
	UpdateNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	DeleteNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	GetSupportedChannels(ctx context.Context, in *SupportedChannelsRequest, opts ...grpc.CallOption) (*SupportedChannelsResponse, error)
	CreateUserChannel(ctx context.Context, in *CreateUserChannelRequest, opts ...grpc.CallOption) (*NotificationChannelResponse, error)
	GetUserChannel(ctx context.Context, in *NotificationChannelsRequest, opts ...grpc.CallOption) (*NotificationChannelResponse, error)
	SubscribeWithUserChannel(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	UnsubscribeWithUserChannel(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	DeleteUserChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	GetLastNotificationAndStatus(ctx context.Context, in *NotificationAndStatusRequest, opts ...grpc.CallOption) (*NotificationAndStatusResponse, error)
	GetNotificationPayload(ctx context.Context, in *NotificationPayloadRequest, opts ...grpc.CallOption) (*NotificationPayloadResponse, error)
	// immediately but asynchronously send notification described in the enclosed NotificationPayloadRequest.
	CreateNotificationForTesting(ctx context.Context, in *CreateNotificationForTestingRequest, opts ...grpc.CallOption) (*CreateNotificationForTestingResponse, error)
	CreateNotificationForTestingInsight(ctx context.Context, in *CreateNotificationForTestingRequest, opts ...grpc.CallOption) (*CreateNotificationForTestingResponse, error)
	GetNotificationPayloadInsight(ctx context.Context, in *NotificationPayloadRequest, opts ...grpc.CallOption) (*NotificationPayloadResponse, error)
	// ApplyAlertingMapping offers a policy+threshold centric way to manage channels.
	// It replaces selectors in the target channels by simple policy+threshold matchers.
	ApplyAlertingMapping(ctx context.Context, in *ApplyAlertingManagedChannelsMappingRequest, opts ...grpc.CallOption) (*NotificationChannelsResponse, error)
	GetAccessControlConfig(ctx context.Context, in *GetAccessControlConfigRequest, opts ...grpc.CallOption) (*GetAccessControlConfigResponse, error)
	SetAccessControlConfig(ctx context.Context, in *SetAccessControlConfigRequest, opts ...grpc.CallOption) (*SetAccessControlConfigResponse, error)
}

type notifyClient struct {
	cc grpc.ClientConnInterface
}

func NewNotifyClient(cc grpc.ClientConnInterface) NotifyClient {
	return &notifyClient{cc}
}

func (c *notifyClient) SearchNotifications(ctx context.Context, in *NotificationsRequest, opts ...grpc.CallOption) (*NotificationsResponse, error) {
	out := new(NotificationsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/SearchNotifications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) ListNotifications(ctx context.Context, in *NotificationsRequest, opts ...grpc.CallOption) (*NotificationsResponse, error) {
	out := new(NotificationsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/ListNotifications", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) StreamNotifications(ctx context.Context, in *NotificationsRequest, opts ...grpc.CallOption) (Notify_StreamNotificationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Notify_ServiceDesc.Streams[0], "/kentik.api.notify.v0.Notify/StreamNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &notifyStreamNotificationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Notify_StreamNotificationsClient interface {
	Recv() (*NotificationsResponse, error)
	grpc.ClientStream
}

type notifyStreamNotificationsClient struct {
	grpc.ClientStream
}

func (x *notifyStreamNotificationsClient) Recv() (*NotificationsResponse, error) {
	m := new(NotificationsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *notifyClient) CreateNotificationEvent(ctx context.Context, in *NotificationEvent, opts ...grpc.CallOption) (*NotificationEventResponse, error) {
	out := new(NotificationEventResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/CreateNotificationEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) SearchDeliveryResults(ctx context.Context, in *DeliveryResultsRequest, opts ...grpc.CallOption) (*DeliveryResultsResponse, error) {
	out := new(DeliveryResultsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/SearchDeliveryResults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) CreateNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/CreateNotificationChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) ListNotificationChannels(ctx context.Context, in *NotificationChannelsRequest, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/ListNotificationChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) SearchNotificationChannels(ctx context.Context, in *NotificationChannelsRequest, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/SearchNotificationChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelResponse, error) {
	out := new(NotificationChannelResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetNotificationChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) UpdateNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/UpdateNotificationChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) DeleteNotificationChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/DeleteNotificationChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetSupportedChannels(ctx context.Context, in *SupportedChannelsRequest, opts ...grpc.CallOption) (*SupportedChannelsResponse, error) {
	out := new(SupportedChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetSupportedChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) CreateUserChannel(ctx context.Context, in *CreateUserChannelRequest, opts ...grpc.CallOption) (*NotificationChannelResponse, error) {
	out := new(NotificationChannelResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/CreateUserChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetUserChannel(ctx context.Context, in *NotificationChannelsRequest, opts ...grpc.CallOption) (*NotificationChannelResponse, error) {
	out := new(NotificationChannelResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetUserChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) SubscribeWithUserChannel(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/SubscribeWithUserChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) UnsubscribeWithUserChannel(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/UnsubscribeWithUserChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) DeleteUserChannel(ctx context.Context, in *NotificationChannel, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/DeleteUserChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetLastNotificationAndStatus(ctx context.Context, in *NotificationAndStatusRequest, opts ...grpc.CallOption) (*NotificationAndStatusResponse, error) {
	out := new(NotificationAndStatusResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetLastNotificationAndStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetNotificationPayload(ctx context.Context, in *NotificationPayloadRequest, opts ...grpc.CallOption) (*NotificationPayloadResponse, error) {
	out := new(NotificationPayloadResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetNotificationPayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) CreateNotificationForTesting(ctx context.Context, in *CreateNotificationForTestingRequest, opts ...grpc.CallOption) (*CreateNotificationForTestingResponse, error) {
	out := new(CreateNotificationForTestingResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/CreateNotificationForTesting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) CreateNotificationForTestingInsight(ctx context.Context, in *CreateNotificationForTestingRequest, opts ...grpc.CallOption) (*CreateNotificationForTestingResponse, error) {
	out := new(CreateNotificationForTestingResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/CreateNotificationForTestingInsight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetNotificationPayloadInsight(ctx context.Context, in *NotificationPayloadRequest, opts ...grpc.CallOption) (*NotificationPayloadResponse, error) {
	out := new(NotificationPayloadResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetNotificationPayloadInsight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) ApplyAlertingMapping(ctx context.Context, in *ApplyAlertingManagedChannelsMappingRequest, opts ...grpc.CallOption) (*NotificationChannelsResponse, error) {
	out := new(NotificationChannelsResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/ApplyAlertingMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) GetAccessControlConfig(ctx context.Context, in *GetAccessControlConfigRequest, opts ...grpc.CallOption) (*GetAccessControlConfigResponse, error) {
	out := new(GetAccessControlConfigResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/GetAccessControlConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyClient) SetAccessControlConfig(ctx context.Context, in *SetAccessControlConfigRequest, opts ...grpc.CallOption) (*SetAccessControlConfigResponse, error) {
	out := new(SetAccessControlConfigResponse)
	err := c.cc.Invoke(ctx, "/kentik.api.notify.v0.Notify/SetAccessControlConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotifyServer is the server API for Notify service.
// All implementations should embed UnimplementedNotifyServer
// for forward compatibility
type NotifyServer interface {
	SearchNotifications(context.Context, *NotificationsRequest) (*NotificationsResponse, error)
	ListNotifications(context.Context, *NotificationsRequest) (*NotificationsResponse, error)
	// deprecated
	StreamNotifications(*NotificationsRequest, Notify_StreamNotificationsServer) error
	// Note: internally can publish notifications directly to Kafka.
	CreateNotificationEvent(context.Context, *NotificationEvent) (*NotificationEventResponse, error)
	SearchDeliveryResults(context.Context, *DeliveryResultsRequest) (*DeliveryResultsResponse, error)
	CreateNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error)
	ListNotificationChannels(context.Context, *NotificationChannelsRequest) (*NotificationChannelsResponse, error)
	SearchNotificationChannels(context.Context, *NotificationChannelsRequest) (*NotificationChannelsResponse, error)
	GetNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelResponse, error)
	UpdateNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error)
	DeleteNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error)
	GetSupportedChannels(context.Context, *SupportedChannelsRequest) (*SupportedChannelsResponse, error)
	CreateUserChannel(context.Context, *CreateUserChannelRequest) (*NotificationChannelResponse, error)
	GetUserChannel(context.Context, *NotificationChannelsRequest) (*NotificationChannelResponse, error)
	SubscribeWithUserChannel(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	UnsubscribeWithUserChannel(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	DeleteUserChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error)
	GetLastNotificationAndStatus(context.Context, *NotificationAndStatusRequest) (*NotificationAndStatusResponse, error)
	GetNotificationPayload(context.Context, *NotificationPayloadRequest) (*NotificationPayloadResponse, error)
	// immediately but asynchronously send notification described in the enclosed NotificationPayloadRequest.
	CreateNotificationForTesting(context.Context, *CreateNotificationForTestingRequest) (*CreateNotificationForTestingResponse, error)
	CreateNotificationForTestingInsight(context.Context, *CreateNotificationForTestingRequest) (*CreateNotificationForTestingResponse, error)
	GetNotificationPayloadInsight(context.Context, *NotificationPayloadRequest) (*NotificationPayloadResponse, error)
	// ApplyAlertingMapping offers a policy+threshold centric way to manage channels.
	// It replaces selectors in the target channels by simple policy+threshold matchers.
	ApplyAlertingMapping(context.Context, *ApplyAlertingManagedChannelsMappingRequest) (*NotificationChannelsResponse, error)
	GetAccessControlConfig(context.Context, *GetAccessControlConfigRequest) (*GetAccessControlConfigResponse, error)
	SetAccessControlConfig(context.Context, *SetAccessControlConfigRequest) (*SetAccessControlConfigResponse, error)
}

// UnimplementedNotifyServer should be embedded to have forward compatible implementations.
type UnimplementedNotifyServer struct {
}

func (UnimplementedNotifyServer) SearchNotifications(context.Context, *NotificationsRequest) (*NotificationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchNotifications not implemented")
}
func (UnimplementedNotifyServer) ListNotifications(context.Context, *NotificationsRequest) (*NotificationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifications not implemented")
}
func (UnimplementedNotifyServer) StreamNotifications(*NotificationsRequest, Notify_StreamNotificationsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamNotifications not implemented")
}
func (UnimplementedNotifyServer) CreateNotificationEvent(context.Context, *NotificationEvent) (*NotificationEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotificationEvent not implemented")
}
func (UnimplementedNotifyServer) SearchDeliveryResults(context.Context, *DeliveryResultsRequest) (*DeliveryResultsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchDeliveryResults not implemented")
}
func (UnimplementedNotifyServer) CreateNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotificationChannel not implemented")
}
func (UnimplementedNotifyServer) ListNotificationChannels(context.Context, *NotificationChannelsRequest) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotificationChannels not implemented")
}
func (UnimplementedNotifyServer) SearchNotificationChannels(context.Context, *NotificationChannelsRequest) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchNotificationChannels not implemented")
}
func (UnimplementedNotifyServer) GetNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationChannel not implemented")
}
func (UnimplementedNotifyServer) UpdateNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotificationChannel not implemented")
}
func (UnimplementedNotifyServer) DeleteNotificationChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotificationChannel not implemented")
}
func (UnimplementedNotifyServer) GetSupportedChannels(context.Context, *SupportedChannelsRequest) (*SupportedChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSupportedChannels not implemented")
}
func (UnimplementedNotifyServer) CreateUserChannel(context.Context, *CreateUserChannelRequest) (*NotificationChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserChannel not implemented")
}
func (UnimplementedNotifyServer) GetUserChannel(context.Context, *NotificationChannelsRequest) (*NotificationChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserChannel not implemented")
}
func (UnimplementedNotifyServer) SubscribeWithUserChannel(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeWithUserChannel not implemented")
}
func (UnimplementedNotifyServer) UnsubscribeWithUserChannel(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsubscribeWithUserChannel not implemented")
}
func (UnimplementedNotifyServer) DeleteUserChannel(context.Context, *NotificationChannel) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserChannel not implemented")
}
func (UnimplementedNotifyServer) GetLastNotificationAndStatus(context.Context, *NotificationAndStatusRequest) (*NotificationAndStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastNotificationAndStatus not implemented")
}
func (UnimplementedNotifyServer) GetNotificationPayload(context.Context, *NotificationPayloadRequest) (*NotificationPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationPayload not implemented")
}
func (UnimplementedNotifyServer) CreateNotificationForTesting(context.Context, *CreateNotificationForTestingRequest) (*CreateNotificationForTestingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotificationForTesting not implemented")
}
func (UnimplementedNotifyServer) CreateNotificationForTestingInsight(context.Context, *CreateNotificationForTestingRequest) (*CreateNotificationForTestingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotificationForTestingInsight not implemented")
}
func (UnimplementedNotifyServer) GetNotificationPayloadInsight(context.Context, *NotificationPayloadRequest) (*NotificationPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationPayloadInsight not implemented")
}
func (UnimplementedNotifyServer) ApplyAlertingMapping(context.Context, *ApplyAlertingManagedChannelsMappingRequest) (*NotificationChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyAlertingMapping not implemented")
}
func (UnimplementedNotifyServer) GetAccessControlConfig(context.Context, *GetAccessControlConfigRequest) (*GetAccessControlConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessControlConfig not implemented")
}
func (UnimplementedNotifyServer) SetAccessControlConfig(context.Context, *SetAccessControlConfigRequest) (*SetAccessControlConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAccessControlConfig not implemented")
}

// UnsafeNotifyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotifyServer will
// result in compilation errors.
type UnsafeNotifyServer interface {
	mustEmbedUnimplementedNotifyServer()
}

func RegisterNotifyServer(s grpc.ServiceRegistrar, srv NotifyServer) {
	s.RegisterService(&Notify_ServiceDesc, srv)
}

func _Notify_SearchNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).SearchNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/SearchNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).SearchNotifications(ctx, req.(*NotificationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_ListNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).ListNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/ListNotifications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).ListNotifications(ctx, req.(*NotificationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_StreamNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NotificationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotifyServer).StreamNotifications(m, &notifyStreamNotificationsServer{stream})
}

type Notify_StreamNotificationsServer interface {
	Send(*NotificationsResponse) error
	grpc.ServerStream
}

type notifyStreamNotificationsServer struct {
	grpc.ServerStream
}

func (x *notifyStreamNotificationsServer) Send(m *NotificationsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Notify_CreateNotificationEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).CreateNotificationEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/CreateNotificationEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).CreateNotificationEvent(ctx, req.(*NotificationEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_SearchDeliveryResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliveryResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).SearchDeliveryResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/SearchDeliveryResults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).SearchDeliveryResults(ctx, req.(*DeliveryResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_CreateNotificationChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).CreateNotificationChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/CreateNotificationChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).CreateNotificationChannel(ctx, req.(*NotificationChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_ListNotificationChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).ListNotificationChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/ListNotificationChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).ListNotificationChannels(ctx, req.(*NotificationChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_SearchNotificationChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).SearchNotificationChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/SearchNotificationChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).SearchNotificationChannels(ctx, req.(*NotificationChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetNotificationChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetNotificationChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetNotificationChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetNotificationChannel(ctx, req.(*NotificationChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_UpdateNotificationChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).UpdateNotificationChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/UpdateNotificationChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).UpdateNotificationChannel(ctx, req.(*NotificationChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_DeleteNotificationChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).DeleteNotificationChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/DeleteNotificationChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).DeleteNotificationChannel(ctx, req.(*NotificationChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetSupportedChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SupportedChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetSupportedChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetSupportedChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetSupportedChannels(ctx, req.(*SupportedChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_CreateUserChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).CreateUserChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/CreateUserChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).CreateUserChannel(ctx, req.(*CreateUserChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetUserChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetUserChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetUserChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetUserChannel(ctx, req.(*NotificationChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_SubscribeWithUserChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).SubscribeWithUserChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/SubscribeWithUserChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).SubscribeWithUserChannel(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_UnsubscribeWithUserChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).UnsubscribeWithUserChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/UnsubscribeWithUserChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).UnsubscribeWithUserChannel(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_DeleteUserChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).DeleteUserChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/DeleteUserChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).DeleteUserChannel(ctx, req.(*NotificationChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetLastNotificationAndStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationAndStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetLastNotificationAndStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetLastNotificationAndStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetLastNotificationAndStatus(ctx, req.(*NotificationAndStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetNotificationPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetNotificationPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetNotificationPayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetNotificationPayload(ctx, req.(*NotificationPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_CreateNotificationForTesting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNotificationForTestingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).CreateNotificationForTesting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/CreateNotificationForTesting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).CreateNotificationForTesting(ctx, req.(*CreateNotificationForTestingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_CreateNotificationForTestingInsight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNotificationForTestingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).CreateNotificationForTestingInsight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/CreateNotificationForTestingInsight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).CreateNotificationForTestingInsight(ctx, req.(*CreateNotificationForTestingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetNotificationPayloadInsight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetNotificationPayloadInsight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetNotificationPayloadInsight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetNotificationPayloadInsight(ctx, req.(*NotificationPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_ApplyAlertingMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyAlertingManagedChannelsMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).ApplyAlertingMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/ApplyAlertingMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).ApplyAlertingMapping(ctx, req.(*ApplyAlertingManagedChannelsMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_GetAccessControlConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccessControlConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).GetAccessControlConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/GetAccessControlConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).GetAccessControlConfig(ctx, req.(*GetAccessControlConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notify_SetAccessControlConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAccessControlConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyServer).SetAccessControlConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kentik.api.notify.v0.Notify/SetAccessControlConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyServer).SetAccessControlConfig(ctx, req.(*SetAccessControlConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Notify_ServiceDesc is the grpc.ServiceDesc for Notify service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notify_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kentik.api.notify.v0.Notify",
	HandlerType: (*NotifyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchNotifications",
			Handler:    _Notify_SearchNotifications_Handler,
		},
		{
			MethodName: "ListNotifications",
			Handler:    _Notify_ListNotifications_Handler,
		},
		{
			MethodName: "CreateNotificationEvent",
			Handler:    _Notify_CreateNotificationEvent_Handler,
		},
		{
			MethodName: "SearchDeliveryResults",
			Handler:    _Notify_SearchDeliveryResults_Handler,
		},
		{
			MethodName: "CreateNotificationChannel",
			Handler:    _Notify_CreateNotificationChannel_Handler,
		},
		{
			MethodName: "ListNotificationChannels",
			Handler:    _Notify_ListNotificationChannels_Handler,
		},
		{
			MethodName: "SearchNotificationChannels",
			Handler:    _Notify_SearchNotificationChannels_Handler,
		},
		{
			MethodName: "GetNotificationChannel",
			Handler:    _Notify_GetNotificationChannel_Handler,
		},
		{
			MethodName: "UpdateNotificationChannel",
			Handler:    _Notify_UpdateNotificationChannel_Handler,
		},
		{
			MethodName: "DeleteNotificationChannel",
			Handler:    _Notify_DeleteNotificationChannel_Handler,
		},
		{
			MethodName: "GetSupportedChannels",
			Handler:    _Notify_GetSupportedChannels_Handler,
		},
		{
			MethodName: "CreateUserChannel",
			Handler:    _Notify_CreateUserChannel_Handler,
		},
		{
			MethodName: "GetUserChannel",
			Handler:    _Notify_GetUserChannel_Handler,
		},
		{
			MethodName: "SubscribeWithUserChannel",
			Handler:    _Notify_SubscribeWithUserChannel_Handler,
		},
		{
			MethodName: "UnsubscribeWithUserChannel",
			Handler:    _Notify_UnsubscribeWithUserChannel_Handler,
		},
		{
			MethodName: "DeleteUserChannel",
			Handler:    _Notify_DeleteUserChannel_Handler,
		},
		{
			MethodName: "GetLastNotificationAndStatus",
			Handler:    _Notify_GetLastNotificationAndStatus_Handler,
		},
		{
			MethodName: "GetNotificationPayload",
			Handler:    _Notify_GetNotificationPayload_Handler,
		},
		{
			MethodName: "CreateNotificationForTesting",
			Handler:    _Notify_CreateNotificationForTesting_Handler,
		},
		{
			MethodName: "CreateNotificationForTestingInsight",
			Handler:    _Notify_CreateNotificationForTestingInsight_Handler,
		},
		{
			MethodName: "GetNotificationPayloadInsight",
			Handler:    _Notify_GetNotificationPayloadInsight_Handler,
		},
		{
			MethodName: "ApplyAlertingMapping",
			Handler:    _Notify_ApplyAlertingMapping_Handler,
		},
		{
			MethodName: "GetAccessControlConfig",
			Handler:    _Notify_GetAccessControlConfig_Handler,
		},
		{
			MethodName: "SetAccessControlConfig",
			Handler:    _Notify_SetAccessControlConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamNotifications",
			Handler:       _Notify_StreamNotifications_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kentik/notify/backend/v0/notify.proto",
}
