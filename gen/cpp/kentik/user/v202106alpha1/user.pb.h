// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kentik/user/v202106alpha1/user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kentik_2fuser_2fv202106alpha1_2fuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kentik_2fuser_2fv202106alpha1_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "kentik/core/v202012alpha1/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kentik_2fuser_2fv202106alpha1_2fuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
namespace kentik {
namespace user {
namespace v202106alpha1 {
class CreateUserRequest;
class CreateUserRequestDefaultTypeInternal;
extern CreateUserRequestDefaultTypeInternal _CreateUserRequest_default_instance_;
class CreateUserResponse;
class CreateUserResponseDefaultTypeInternal;
extern CreateUserResponseDefaultTypeInternal _CreateUserResponse_default_instance_;
class DeleteUserRequest;
class DeleteUserRequestDefaultTypeInternal;
extern DeleteUserRequestDefaultTypeInternal _DeleteUserRequest_default_instance_;
class DeleteUserResponse;
class DeleteUserResponseDefaultTypeInternal;
extern DeleteUserResponseDefaultTypeInternal _DeleteUserResponse_default_instance_;
class GetUserRequest;
class GetUserRequestDefaultTypeInternal;
extern GetUserRequestDefaultTypeInternal _GetUserRequest_default_instance_;
class GetUserResponse;
class GetUserResponseDefaultTypeInternal;
extern GetUserResponseDefaultTypeInternal _GetUserResponse_default_instance_;
class ListUserRequest;
class ListUserRequestDefaultTypeInternal;
extern ListUserRequestDefaultTypeInternal _ListUserRequest_default_instance_;
class ListUserResponse;
class ListUserResponseDefaultTypeInternal;
extern ListUserResponseDefaultTypeInternal _ListUserResponse_default_instance_;
class UpdateUserRequest;
class UpdateUserRequestDefaultTypeInternal;
extern UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
class UpdateUserResponse;
class UpdateUserResponseDefaultTypeInternal;
extern UpdateUserResponseDefaultTypeInternal _UpdateUserResponse_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v202106alpha1
}  // namespace user
}  // namespace kentik
PROTOBUF_NAMESPACE_OPEN
template<> ::kentik::user::v202106alpha1::CreateUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::CreateUserRequest>(Arena*);
template<> ::kentik::user::v202106alpha1::CreateUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::CreateUserResponse>(Arena*);
template<> ::kentik::user::v202106alpha1::DeleteUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::DeleteUserRequest>(Arena*);
template<> ::kentik::user::v202106alpha1::DeleteUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::DeleteUserResponse>(Arena*);
template<> ::kentik::user::v202106alpha1::GetUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::GetUserRequest>(Arena*);
template<> ::kentik::user::v202106alpha1::GetUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::GetUserResponse>(Arena*);
template<> ::kentik::user::v202106alpha1::ListUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::ListUserRequest>(Arena*);
template<> ::kentik::user::v202106alpha1::ListUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::ListUserResponse>(Arena*);
template<> ::kentik::user::v202106alpha1::UpdateUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::UpdateUserRequest>(Arena*);
template<> ::kentik::user::v202106alpha1::UpdateUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::UpdateUserResponse>(Arena*);
template<> ::kentik::user::v202106alpha1::User* Arena::CreateMaybeMessage<::kentik::user::v202106alpha1::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kentik {
namespace user {
namespace v202106alpha1 {

enum Landing : int {
  LANDING_UNSPECIFIED = 0,
  LANDING_OBSERVATION_DECK = 1,
  LANDING_NETWORK_EXPLORER = 2,
  LANDING_LIBRARY = 3,
  LANDING_EXPLORER = 4,
  LANDING_ALERTING = 5,
  LANDING_SYNTHETICS = 6,
  Landing_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Landing_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Landing_IsValid(int value);
constexpr Landing Landing_MIN = LANDING_UNSPECIFIED;
constexpr Landing Landing_MAX = LANDING_SYNTHETICS;
constexpr int Landing_ARRAYSIZE = Landing_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Landing_descriptor();
template<typename T>
inline const std::string& Landing_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Landing>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Landing_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Landing_descriptor(), enum_t_value);
}
inline bool Landing_Parse(
    const std::string& name, Landing* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Landing>(
    Landing_descriptor(), name, value);
}
enum Role : int {
  ROLE_UNSPECIFIED = 0,
  ROLE_MEMBER = 1,
  ROLE_ADMINISTRATOR = 2,
  ROLE_SUPER_ADMINISTRATOR = 3,
  Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Role_IsValid(int value);
constexpr Role Role_MIN = ROLE_UNSPECIFIED;
constexpr Role Role_MAX = ROLE_SUPER_ADMINISTRATOR;
constexpr int Role_ARRAYSIZE = Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Role_descriptor();
template<typename T>
inline const std::string& Role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Role_descriptor(), enum_t_value);
}
inline bool Role_Parse(
    const std::string& name, Role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Role>(
    Role_descriptor(), name, value);
}
// ===================================================================

class User PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.User) */ {
 public:
  inline User() : User(nullptr) {};
  virtual ~User();

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(nullptr);
  }

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUserEmailFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kUserFullNameFieldNumber = 4,
    kLastLoginFieldNumber = 6,
    kCreatedDateFieldNumber = 7,
    kUpdatedDateFieldNumber = 8,
    kRoleFieldNumber = 5,
  };
  // string id = 1[json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string user_email = 2[json_name = "userEmail"];
  void clear_user_email();
  const std::string& user_email() const;
  void set_user_email(const std::string& value);
  void set_user_email(std::string&& value);
  void set_user_email(const char* value);
  void set_user_email(const char* value, size_t size);
  std::string* mutable_user_email();
  std::string* release_user_email();
  void set_allocated_user_email(std::string* user_email);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_email();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_email(
      std::string* user_email);
  private:
  const std::string& _internal_user_email() const;
  void _internal_set_user_email(const std::string& value);
  std::string* _internal_mutable_user_email();
  public:

  // string username = 3[json_name = "username"];
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string user_full_name = 4[json_name = "userFullName"];
  void clear_user_full_name();
  const std::string& user_full_name() const;
  void set_user_full_name(const std::string& value);
  void set_user_full_name(std::string&& value);
  void set_user_full_name(const char* value);
  void set_user_full_name(const char* value, size_t size);
  std::string* mutable_user_full_name();
  std::string* release_user_full_name();
  void set_allocated_user_full_name(std::string* user_full_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_full_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_full_name(
      std::string* user_full_name);
  private:
  const std::string& _internal_user_full_name() const;
  void _internal_set_user_full_name(const std::string& value);
  std::string* _internal_mutable_user_full_name();
  public:

  // .google.protobuf.Timestamp last_login = 6[json_name = "lastLogin"];
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  const PROTOBUF_NAMESPACE_ID::Timestamp& last_login() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_last_login();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_login();
  void set_allocated_last_login(PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_login() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_login();
  public:
  void unsafe_arena_set_allocated_last_login(
      PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_login();

  // .google.protobuf.Timestamp created_date = 7[json_name = "createdDate"];
  bool has_created_date() const;
  private:
  bool _internal_has_created_date() const;
  public:
  void clear_created_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& created_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_created_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_date();
  void set_allocated_created_date(PROTOBUF_NAMESPACE_ID::Timestamp* created_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_date();
  public:
  void unsafe_arena_set_allocated_created_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* created_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_date();

  // .google.protobuf.Timestamp updated_date = 8[json_name = "updatedDate"];
  bool has_updated_date() const;
  private:
  bool _internal_has_updated_date() const;
  public:
  void clear_updated_date();
  const PROTOBUF_NAMESPACE_ID::Timestamp& updated_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_date();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_date();
  void set_allocated_updated_date(PROTOBUF_NAMESPACE_ID::Timestamp* updated_date);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_date() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_date();
  public:
  void unsafe_arena_set_allocated_updated_date(
      PROTOBUF_NAMESPACE_ID::Timestamp* updated_date);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_date();

  // .kentik.user.v202106alpha1.Role role = 5[json_name = "role"];
  void clear_role();
  ::kentik::user::v202106alpha1::Role role() const;
  void set_role(::kentik::user::v202106alpha1::Role value);
  private:
  ::kentik::user::v202106alpha1::Role _internal_role() const;
  void _internal_set_role(::kentik::user::v202106alpha1::Role value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_full_name_;
  PROTOBUF_NAMESPACE_ID::Timestamp* last_login_;
  PROTOBUF_NAMESPACE_ID::Timestamp* created_date_;
  PROTOBUF_NAMESPACE_ID::Timestamp* updated_date_;
  int role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.ListUserRequest) */ {
 public:
  inline ListUserRequest() : ListUserRequest(nullptr) {};
  virtual ~ListUserRequest();

  ListUserRequest(const ListUserRequest& from);
  ListUserRequest(ListUserRequest&& from) noexcept
    : ListUserRequest() {
    *this = ::std::move(from);
  }

  inline ListUserRequest& operator=(const ListUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUserRequest& operator=(ListUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUserRequest* internal_default_instance() {
    return reinterpret_cast<const ListUserRequest*>(
               &_ListUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListUserRequest& a, ListUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListUserRequest* New() const final {
    return CreateMaybeMessage<ListUserRequest>(nullptr);
  }

  ListUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListUserRequest& from);
  void MergeFrom(const ListUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.ListUserRequest";
  }
  protected:
  explicit ListUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.ListUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.ListUserResponse) */ {
 public:
  inline ListUserResponse() : ListUserResponse(nullptr) {};
  virtual ~ListUserResponse();

  ListUserResponse(const ListUserResponse& from);
  ListUserResponse(ListUserResponse&& from) noexcept
    : ListUserResponse() {
    *this = ::std::move(from);
  }

  inline ListUserResponse& operator=(const ListUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUserResponse& operator=(ListUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUserResponse* internal_default_instance() {
    return reinterpret_cast<const ListUserResponse*>(
               &_ListUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListUserResponse& a, ListUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListUserResponse* New() const final {
    return CreateMaybeMessage<ListUserResponse>(nullptr);
  }

  ListUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListUserResponse& from);
  void MergeFrom(const ListUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.ListUserResponse";
  }
  protected:
  explicit ListUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
    kInvalidCountFieldNumber = 2,
  };
  // repeated .kentik.user.v202106alpha1.User users = 1[json_name = "users"];
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::kentik::user::v202106alpha1::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202106alpha1::User >*
      mutable_users();
  private:
  const ::kentik::user::v202106alpha1::User& _internal_users(int index) const;
  ::kentik::user::v202106alpha1::User* _internal_add_users();
  public:
  const ::kentik::user::v202106alpha1::User& users(int index) const;
  ::kentik::user::v202106alpha1::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202106alpha1::User >&
      users() const;

  // uint32 invalid_count = 2[json_name = "invalidCount"];
  void clear_invalid_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 invalid_count() const;
  void set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_invalid_count() const;
  void _internal_set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.ListUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202106alpha1::User > users_;
  ::PROTOBUF_NAMESPACE_ID::uint32 invalid_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.GetUserRequest) */ {
 public:
  inline GetUserRequest() : GetUserRequest(nullptr) {};
  virtual ~GetUserRequest();

  GetUserRequest(const GetUserRequest& from);
  GetUserRequest(GetUserRequest&& from) noexcept
    : GetUserRequest() {
    *this = ::std::move(from);
  }

  inline GetUserRequest& operator=(const GetUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserRequest& operator=(GetUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserRequest*>(
               &_GetUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetUserRequest& a, GetUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUserRequest* New() const final {
    return CreateMaybeMessage<GetUserRequest>(nullptr);
  }

  GetUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUserRequest& from);
  void MergeFrom(const GetUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.GetUserRequest";
  }
  protected:
  explicit GetUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.GetUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.GetUserResponse) */ {
 public:
  inline GetUserResponse() : GetUserResponse(nullptr) {};
  virtual ~GetUserResponse();

  GetUserResponse(const GetUserResponse& from);
  GetUserResponse(GetUserResponse&& from) noexcept
    : GetUserResponse() {
    *this = ::std::move(from);
  }

  inline GetUserResponse& operator=(const GetUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserResponse& operator=(GetUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserResponse*>(
               &_GetUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetUserResponse& a, GetUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUserResponse* New() const final {
    return CreateMaybeMessage<GetUserResponse>(nullptr);
  }

  GetUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUserResponse& from);
  void MergeFrom(const GetUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.GetUserResponse";
  }
  protected:
  explicit GetUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202106alpha1::User& user() const;
  ::kentik::user::v202106alpha1::User* release_user();
  ::kentik::user::v202106alpha1::User* mutable_user();
  void set_allocated_user(::kentik::user::v202106alpha1::User* user);
  private:
  const ::kentik::user::v202106alpha1::User& _internal_user() const;
  ::kentik::user::v202106alpha1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202106alpha1::User* user);
  ::kentik::user::v202106alpha1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.GetUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202106alpha1::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.CreateUserRequest) */ {
 public:
  inline CreateUserRequest() : CreateUserRequest(nullptr) {};
  virtual ~CreateUserRequest();

  CreateUserRequest(const CreateUserRequest& from);
  CreateUserRequest(CreateUserRequest&& from) noexcept
    : CreateUserRequest() {
    *this = ::std::move(from);
  }

  inline CreateUserRequest& operator=(const CreateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserRequest& operator=(CreateUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateUserRequest* internal_default_instance() {
    return reinterpret_cast<const CreateUserRequest*>(
               &_CreateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateUserRequest& a, CreateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateUserRequest* New() const final {
    return CreateMaybeMessage<CreateUserRequest>(nullptr);
  }

  CreateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateUserRequest& from);
  void MergeFrom(const CreateUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.CreateUserRequest";
  }
  protected:
  explicit CreateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202106alpha1::User& user() const;
  ::kentik::user::v202106alpha1::User* release_user();
  ::kentik::user::v202106alpha1::User* mutable_user();
  void set_allocated_user(::kentik::user::v202106alpha1::User* user);
  private:
  const ::kentik::user::v202106alpha1::User& _internal_user() const;
  ::kentik::user::v202106alpha1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202106alpha1::User* user);
  ::kentik::user::v202106alpha1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.CreateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202106alpha1::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.CreateUserResponse) */ {
 public:
  inline CreateUserResponse() : CreateUserResponse(nullptr) {};
  virtual ~CreateUserResponse();

  CreateUserResponse(const CreateUserResponse& from);
  CreateUserResponse(CreateUserResponse&& from) noexcept
    : CreateUserResponse() {
    *this = ::std::move(from);
  }

  inline CreateUserResponse& operator=(const CreateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserResponse& operator=(CreateUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateUserResponse* internal_default_instance() {
    return reinterpret_cast<const CreateUserResponse*>(
               &_CreateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateUserResponse& a, CreateUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateUserResponse* New() const final {
    return CreateMaybeMessage<CreateUserResponse>(nullptr);
  }

  CreateUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateUserResponse& from);
  void MergeFrom(const CreateUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.CreateUserResponse";
  }
  protected:
  explicit CreateUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202106alpha1::User& user() const;
  ::kentik::user::v202106alpha1::User* release_user();
  ::kentik::user::v202106alpha1::User* mutable_user();
  void set_allocated_user(::kentik::user::v202106alpha1::User* user);
  private:
  const ::kentik::user::v202106alpha1::User& _internal_user() const;
  ::kentik::user::v202106alpha1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202106alpha1::User* user);
  ::kentik::user::v202106alpha1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.CreateUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202106alpha1::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.UpdateUserRequest) */ {
 public:
  inline UpdateUserRequest() : UpdateUserRequest(nullptr) {};
  virtual ~UpdateUserRequest();

  UpdateUserRequest(const UpdateUserRequest& from);
  UpdateUserRequest(UpdateUserRequest&& from) noexcept
    : UpdateUserRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest& operator=(const UpdateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest& operator=(UpdateUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateUserRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest*>(
               &_UpdateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateUserRequest& a, UpdateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateUserRequest* New() const final {
    return CreateMaybeMessage<UpdateUserRequest>(nullptr);
  }

  UpdateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateUserRequest& from);
  void MergeFrom(const UpdateUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.UpdateUserRequest";
  }
  protected:
  explicit UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202106alpha1::User& user() const;
  ::kentik::user::v202106alpha1::User* release_user();
  ::kentik::user::v202106alpha1::User* mutable_user();
  void set_allocated_user(::kentik::user::v202106alpha1::User* user);
  private:
  const ::kentik::user::v202106alpha1::User& _internal_user() const;
  ::kentik::user::v202106alpha1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202106alpha1::User* user);
  ::kentik::user::v202106alpha1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.UpdateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202106alpha1::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.UpdateUserResponse) */ {
 public:
  inline UpdateUserResponse() : UpdateUserResponse(nullptr) {};
  virtual ~UpdateUserResponse();

  UpdateUserResponse(const UpdateUserResponse& from);
  UpdateUserResponse(UpdateUserResponse&& from) noexcept
    : UpdateUserResponse() {
    *this = ::std::move(from);
  }

  inline UpdateUserResponse& operator=(const UpdateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserResponse& operator=(UpdateUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateUserResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateUserResponse*>(
               &_UpdateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateUserResponse& a, UpdateUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateUserResponse* New() const final {
    return CreateMaybeMessage<UpdateUserResponse>(nullptr);
  }

  UpdateUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateUserResponse& from);
  void MergeFrom(const UpdateUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.UpdateUserResponse";
  }
  protected:
  explicit UpdateUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202106alpha1::User& user() const;
  ::kentik::user::v202106alpha1::User* release_user();
  ::kentik::user::v202106alpha1::User* mutable_user();
  void set_allocated_user(::kentik::user::v202106alpha1::User* user);
  private:
  const ::kentik::user::v202106alpha1::User& _internal_user() const;
  ::kentik::user::v202106alpha1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202106alpha1::User* user);
  ::kentik::user::v202106alpha1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.UpdateUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202106alpha1::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.DeleteUserRequest) */ {
 public:
  inline DeleteUserRequest() : DeleteUserRequest(nullptr) {};
  virtual ~DeleteUserRequest();

  DeleteUserRequest(const DeleteUserRequest& from);
  DeleteUserRequest(DeleteUserRequest&& from) noexcept
    : DeleteUserRequest() {
    *this = ::std::move(from);
  }

  inline DeleteUserRequest& operator=(const DeleteUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserRequest& operator=(DeleteUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteUserRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteUserRequest*>(
               &_DeleteUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteUserRequest& a, DeleteUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteUserRequest* New() const final {
    return CreateMaybeMessage<DeleteUserRequest>(nullptr);
  }

  DeleteUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteUserRequest& from);
  void MergeFrom(const DeleteUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.DeleteUserRequest";
  }
  protected:
  explicit DeleteUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.DeleteUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202106alpha1.DeleteUserResponse) */ {
 public:
  inline DeleteUserResponse() : DeleteUserResponse(nullptr) {};
  virtual ~DeleteUserResponse();

  DeleteUserResponse(const DeleteUserResponse& from);
  DeleteUserResponse(DeleteUserResponse&& from) noexcept
    : DeleteUserResponse() {
    *this = ::std::move(from);
  }

  inline DeleteUserResponse& operator=(const DeleteUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserResponse& operator=(DeleteUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteUserResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteUserResponse*>(
               &_DeleteUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteUserResponse& a, DeleteUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteUserResponse* New() const final {
    return CreateMaybeMessage<DeleteUserResponse>(nullptr);
  }

  DeleteUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteUserResponse& from);
  void MergeFrom(const DeleteUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202106alpha1.DeleteUserResponse";
  }
  protected:
  explicit DeleteUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202106alpha1_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.user.v202106alpha1.DeleteUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202106alpha1_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// string id = 1[json_name = "id"];
inline void User::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.id)
  return _internal_id();
}
inline void User::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.User.id)
}
inline std::string* User::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.id)
  return _internal_mutable_id();
}
inline const std::string& User::_internal_id() const {
  return id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202106alpha1.User.id)
}
inline void User::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202106alpha1.User.id)
}
inline void User::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202106alpha1.User.id)
}
inline std::string* User::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.id)
}
inline std::string* User::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202106alpha1.User.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.id)
}

// string user_email = 2[json_name = "userEmail"];
inline void User::clear_user_email() {
  user_email_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::user_email() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.user_email)
  return _internal_user_email();
}
inline void User::set_user_email(const std::string& value) {
  _internal_set_user_email(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.User.user_email)
}
inline std::string* User::mutable_user_email() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.user_email)
  return _internal_mutable_user_email();
}
inline const std::string& User::_internal_user_email() const {
  return user_email_.Get();
}
inline void User::_internal_set_user_email(const std::string& value) {
  
  user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_user_email(std::string&& value) {
  
  user_email_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202106alpha1.User.user_email)
}
inline void User::set_user_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202106alpha1.User.user_email)
}
inline void User::set_user_email(const char* value,
    size_t size) {
  
  user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202106alpha1.User.user_email)
}
inline std::string* User::_internal_mutable_user_email() {
  
  return user_email_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_user_email() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.user_email)
  return user_email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_user_email(std::string* user_email) {
  if (user_email != nullptr) {
    
  } else {
    
  }
  user_email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_email,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.user_email)
}
inline std::string* User::unsafe_arena_release_user_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202106alpha1.User.user_email)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_email_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_user_email(
    std::string* user_email) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_email != nullptr) {
    
  } else {
    
  }
  user_email_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_email, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.user_email)
}

// string username = 3[json_name = "username"];
inline void User::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.username)
  return _internal_username();
}
inline void User::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.User.username)
}
inline std::string* User::mutable_username() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.username)
  return _internal_mutable_username();
}
inline const std::string& User::_internal_username() const {
  return username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_username(std::string&& value) {
  
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202106alpha1.User.username)
}
inline void User::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202106alpha1.User.username)
}
inline void User::set_username(const char* value,
    size_t size) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202106alpha1.User.username)
}
inline std::string* User::_internal_mutable_username() {
  
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.username)
}
inline std::string* User::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202106alpha1.User.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    
  } else {
    
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.username)
}

// string user_full_name = 4[json_name = "userFullName"];
inline void User::clear_user_full_name() {
  user_full_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::user_full_name() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.user_full_name)
  return _internal_user_full_name();
}
inline void User::set_user_full_name(const std::string& value) {
  _internal_set_user_full_name(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.User.user_full_name)
}
inline std::string* User::mutable_user_full_name() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.user_full_name)
  return _internal_mutable_user_full_name();
}
inline const std::string& User::_internal_user_full_name() const {
  return user_full_name_.Get();
}
inline void User::_internal_set_user_full_name(const std::string& value) {
  
  user_full_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_user_full_name(std::string&& value) {
  
  user_full_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202106alpha1.User.user_full_name)
}
inline void User::set_user_full_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_full_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202106alpha1.User.user_full_name)
}
inline void User::set_user_full_name(const char* value,
    size_t size) {
  
  user_full_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202106alpha1.User.user_full_name)
}
inline std::string* User::_internal_mutable_user_full_name() {
  
  return user_full_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_user_full_name() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.user_full_name)
  return user_full_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_user_full_name(std::string* user_full_name) {
  if (user_full_name != nullptr) {
    
  } else {
    
  }
  user_full_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_full_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.user_full_name)
}
inline std::string* User::unsafe_arena_release_user_full_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202106alpha1.User.user_full_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_full_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_user_full_name(
    std::string* user_full_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_full_name != nullptr) {
    
  } else {
    
  }
  user_full_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_full_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.user_full_name)
}

// .kentik.user.v202106alpha1.Role role = 5[json_name = "role"];
inline void User::clear_role() {
  role_ = 0;
}
inline ::kentik::user::v202106alpha1::Role User::_internal_role() const {
  return static_cast< ::kentik::user::v202106alpha1::Role >(role_);
}
inline ::kentik::user::v202106alpha1::Role User::role() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.role)
  return _internal_role();
}
inline void User::_internal_set_role(::kentik::user::v202106alpha1::Role value) {
  
  role_ = value;
}
inline void User::set_role(::kentik::user::v202106alpha1::Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.User.role)
}

// .google.protobuf.Timestamp last_login = 6[json_name = "lastLogin"];
inline bool User::_internal_has_last_login() const {
  return this != internal_default_instance() && last_login_ != nullptr;
}
inline bool User::has_last_login() const {
  return _internal_has_last_login();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_last_login() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = last_login_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::last_login() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.last_login)
  return _internal_last_login();
}
inline void User::unsafe_arena_set_allocated_last_login(
    PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  last_login_ = last_login;
  if (last_login) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.last_login)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::release_last_login() {
  auto temp = unsafe_arena_release_last_login();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_last_login() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.last_login)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_login_;
  last_login_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_last_login() {
  
  if (last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    last_login_ = p;
  }
  return last_login_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_last_login() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.last_login)
  return _internal_mutable_last_login();
}
inline void User::set_allocated_last_login(PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  if (last_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login)->GetArena();
    if (message_arena != submessage_arena) {
      last_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_login, submessage_arena);
    }
    
  } else {
    
  }
  last_login_ = last_login;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.last_login)
}

// .google.protobuf.Timestamp created_date = 7[json_name = "createdDate"];
inline bool User::_internal_has_created_date() const {
  return this != internal_default_instance() && created_date_ != nullptr;
}
inline bool User::has_created_date() const {
  return _internal_has_created_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_created_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = created_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::created_date() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.created_date)
  return _internal_created_date();
}
inline void User::unsafe_arena_set_allocated_created_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* created_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_date_);
  }
  created_date_ = created_date;
  if (created_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.created_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::release_created_date() {
  auto temp = unsafe_arena_release_created_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_created_date() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.created_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_date_;
  created_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_created_date() {
  
  if (created_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    created_date_ = p;
  }
  return created_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_created_date() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.created_date)
  return _internal_mutable_created_date();
}
inline void User::set_allocated_created_date(PROTOBUF_NAMESPACE_ID::Timestamp* created_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_date_);
  }
  if (created_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_date)->GetArena();
    if (message_arena != submessage_arena) {
      created_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_date, submessage_arena);
    }
    
  } else {
    
  }
  created_date_ = created_date;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.created_date)
}

// .google.protobuf.Timestamp updated_date = 8[json_name = "updatedDate"];
inline bool User::_internal_has_updated_date() const {
  return this != internal_default_instance() && updated_date_ != nullptr;
}
inline bool User::has_updated_date() const {
  return _internal_has_updated_date();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_updated_date() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_date_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::updated_date() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.User.updated_date)
  return _internal_updated_date();
}
inline void User::unsafe_arena_set_allocated_updated_date(
    PROTOBUF_NAMESPACE_ID::Timestamp* updated_date) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_date_);
  }
  updated_date_ = updated_date;
  if (updated_date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.User.updated_date)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::release_updated_date() {
  auto temp = unsafe_arena_release_updated_date();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_updated_date() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.User.updated_date)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_date_;
  updated_date_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_updated_date() {
  
  if (updated_date_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    updated_date_ = p;
  }
  return updated_date_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_updated_date() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.User.updated_date)
  return _internal_mutable_updated_date();
}
inline void User::set_allocated_updated_date(PROTOBUF_NAMESPACE_ID::Timestamp* updated_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_date_);
  }
  if (updated_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_date)->GetArena();
    if (message_arena != submessage_arena) {
      updated_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_date, submessage_arena);
    }
    
  } else {
    
  }
  updated_date_ = updated_date;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.User.updated_date)
}

// -------------------------------------------------------------------

// ListUserRequest

// -------------------------------------------------------------------

// ListUserResponse

// repeated .kentik.user.v202106alpha1.User users = 1[json_name = "users"];
inline int ListUserResponse::_internal_users_size() const {
  return users_.size();
}
inline int ListUserResponse::users_size() const {
  return _internal_users_size();
}
inline void ListUserResponse::clear_users() {
  users_.Clear();
}
inline ::kentik::user::v202106alpha1::User* ListUserResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.ListUserResponse.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202106alpha1::User >*
ListUserResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:kentik.user.v202106alpha1.ListUserResponse.users)
  return &users_;
}
inline const ::kentik::user::v202106alpha1::User& ListUserResponse::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::kentik::user::v202106alpha1::User& ListUserResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.ListUserResponse.users)
  return _internal_users(index);
}
inline ::kentik::user::v202106alpha1::User* ListUserResponse::_internal_add_users() {
  return users_.Add();
}
inline ::kentik::user::v202106alpha1::User* ListUserResponse::add_users() {
  // @@protoc_insertion_point(field_add:kentik.user.v202106alpha1.ListUserResponse.users)
  return _internal_add_users();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202106alpha1::User >&
ListUserResponse::users() const {
  // @@protoc_insertion_point(field_list:kentik.user.v202106alpha1.ListUserResponse.users)
  return users_;
}

// uint32 invalid_count = 2[json_name = "invalidCount"];
inline void ListUserResponse::clear_invalid_count() {
  invalid_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListUserResponse::_internal_invalid_count() const {
  return invalid_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListUserResponse::invalid_count() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.ListUserResponse.invalid_count)
  return _internal_invalid_count();
}
inline void ListUserResponse::_internal_set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  invalid_count_ = value;
}
inline void ListUserResponse::set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_invalid_count(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.ListUserResponse.invalid_count)
}

// -------------------------------------------------------------------

// GetUserRequest

// string id = 1[json_name = "id"];
inline void GetUserRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetUserRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.GetUserRequest.id)
  return _internal_id();
}
inline void GetUserRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.GetUserRequest.id)
}
inline std::string* GetUserRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.GetUserRequest.id)
  return _internal_mutable_id();
}
inline const std::string& GetUserRequest::_internal_id() const {
  return id_.Get();
}
inline void GetUserRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetUserRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202106alpha1.GetUserRequest.id)
}
inline void GetUserRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202106alpha1.GetUserRequest.id)
}
inline void GetUserRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202106alpha1.GetUserRequest.id)
}
inline std::string* GetUserRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetUserRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.GetUserRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetUserRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.GetUserRequest.id)
}
inline std::string* GetUserRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202106alpha1.GetUserRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetUserRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.GetUserRequest.id)
}

// -------------------------------------------------------------------

// GetUserResponse

// .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
inline bool GetUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetUserResponse::has_user() const {
  return _internal_has_user();
}
inline void GetUserResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202106alpha1::User& GetUserResponse::_internal_user() const {
  const ::kentik::user::v202106alpha1::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202106alpha1::User*>(
      &::kentik::user::v202106alpha1::_User_default_instance_);
}
inline const ::kentik::user::v202106alpha1::User& GetUserResponse::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.GetUserResponse.user)
  return _internal_user();
}
inline void GetUserResponse::unsafe_arena_set_allocated_user(
    ::kentik::user::v202106alpha1::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.GetUserResponse.user)
}
inline ::kentik::user::v202106alpha1::User* GetUserResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202106alpha1::User* GetUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.GetUserResponse.user)
  
  ::kentik::user::v202106alpha1::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202106alpha1::User* GetUserResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202106alpha1::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202106alpha1::User* GetUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.GetUserResponse.user)
  return _internal_mutable_user();
}
inline void GetUserResponse::set_allocated_user(::kentik::user::v202106alpha1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.GetUserResponse.user)
}

// -------------------------------------------------------------------

// CreateUserRequest

// .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
inline bool CreateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool CreateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void CreateUserRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202106alpha1::User& CreateUserRequest::_internal_user() const {
  const ::kentik::user::v202106alpha1::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202106alpha1::User*>(
      &::kentik::user::v202106alpha1::_User_default_instance_);
}
inline const ::kentik::user::v202106alpha1::User& CreateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.CreateUserRequest.user)
  return _internal_user();
}
inline void CreateUserRequest::unsafe_arena_set_allocated_user(
    ::kentik::user::v202106alpha1::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.CreateUserRequest.user)
}
inline ::kentik::user::v202106alpha1::User* CreateUserRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202106alpha1::User* CreateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.CreateUserRequest.user)
  
  ::kentik::user::v202106alpha1::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202106alpha1::User* CreateUserRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202106alpha1::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202106alpha1::User* CreateUserRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.CreateUserRequest.user)
  return _internal_mutable_user();
}
inline void CreateUserRequest::set_allocated_user(::kentik::user::v202106alpha1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.CreateUserRequest.user)
}

// -------------------------------------------------------------------

// CreateUserResponse

// .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
inline bool CreateUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool CreateUserResponse::has_user() const {
  return _internal_has_user();
}
inline void CreateUserResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202106alpha1::User& CreateUserResponse::_internal_user() const {
  const ::kentik::user::v202106alpha1::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202106alpha1::User*>(
      &::kentik::user::v202106alpha1::_User_default_instance_);
}
inline const ::kentik::user::v202106alpha1::User& CreateUserResponse::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.CreateUserResponse.user)
  return _internal_user();
}
inline void CreateUserResponse::unsafe_arena_set_allocated_user(
    ::kentik::user::v202106alpha1::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.CreateUserResponse.user)
}
inline ::kentik::user::v202106alpha1::User* CreateUserResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202106alpha1::User* CreateUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.CreateUserResponse.user)
  
  ::kentik::user::v202106alpha1::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202106alpha1::User* CreateUserResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202106alpha1::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202106alpha1::User* CreateUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.CreateUserResponse.user)
  return _internal_mutable_user();
}
inline void CreateUserResponse::set_allocated_user(::kentik::user::v202106alpha1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.CreateUserResponse.user)
}

// -------------------------------------------------------------------

// UpdateUserRequest

// .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
inline bool UpdateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202106alpha1::User& UpdateUserRequest::_internal_user() const {
  const ::kentik::user::v202106alpha1::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202106alpha1::User*>(
      &::kentik::user::v202106alpha1::_User_default_instance_);
}
inline const ::kentik::user::v202106alpha1::User& UpdateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.UpdateUserRequest.user)
  return _internal_user();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_user(
    ::kentik::user::v202106alpha1::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.UpdateUserRequest.user)
}
inline ::kentik::user::v202106alpha1::User* UpdateUserRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202106alpha1::User* UpdateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.UpdateUserRequest.user)
  
  ::kentik::user::v202106alpha1::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202106alpha1::User* UpdateUserRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202106alpha1::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202106alpha1::User* UpdateUserRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.UpdateUserRequest.user)
  return _internal_mutable_user();
}
inline void UpdateUserRequest::set_allocated_user(::kentik::user::v202106alpha1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.UpdateUserRequest.user)
}

// -------------------------------------------------------------------

// UpdateUserResponse

// .kentik.user.v202106alpha1.User user = 1[json_name = "user"];
inline bool UpdateUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserResponse::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202106alpha1::User& UpdateUserResponse::_internal_user() const {
  const ::kentik::user::v202106alpha1::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202106alpha1::User*>(
      &::kentik::user::v202106alpha1::_User_default_instance_);
}
inline const ::kentik::user::v202106alpha1::User& UpdateUserResponse::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.UpdateUserResponse.user)
  return _internal_user();
}
inline void UpdateUserResponse::unsafe_arena_set_allocated_user(
    ::kentik::user::v202106alpha1::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.UpdateUserResponse.user)
}
inline ::kentik::user::v202106alpha1::User* UpdateUserResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202106alpha1::User* UpdateUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.UpdateUserResponse.user)
  
  ::kentik::user::v202106alpha1::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202106alpha1::User* UpdateUserResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202106alpha1::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202106alpha1::User* UpdateUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.UpdateUserResponse.user)
  return _internal_mutable_user();
}
inline void UpdateUserResponse::set_allocated_user(::kentik::user::v202106alpha1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.UpdateUserResponse.user)
}

// -------------------------------------------------------------------

// DeleteUserRequest

// string id = 1[json_name = "id"];
inline void DeleteUserRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteUserRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202106alpha1.DeleteUserRequest.id)
  return _internal_id();
}
inline void DeleteUserRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202106alpha1.DeleteUserRequest.id)
}
inline std::string* DeleteUserRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202106alpha1.DeleteUserRequest.id)
  return _internal_mutable_id();
}
inline const std::string& DeleteUserRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteUserRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteUserRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202106alpha1.DeleteUserRequest.id)
}
inline void DeleteUserRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202106alpha1.DeleteUserRequest.id)
}
inline void DeleteUserRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202106alpha1.DeleteUserRequest.id)
}
inline std::string* DeleteUserRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteUserRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202106alpha1.DeleteUserRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteUserRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202106alpha1.DeleteUserRequest.id)
}
inline std::string* DeleteUserRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202106alpha1.DeleteUserRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DeleteUserRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202106alpha1.DeleteUserRequest.id)
}

// -------------------------------------------------------------------

// DeleteUserResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v202106alpha1
}  // namespace user
}  // namespace kentik

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kentik::user::v202106alpha1::Landing> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::user::v202106alpha1::Landing>() {
  return ::kentik::user::v202106alpha1::Landing_descriptor();
}
template <> struct is_proto_enum< ::kentik::user::v202106alpha1::Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::user::v202106alpha1::Role>() {
  return ::kentik::user::v202106alpha1::Role_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kentik_2fuser_2fv202106alpha1_2fuser_2eproto
