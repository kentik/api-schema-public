// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kentik/user/v202211/user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kentik_2fuser_2fv202211_2fuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kentik_2fuser_2fv202211_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "kentik/core/v202012alpha1/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kentik_2fuser_2fv202211_2fuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto;
namespace kentik {
namespace user {
namespace v202211 {
class CreateUserRequest;
class CreateUserRequestDefaultTypeInternal;
extern CreateUserRequestDefaultTypeInternal _CreateUserRequest_default_instance_;
class CreateUserResponse;
class CreateUserResponseDefaultTypeInternal;
extern CreateUserResponseDefaultTypeInternal _CreateUserResponse_default_instance_;
class DeleteUserRequest;
class DeleteUserRequestDefaultTypeInternal;
extern DeleteUserRequestDefaultTypeInternal _DeleteUserRequest_default_instance_;
class DeleteUserResponse;
class DeleteUserResponseDefaultTypeInternal;
extern DeleteUserResponseDefaultTypeInternal _DeleteUserResponse_default_instance_;
class GetUserRequest;
class GetUserRequestDefaultTypeInternal;
extern GetUserRequestDefaultTypeInternal _GetUserRequest_default_instance_;
class GetUserResponse;
class GetUserResponseDefaultTypeInternal;
extern GetUserResponseDefaultTypeInternal _GetUserResponse_default_instance_;
class ListUsersRequest;
class ListUsersRequestDefaultTypeInternal;
extern ListUsersRequestDefaultTypeInternal _ListUsersRequest_default_instance_;
class ListUsersResponse;
class ListUsersResponseDefaultTypeInternal;
extern ListUsersResponseDefaultTypeInternal _ListUsersResponse_default_instance_;
class PermissionEntry;
class PermissionEntryDefaultTypeInternal;
extern PermissionEntryDefaultTypeInternal _PermissionEntry_default_instance_;
class ResetActiveSessionsRequest;
class ResetActiveSessionsRequestDefaultTypeInternal;
extern ResetActiveSessionsRequestDefaultTypeInternal _ResetActiveSessionsRequest_default_instance_;
class ResetActiveSessionsResponse;
class ResetActiveSessionsResponseDefaultTypeInternal;
extern ResetActiveSessionsResponseDefaultTypeInternal _ResetActiveSessionsResponse_default_instance_;
class ResetApiTokenRequest;
class ResetApiTokenRequestDefaultTypeInternal;
extern ResetApiTokenRequestDefaultTypeInternal _ResetApiTokenRequest_default_instance_;
class ResetApiTokenResponse;
class ResetApiTokenResponseDefaultTypeInternal;
extern ResetApiTokenResponseDefaultTypeInternal _ResetApiTokenResponse_default_instance_;
class UpdateUserRequest;
class UpdateUserRequestDefaultTypeInternal;
extern UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
class UpdateUserResponse;
class UpdateUserResponseDefaultTypeInternal;
extern UpdateUserResponseDefaultTypeInternal _UpdateUserResponse_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v202211
}  // namespace user
}  // namespace kentik
PROTOBUF_NAMESPACE_OPEN
template<> ::kentik::user::v202211::CreateUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::CreateUserRequest>(Arena*);
template<> ::kentik::user::v202211::CreateUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::CreateUserResponse>(Arena*);
template<> ::kentik::user::v202211::DeleteUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::DeleteUserRequest>(Arena*);
template<> ::kentik::user::v202211::DeleteUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::DeleteUserResponse>(Arena*);
template<> ::kentik::user::v202211::GetUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::GetUserRequest>(Arena*);
template<> ::kentik::user::v202211::GetUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::GetUserResponse>(Arena*);
template<> ::kentik::user::v202211::ListUsersRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::ListUsersRequest>(Arena*);
template<> ::kentik::user::v202211::ListUsersResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::ListUsersResponse>(Arena*);
template<> ::kentik::user::v202211::PermissionEntry* Arena::CreateMaybeMessage<::kentik::user::v202211::PermissionEntry>(Arena*);
template<> ::kentik::user::v202211::ResetActiveSessionsRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::ResetActiveSessionsRequest>(Arena*);
template<> ::kentik::user::v202211::ResetActiveSessionsResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::ResetActiveSessionsResponse>(Arena*);
template<> ::kentik::user::v202211::ResetApiTokenRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::ResetApiTokenRequest>(Arena*);
template<> ::kentik::user::v202211::ResetApiTokenResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::ResetApiTokenResponse>(Arena*);
template<> ::kentik::user::v202211::UpdateUserRequest* Arena::CreateMaybeMessage<::kentik::user::v202211::UpdateUserRequest>(Arena*);
template<> ::kentik::user::v202211::UpdateUserResponse* Arena::CreateMaybeMessage<::kentik::user::v202211::UpdateUserResponse>(Arena*);
template<> ::kentik::user::v202211::User* Arena::CreateMaybeMessage<::kentik::user::v202211::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kentik {
namespace user {
namespace v202211 {

enum Role : int {
  ROLE_UNSPECIFIED = 0,
  ROLE_MEMBER = 1,
  ROLE_ADMINISTRATOR = 2,
  ROLE_SUPER_ADMINISTRATOR = 3,
  Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Role_IsValid(int value);
constexpr Role Role_MIN = ROLE_UNSPECIFIED;
constexpr Role Role_MAX = ROLE_SUPER_ADMINISTRATOR;
constexpr int Role_ARRAYSIZE = Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Role_descriptor();
template<typename T>
inline const std::string& Role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Role_descriptor(), enum_t_value);
}
inline bool Role_Parse(
    const std::string& name, Role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Role>(
    Role_descriptor(), name, value);
}
// ===================================================================

class PermissionEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.PermissionEntry) */ {
 public:
  inline PermissionEntry() : PermissionEntry(nullptr) {};
  virtual ~PermissionEntry();

  PermissionEntry(const PermissionEntry& from);
  PermissionEntry(PermissionEntry&& from) noexcept
    : PermissionEntry() {
    *this = ::std::move(from);
  }

  inline PermissionEntry& operator=(const PermissionEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionEntry& operator=(PermissionEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PermissionEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionEntry* internal_default_instance() {
    return reinterpret_cast<const PermissionEntry*>(
               &_PermissionEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PermissionEntry& a, PermissionEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PermissionEntry* New() const final {
    return CreateMaybeMessage<PermissionEntry>(nullptr);
  }

  PermissionEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PermissionEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PermissionEntry& from);
  void MergeFrom(const PermissionEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.PermissionEntry";
  }
  protected:
  explicit PermissionEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilityFieldNumber = 1,
    kAllowedFieldNumber = 2,
  };
  // string capability = 1[json_name = "capability", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_capability();
  const std::string& capability() const;
  void set_capability(const std::string& value);
  void set_capability(std::string&& value);
  void set_capability(const char* value);
  void set_capability(const char* value, size_t size);
  std::string* mutable_capability();
  std::string* release_capability();
  void set_allocated_capability(std::string* capability);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_capability();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_capability(
      std::string* capability);
  private:
  const std::string& _internal_capability() const;
  void _internal_set_capability(const std::string& value);
  std::string* _internal_mutable_capability();
  public:

  // bool allowed = 2[json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.PermissionEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capability_;
  bool allowed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class User PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.User) */ {
 public:
  inline User() : User(nullptr) {};
  virtual ~User();

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(nullptr);
  }

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 6,
    kIdFieldNumber = 1,
    kUserEmailFieldNumber = 2,
    kUserFullNameFieldNumber = 4,
    kFilterFieldNumber = 7,
    kLastLoginFieldNumber = 8,
    kCdateFieldNumber = 9,
    kEdateFieldNumber = 10,
    kRoleFieldNumber = 5,
  };
  // repeated .kentik.user.v202211.PermissionEntry permissions = 6[json_name = "permissions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::kentik::user::v202211::PermissionEntry* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::PermissionEntry >*
      mutable_permissions();
  private:
  const ::kentik::user::v202211::PermissionEntry& _internal_permissions(int index) const;
  ::kentik::user::v202211::PermissionEntry* _internal_add_permissions();
  public:
  const ::kentik::user::v202211::PermissionEntry& permissions(int index) const;
  ::kentik::user::v202211::PermissionEntry* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::PermissionEntry >&
      permissions() const;

  // string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string user_email = 2[json_name = "userEmail", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user_email();
  const std::string& user_email() const;
  void set_user_email(const std::string& value);
  void set_user_email(std::string&& value);
  void set_user_email(const char* value);
  void set_user_email(const char* value, size_t size);
  std::string* mutable_user_email();
  std::string* release_user_email();
  void set_allocated_user_email(std::string* user_email);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_email();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_email(
      std::string* user_email);
  private:
  const std::string& _internal_user_email() const;
  void _internal_set_user_email(const std::string& value);
  std::string* _internal_mutable_user_email();
  public:

  // string user_full_name = 4[json_name = "userFullName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user_full_name();
  const std::string& user_full_name() const;
  void set_user_full_name(const std::string& value);
  void set_user_full_name(std::string&& value);
  void set_user_full_name(const char* value);
  void set_user_full_name(const char* value, size_t size);
  std::string* mutable_user_full_name();
  std::string* release_user_full_name();
  void set_allocated_user_full_name(std::string* user_full_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_full_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_full_name(
      std::string* user_full_name);
  private:
  const std::string& _internal_user_full_name() const;
  void _internal_set_user_full_name(const std::string& value);
  std::string* _internal_mutable_user_full_name();
  public:

  // string filter = 7[json_name = "filter", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_filter();
  const std::string& filter() const;
  void set_filter(const std::string& value);
  void set_filter(std::string&& value);
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  std::string* mutable_filter();
  std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_filter();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_filter(
      std::string* filter);
  private:
  const std::string& _internal_filter() const;
  void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // .google.protobuf.Timestamp last_login = 8[json_name = "lastLogin", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  const PROTOBUF_NAMESPACE_ID::Timestamp& last_login() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_last_login();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_login();
  void set_allocated_last_login(PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_login() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_login();
  public:
  void unsafe_arena_set_allocated_last_login(
      PROTOBUF_NAMESPACE_ID::Timestamp* last_login);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_login();

  // .google.protobuf.Timestamp cdate = 9[json_name = "cdate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_cdate() const;
  private:
  bool _internal_has_cdate() const;
  public:
  void clear_cdate();
  const PROTOBUF_NAMESPACE_ID::Timestamp& cdate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_cdate();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cdate();
  void set_allocated_cdate(PROTOBUF_NAMESPACE_ID::Timestamp* cdate);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cdate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cdate();
  public:
  void unsafe_arena_set_allocated_cdate(
      PROTOBUF_NAMESPACE_ID::Timestamp* cdate);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cdate();

  // .google.protobuf.Timestamp edate = 10[json_name = "edate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_edate() const;
  private:
  bool _internal_has_edate() const;
  public:
  void clear_edate();
  const PROTOBUF_NAMESPACE_ID::Timestamp& edate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_edate();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_edate();
  void set_allocated_edate(PROTOBUF_NAMESPACE_ID::Timestamp* edate);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_edate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_edate();
  public:
  void unsafe_arena_set_allocated_edate(
      PROTOBUF_NAMESPACE_ID::Timestamp* edate);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_edate();

  // .kentik.user.v202211.Role role = 5[json_name = "role", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_role();
  ::kentik::user::v202211::Role role() const;
  void set_role(::kentik::user::v202211::Role value);
  private:
  ::kentik::user::v202211::Role _internal_role() const;
  void _internal_set_role(::kentik::user::v202211::Role value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::PermissionEntry > permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_full_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  PROTOBUF_NAMESPACE_ID::Timestamp* last_login_;
  PROTOBUF_NAMESPACE_ID::Timestamp* cdate_;
  PROTOBUF_NAMESPACE_ID::Timestamp* edate_;
  int role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListUsersRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.ListUsersRequest) */ {
 public:
  inline ListUsersRequest() : ListUsersRequest(nullptr) {};
  virtual ~ListUsersRequest();

  ListUsersRequest(const ListUsersRequest& from);
  ListUsersRequest(ListUsersRequest&& from) noexcept
    : ListUsersRequest() {
    *this = ::std::move(from);
  }

  inline ListUsersRequest& operator=(const ListUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersRequest& operator=(ListUsersRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListUsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUsersRequest* internal_default_instance() {
    return reinterpret_cast<const ListUsersRequest*>(
               &_ListUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListUsersRequest& a, ListUsersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUsersRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListUsersRequest* New() const final {
    return CreateMaybeMessage<ListUsersRequest>(nullptr);
  }

  ListUsersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListUsersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListUsersRequest& from);
  void MergeFrom(const ListUsersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUsersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.ListUsersRequest";
  }
  protected:
  explicit ListUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.ListUsersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ListUsersResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.ListUsersResponse) */ {
 public:
  inline ListUsersResponse() : ListUsersResponse(nullptr) {};
  virtual ~ListUsersResponse();

  ListUsersResponse(const ListUsersResponse& from);
  ListUsersResponse(ListUsersResponse&& from) noexcept
    : ListUsersResponse() {
    *this = ::std::move(from);
  }

  inline ListUsersResponse& operator=(const ListUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersResponse& operator=(ListUsersResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListUsersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListUsersResponse* internal_default_instance() {
    return reinterpret_cast<const ListUsersResponse*>(
               &_ListUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListUsersResponse& a, ListUsersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUsersResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListUsersResponse* New() const final {
    return CreateMaybeMessage<ListUsersResponse>(nullptr);
  }

  ListUsersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListUsersResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListUsersResponse& from);
  void MergeFrom(const ListUsersResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUsersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.ListUsersResponse";
  }
  protected:
  explicit ListUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
    kInvalidCountFieldNumber = 2,
  };
  // repeated .kentik.user.v202211.User users = 1[json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::kentik::user::v202211::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::User >*
      mutable_users();
  private:
  const ::kentik::user::v202211::User& _internal_users(int index) const;
  ::kentik::user::v202211::User* _internal_add_users();
  public:
  const ::kentik::user::v202211::User& users(int index) const;
  ::kentik::user::v202211::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::User >&
      users() const;

  // uint32 invalid_count = 2[json_name = "invalidCount", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_invalid_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 invalid_count() const;
  void set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_invalid_count() const;
  void _internal_set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.ListUsersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::User > users_;
  ::PROTOBUF_NAMESPACE_ID::uint32 invalid_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.GetUserRequest) */ {
 public:
  inline GetUserRequest() : GetUserRequest(nullptr) {};
  virtual ~GetUserRequest();

  GetUserRequest(const GetUserRequest& from);
  GetUserRequest(GetUserRequest&& from) noexcept
    : GetUserRequest() {
    *this = ::std::move(from);
  }

  inline GetUserRequest& operator=(const GetUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserRequest& operator=(GetUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserRequest*>(
               &_GetUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetUserRequest& a, GetUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUserRequest* New() const final {
    return CreateMaybeMessage<GetUserRequest>(nullptr);
  }

  GetUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUserRequest& from);
  void MergeFrom(const GetUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.GetUserRequest";
  }
  protected:
  explicit GetUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.GetUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.GetUserResponse) */ {
 public:
  inline GetUserResponse() : GetUserResponse(nullptr) {};
  virtual ~GetUserResponse();

  GetUserResponse(const GetUserResponse& from);
  GetUserResponse(GetUserResponse&& from) noexcept
    : GetUserResponse() {
    *this = ::std::move(from);
  }

  inline GetUserResponse& operator=(const GetUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserResponse& operator=(GetUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserResponse*>(
               &_GetUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetUserResponse& a, GetUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUserResponse* New() const final {
    return CreateMaybeMessage<GetUserResponse>(nullptr);
  }

  GetUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUserResponse& from);
  void MergeFrom(const GetUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.GetUserResponse";
  }
  protected:
  explicit GetUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202211::User& user() const;
  ::kentik::user::v202211::User* release_user();
  ::kentik::user::v202211::User* mutable_user();
  void set_allocated_user(::kentik::user::v202211::User* user);
  private:
  const ::kentik::user::v202211::User& _internal_user() const;
  ::kentik::user::v202211::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202211::User* user);
  ::kentik::user::v202211::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.GetUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202211::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.CreateUserRequest) */ {
 public:
  inline CreateUserRequest() : CreateUserRequest(nullptr) {};
  virtual ~CreateUserRequest();

  CreateUserRequest(const CreateUserRequest& from);
  CreateUserRequest(CreateUserRequest&& from) noexcept
    : CreateUserRequest() {
    *this = ::std::move(from);
  }

  inline CreateUserRequest& operator=(const CreateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserRequest& operator=(CreateUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateUserRequest* internal_default_instance() {
    return reinterpret_cast<const CreateUserRequest*>(
               &_CreateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateUserRequest& a, CreateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateUserRequest* New() const final {
    return CreateMaybeMessage<CreateUserRequest>(nullptr);
  }

  CreateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateUserRequest& from);
  void MergeFrom(const CreateUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.CreateUserRequest";
  }
  protected:
  explicit CreateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202211::User& user() const;
  ::kentik::user::v202211::User* release_user();
  ::kentik::user::v202211::User* mutable_user();
  void set_allocated_user(::kentik::user::v202211::User* user);
  private:
  const ::kentik::user::v202211::User& _internal_user() const;
  ::kentik::user::v202211::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202211::User* user);
  ::kentik::user::v202211::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.CreateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202211::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.CreateUserResponse) */ {
 public:
  inline CreateUserResponse() : CreateUserResponse(nullptr) {};
  virtual ~CreateUserResponse();

  CreateUserResponse(const CreateUserResponse& from);
  CreateUserResponse(CreateUserResponse&& from) noexcept
    : CreateUserResponse() {
    *this = ::std::move(from);
  }

  inline CreateUserResponse& operator=(const CreateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserResponse& operator=(CreateUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateUserResponse* internal_default_instance() {
    return reinterpret_cast<const CreateUserResponse*>(
               &_CreateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateUserResponse& a, CreateUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateUserResponse* New() const final {
    return CreateMaybeMessage<CreateUserResponse>(nullptr);
  }

  CreateUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateUserResponse& from);
  void MergeFrom(const CreateUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.CreateUserResponse";
  }
  protected:
  explicit CreateUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202211::User& user() const;
  ::kentik::user::v202211::User* release_user();
  ::kentik::user::v202211::User* mutable_user();
  void set_allocated_user(::kentik::user::v202211::User* user);
  private:
  const ::kentik::user::v202211::User& _internal_user() const;
  ::kentik::user::v202211::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202211::User* user);
  ::kentik::user::v202211::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.CreateUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202211::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.UpdateUserRequest) */ {
 public:
  inline UpdateUserRequest() : UpdateUserRequest(nullptr) {};
  virtual ~UpdateUserRequest();

  UpdateUserRequest(const UpdateUserRequest& from);
  UpdateUserRequest(UpdateUserRequest&& from) noexcept
    : UpdateUserRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest& operator=(const UpdateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest& operator=(UpdateUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateUserRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest*>(
               &_UpdateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateUserRequest& a, UpdateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateUserRequest* New() const final {
    return CreateMaybeMessage<UpdateUserRequest>(nullptr);
  }

  UpdateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateUserRequest& from);
  void MergeFrom(const UpdateUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.UpdateUserRequest";
  }
  protected:
  explicit UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202211::User& user() const;
  ::kentik::user::v202211::User* release_user();
  ::kentik::user::v202211::User* mutable_user();
  void set_allocated_user(::kentik::user::v202211::User* user);
  private:
  const ::kentik::user::v202211::User& _internal_user() const;
  ::kentik::user::v202211::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202211::User* user);
  ::kentik::user::v202211::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.UpdateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202211::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.UpdateUserResponse) */ {
 public:
  inline UpdateUserResponse() : UpdateUserResponse(nullptr) {};
  virtual ~UpdateUserResponse();

  UpdateUserResponse(const UpdateUserResponse& from);
  UpdateUserResponse(UpdateUserResponse&& from) noexcept
    : UpdateUserResponse() {
    *this = ::std::move(from);
  }

  inline UpdateUserResponse& operator=(const UpdateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserResponse& operator=(UpdateUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateUserResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateUserResponse*>(
               &_UpdateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateUserResponse& a, UpdateUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateUserResponse* New() const final {
    return CreateMaybeMessage<UpdateUserResponse>(nullptr);
  }

  UpdateUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateUserResponse& from);
  void MergeFrom(const UpdateUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.UpdateUserResponse";
  }
  protected:
  explicit UpdateUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::kentik::user::v202211::User& user() const;
  ::kentik::user::v202211::User* release_user();
  ::kentik::user::v202211::User* mutable_user();
  void set_allocated_user(::kentik::user::v202211::User* user);
  private:
  const ::kentik::user::v202211::User& _internal_user() const;
  ::kentik::user::v202211::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::kentik::user::v202211::User* user);
  ::kentik::user::v202211::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.UpdateUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::user::v202211::User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.DeleteUserRequest) */ {
 public:
  inline DeleteUserRequest() : DeleteUserRequest(nullptr) {};
  virtual ~DeleteUserRequest();

  DeleteUserRequest(const DeleteUserRequest& from);
  DeleteUserRequest(DeleteUserRequest&& from) noexcept
    : DeleteUserRequest() {
    *this = ::std::move(from);
  }

  inline DeleteUserRequest& operator=(const DeleteUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserRequest& operator=(DeleteUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteUserRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteUserRequest*>(
               &_DeleteUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteUserRequest& a, DeleteUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteUserRequest* New() const final {
    return CreateMaybeMessage<DeleteUserRequest>(nullptr);
  }

  DeleteUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteUserRequest& from);
  void MergeFrom(const DeleteUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.DeleteUserRequest";
  }
  protected:
  explicit DeleteUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.DeleteUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.DeleteUserResponse) */ {
 public:
  inline DeleteUserResponse() : DeleteUserResponse(nullptr) {};
  virtual ~DeleteUserResponse();

  DeleteUserResponse(const DeleteUserResponse& from);
  DeleteUserResponse(DeleteUserResponse&& from) noexcept
    : DeleteUserResponse() {
    *this = ::std::move(from);
  }

  inline DeleteUserResponse& operator=(const DeleteUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserResponse& operator=(DeleteUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteUserResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteUserResponse*>(
               &_DeleteUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteUserResponse& a, DeleteUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteUserResponse* New() const final {
    return CreateMaybeMessage<DeleteUserResponse>(nullptr);
  }

  DeleteUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteUserResponse& from);
  void MergeFrom(const DeleteUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.DeleteUserResponse";
  }
  protected:
  explicit DeleteUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.DeleteUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetApiTokenRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.ResetApiTokenRequest) */ {
 public:
  inline ResetApiTokenRequest() : ResetApiTokenRequest(nullptr) {};
  virtual ~ResetApiTokenRequest();

  ResetApiTokenRequest(const ResetApiTokenRequest& from);
  ResetApiTokenRequest(ResetApiTokenRequest&& from) noexcept
    : ResetApiTokenRequest() {
    *this = ::std::move(from);
  }

  inline ResetApiTokenRequest& operator=(const ResetApiTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetApiTokenRequest& operator=(ResetApiTokenRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetApiTokenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetApiTokenRequest* internal_default_instance() {
    return reinterpret_cast<const ResetApiTokenRequest*>(
               &_ResetApiTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResetApiTokenRequest& a, ResetApiTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetApiTokenRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetApiTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetApiTokenRequest* New() const final {
    return CreateMaybeMessage<ResetApiTokenRequest>(nullptr);
  }

  ResetApiTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetApiTokenRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetApiTokenRequest& from);
  void MergeFrom(const ResetApiTokenRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetApiTokenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.ResetApiTokenRequest";
  }
  protected:
  explicit ResetApiTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.ResetApiTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetApiTokenResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.ResetApiTokenResponse) */ {
 public:
  inline ResetApiTokenResponse() : ResetApiTokenResponse(nullptr) {};
  virtual ~ResetApiTokenResponse();

  ResetApiTokenResponse(const ResetApiTokenResponse& from);
  ResetApiTokenResponse(ResetApiTokenResponse&& from) noexcept
    : ResetApiTokenResponse() {
    *this = ::std::move(from);
  }

  inline ResetApiTokenResponse& operator=(const ResetApiTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetApiTokenResponse& operator=(ResetApiTokenResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetApiTokenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetApiTokenResponse* internal_default_instance() {
    return reinterpret_cast<const ResetApiTokenResponse*>(
               &_ResetApiTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResetApiTokenResponse& a, ResetApiTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetApiTokenResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetApiTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetApiTokenResponse* New() const final {
    return CreateMaybeMessage<ResetApiTokenResponse>(nullptr);
  }

  ResetApiTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetApiTokenResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetApiTokenResponse& from);
  void MergeFrom(const ResetApiTokenResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetApiTokenResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.ResetApiTokenResponse";
  }
  protected:
  explicit ResetApiTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.ResetApiTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetActiveSessionsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.ResetActiveSessionsRequest) */ {
 public:
  inline ResetActiveSessionsRequest() : ResetActiveSessionsRequest(nullptr) {};
  virtual ~ResetActiveSessionsRequest();

  ResetActiveSessionsRequest(const ResetActiveSessionsRequest& from);
  ResetActiveSessionsRequest(ResetActiveSessionsRequest&& from) noexcept
    : ResetActiveSessionsRequest() {
    *this = ::std::move(from);
  }

  inline ResetActiveSessionsRequest& operator=(const ResetActiveSessionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetActiveSessionsRequest& operator=(ResetActiveSessionsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetActiveSessionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetActiveSessionsRequest* internal_default_instance() {
    return reinterpret_cast<const ResetActiveSessionsRequest*>(
               &_ResetActiveSessionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResetActiveSessionsRequest& a, ResetActiveSessionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetActiveSessionsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetActiveSessionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetActiveSessionsRequest* New() const final {
    return CreateMaybeMessage<ResetActiveSessionsRequest>(nullptr);
  }

  ResetActiveSessionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetActiveSessionsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetActiveSessionsRequest& from);
  void MergeFrom(const ResetActiveSessionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetActiveSessionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.ResetActiveSessionsRequest";
  }
  protected:
  explicit ResetActiveSessionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.ResetActiveSessionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetActiveSessionsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.user.v202211.ResetActiveSessionsResponse) */ {
 public:
  inline ResetActiveSessionsResponse() : ResetActiveSessionsResponse(nullptr) {};
  virtual ~ResetActiveSessionsResponse();

  ResetActiveSessionsResponse(const ResetActiveSessionsResponse& from);
  ResetActiveSessionsResponse(ResetActiveSessionsResponse&& from) noexcept
    : ResetActiveSessionsResponse() {
    *this = ::std::move(from);
  }

  inline ResetActiveSessionsResponse& operator=(const ResetActiveSessionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetActiveSessionsResponse& operator=(ResetActiveSessionsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetActiveSessionsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetActiveSessionsResponse* internal_default_instance() {
    return reinterpret_cast<const ResetActiveSessionsResponse*>(
               &_ResetActiveSessionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResetActiveSessionsResponse& a, ResetActiveSessionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetActiveSessionsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetActiveSessionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetActiveSessionsResponse* New() const final {
    return CreateMaybeMessage<ResetActiveSessionsResponse>(nullptr);
  }

  ResetActiveSessionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetActiveSessionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetActiveSessionsResponse& from);
  void MergeFrom(const ResetActiveSessionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetActiveSessionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.user.v202211.ResetActiveSessionsResponse";
  }
  protected:
  explicit ResetActiveSessionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto);
    return ::descriptor_table_kentik_2fuser_2fv202211_2fuser_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.user.v202211.ResetActiveSessionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fuser_2fv202211_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PermissionEntry

// string capability = 1[json_name = "capability", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void PermissionEntry::clear_capability() {
  capability_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PermissionEntry::capability() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.PermissionEntry.capability)
  return _internal_capability();
}
inline void PermissionEntry::set_capability(const std::string& value) {
  _internal_set_capability(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.PermissionEntry.capability)
}
inline std::string* PermissionEntry::mutable_capability() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.PermissionEntry.capability)
  return _internal_mutable_capability();
}
inline const std::string& PermissionEntry::_internal_capability() const {
  return capability_.Get();
}
inline void PermissionEntry::_internal_set_capability(const std::string& value) {
  
  capability_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PermissionEntry::set_capability(std::string&& value) {
  
  capability_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.PermissionEntry.capability)
}
inline void PermissionEntry::set_capability(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  capability_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.PermissionEntry.capability)
}
inline void PermissionEntry::set_capability(const char* value,
    size_t size) {
  
  capability_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.PermissionEntry.capability)
}
inline std::string* PermissionEntry::_internal_mutable_capability() {
  
  return capability_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PermissionEntry::release_capability() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.PermissionEntry.capability)
  return capability_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PermissionEntry::set_allocated_capability(std::string* capability) {
  if (capability != nullptr) {
    
  } else {
    
  }
  capability_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), capability,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.PermissionEntry.capability)
}
inline std::string* PermissionEntry::unsafe_arena_release_capability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.PermissionEntry.capability)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return capability_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PermissionEntry::unsafe_arena_set_allocated_capability(
    std::string* capability) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (capability != nullptr) {
    
  } else {
    
  }
  capability_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      capability, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.PermissionEntry.capability)
}

// bool allowed = 2[json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void PermissionEntry::clear_allowed() {
  allowed_ = false;
}
inline bool PermissionEntry::_internal_allowed() const {
  return allowed_;
}
inline bool PermissionEntry::allowed() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.PermissionEntry.allowed)
  return _internal_allowed();
}
inline void PermissionEntry::_internal_set_allowed(bool value) {
  
  allowed_ = value;
}
inline void PermissionEntry::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.PermissionEntry.allowed)
}

// -------------------------------------------------------------------

// User

// string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void User::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.id)
  return _internal_id();
}
inline void User::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.User.id)
}
inline std::string* User::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.id)
  return _internal_mutable_id();
}
inline const std::string& User::_internal_id() const {
  return id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.User.id)
}
inline void User::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.User.id)
}
inline void User::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.User.id)
}
inline std::string* User::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.id)
}
inline std::string* User::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.User.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.id)
}

// string user_email = 2[json_name = "userEmail", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void User::clear_user_email() {
  user_email_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::user_email() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.user_email)
  return _internal_user_email();
}
inline void User::set_user_email(const std::string& value) {
  _internal_set_user_email(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.User.user_email)
}
inline std::string* User::mutable_user_email() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.user_email)
  return _internal_mutable_user_email();
}
inline const std::string& User::_internal_user_email() const {
  return user_email_.Get();
}
inline void User::_internal_set_user_email(const std::string& value) {
  
  user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_user_email(std::string&& value) {
  
  user_email_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.User.user_email)
}
inline void User::set_user_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.User.user_email)
}
inline void User::set_user_email(const char* value,
    size_t size) {
  
  user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.User.user_email)
}
inline std::string* User::_internal_mutable_user_email() {
  
  return user_email_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_user_email() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.user_email)
  return user_email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_user_email(std::string* user_email) {
  if (user_email != nullptr) {
    
  } else {
    
  }
  user_email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_email,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.user_email)
}
inline std::string* User::unsafe_arena_release_user_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.User.user_email)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_email_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_user_email(
    std::string* user_email) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_email != nullptr) {
    
  } else {
    
  }
  user_email_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_email, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.user_email)
}

// string user_full_name = 4[json_name = "userFullName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void User::clear_user_full_name() {
  user_full_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::user_full_name() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.user_full_name)
  return _internal_user_full_name();
}
inline void User::set_user_full_name(const std::string& value) {
  _internal_set_user_full_name(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.User.user_full_name)
}
inline std::string* User::mutable_user_full_name() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.user_full_name)
  return _internal_mutable_user_full_name();
}
inline const std::string& User::_internal_user_full_name() const {
  return user_full_name_.Get();
}
inline void User::_internal_set_user_full_name(const std::string& value) {
  
  user_full_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_user_full_name(std::string&& value) {
  
  user_full_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.User.user_full_name)
}
inline void User::set_user_full_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_full_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.User.user_full_name)
}
inline void User::set_user_full_name(const char* value,
    size_t size) {
  
  user_full_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.User.user_full_name)
}
inline std::string* User::_internal_mutable_user_full_name() {
  
  return user_full_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_user_full_name() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.user_full_name)
  return user_full_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_user_full_name(std::string* user_full_name) {
  if (user_full_name != nullptr) {
    
  } else {
    
  }
  user_full_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_full_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.user_full_name)
}
inline std::string* User::unsafe_arena_release_user_full_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.User.user_full_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_full_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_user_full_name(
    std::string* user_full_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_full_name != nullptr) {
    
  } else {
    
  }
  user_full_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_full_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.user_full_name)
}

// .kentik.user.v202211.Role role = 5[json_name = "role", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void User::clear_role() {
  role_ = 0;
}
inline ::kentik::user::v202211::Role User::_internal_role() const {
  return static_cast< ::kentik::user::v202211::Role >(role_);
}
inline ::kentik::user::v202211::Role User::role() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.role)
  return _internal_role();
}
inline void User::_internal_set_role(::kentik::user::v202211::Role value) {
  
  role_ = value;
}
inline void User::set_role(::kentik::user::v202211::Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.User.role)
}

// repeated .kentik.user.v202211.PermissionEntry permissions = 6[json_name = "permissions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int User::_internal_permissions_size() const {
  return permissions_.size();
}
inline int User::permissions_size() const {
  return _internal_permissions_size();
}
inline void User::clear_permissions() {
  permissions_.Clear();
}
inline ::kentik::user::v202211::PermissionEntry* User::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::PermissionEntry >*
User::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:kentik.user.v202211.User.permissions)
  return &permissions_;
}
inline const ::kentik::user::v202211::PermissionEntry& User::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::kentik::user::v202211::PermissionEntry& User::permissions(int index) const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.permissions)
  return _internal_permissions(index);
}
inline ::kentik::user::v202211::PermissionEntry* User::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::kentik::user::v202211::PermissionEntry* User::add_permissions() {
  // @@protoc_insertion_point(field_add:kentik.user.v202211.User.permissions)
  return _internal_add_permissions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::PermissionEntry >&
User::permissions() const {
  // @@protoc_insertion_point(field_list:kentik.user.v202211.User.permissions)
  return permissions_;
}

// string filter = 7[json_name = "filter", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void User::clear_filter() {
  filter_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& User::filter() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.filter)
  return _internal_filter();
}
inline void User::set_filter(const std::string& value) {
  _internal_set_filter(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.User.filter)
}
inline std::string* User::mutable_filter() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.filter)
  return _internal_mutable_filter();
}
inline const std::string& User::_internal_filter() const {
  return filter_.Get();
}
inline void User::_internal_set_filter(const std::string& value) {
  
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void User::set_filter(std::string&& value) {
  
  filter_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.User.filter)
}
inline void User::set_filter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.User.filter)
}
inline void User::set_filter(const char* value,
    size_t size) {
  
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.User.filter)
}
inline std::string* User::_internal_mutable_filter() {
  
  return filter_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* User::release_filter() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.filter)
  return filter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void User::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.filter)
}
inline std::string* User::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.User.filter)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return filter_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void User::unsafe_arena_set_allocated_filter(
    std::string* filter) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (filter != nullptr) {
    
  } else {
    
  }
  filter_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      filter, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.filter)
}

// .google.protobuf.Timestamp last_login = 8[json_name = "lastLogin", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool User::_internal_has_last_login() const {
  return this != internal_default_instance() && last_login_ != nullptr;
}
inline bool User::has_last_login() const {
  return _internal_has_last_login();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_last_login() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = last_login_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::last_login() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.last_login)
  return _internal_last_login();
}
inline void User::unsafe_arena_set_allocated_last_login(
    PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  last_login_ = last_login;
  if (last_login) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.last_login)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::release_last_login() {
  auto temp = unsafe_arena_release_last_login();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_last_login() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.last_login)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_login_;
  last_login_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_last_login() {
  
  if (last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    last_login_ = p;
  }
  return last_login_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_last_login() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.last_login)
  return _internal_mutable_last_login();
}
inline void User::set_allocated_last_login(PROTOBUF_NAMESPACE_ID::Timestamp* last_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login_);
  }
  if (last_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_login)->GetArena();
    if (message_arena != submessage_arena) {
      last_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_login, submessage_arena);
    }
    
  } else {
    
  }
  last_login_ = last_login;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.last_login)
}

// .google.protobuf.Timestamp cdate = 9[json_name = "cdate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool User::_internal_has_cdate() const {
  return this != internal_default_instance() && cdate_ != nullptr;
}
inline bool User::has_cdate() const {
  return _internal_has_cdate();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_cdate() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = cdate_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::cdate() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.cdate)
  return _internal_cdate();
}
inline void User::unsafe_arena_set_allocated_cdate(
    PROTOBUF_NAMESPACE_ID::Timestamp* cdate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdate_);
  }
  cdate_ = cdate;
  if (cdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.cdate)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::release_cdate() {
  auto temp = unsafe_arena_release_cdate();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_cdate() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.cdate)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = cdate_;
  cdate_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_cdate() {
  
  if (cdate_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    cdate_ = p;
  }
  return cdate_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_cdate() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.cdate)
  return _internal_mutable_cdate();
}
inline void User::set_allocated_cdate(PROTOBUF_NAMESPACE_ID::Timestamp* cdate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdate_);
  }
  if (cdate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdate)->GetArena();
    if (message_arena != submessage_arena) {
      cdate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cdate, submessage_arena);
    }
    
  } else {
    
  }
  cdate_ = cdate;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.cdate)
}

// .google.protobuf.Timestamp edate = 10[json_name = "edate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool User::_internal_has_edate() const {
  return this != internal_default_instance() && edate_ != nullptr;
}
inline bool User::has_edate() const {
  return _internal_has_edate();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_edate() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = edate_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& User::edate() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.User.edate)
  return _internal_edate();
}
inline void User::unsafe_arena_set_allocated_edate(
    PROTOBUF_NAMESPACE_ID::Timestamp* edate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edate_);
  }
  edate_ = edate;
  if (edate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.User.edate)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::release_edate() {
  auto temp = unsafe_arena_release_edate();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_edate() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.User.edate)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = edate_;
  edate_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_edate() {
  
  if (edate_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    edate_ = p;
  }
  return edate_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_edate() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.User.edate)
  return _internal_mutable_edate();
}
inline void User::set_allocated_edate(PROTOBUF_NAMESPACE_ID::Timestamp* edate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(edate_);
  }
  if (edate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edate)->GetArena();
    if (message_arena != submessage_arena) {
      edate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edate, submessage_arena);
    }
    
  } else {
    
  }
  edate_ = edate;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.User.edate)
}

// -------------------------------------------------------------------

// ListUsersRequest

// -------------------------------------------------------------------

// ListUsersResponse

// repeated .kentik.user.v202211.User users = 1[json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int ListUsersResponse::_internal_users_size() const {
  return users_.size();
}
inline int ListUsersResponse::users_size() const {
  return _internal_users_size();
}
inline void ListUsersResponse::clear_users() {
  users_.Clear();
}
inline ::kentik::user::v202211::User* ListUsersResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.ListUsersResponse.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::User >*
ListUsersResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:kentik.user.v202211.ListUsersResponse.users)
  return &users_;
}
inline const ::kentik::user::v202211::User& ListUsersResponse::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::kentik::user::v202211::User& ListUsersResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.ListUsersResponse.users)
  return _internal_users(index);
}
inline ::kentik::user::v202211::User* ListUsersResponse::_internal_add_users() {
  return users_.Add();
}
inline ::kentik::user::v202211::User* ListUsersResponse::add_users() {
  // @@protoc_insertion_point(field_add:kentik.user.v202211.ListUsersResponse.users)
  return _internal_add_users();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::user::v202211::User >&
ListUsersResponse::users() const {
  // @@protoc_insertion_point(field_list:kentik.user.v202211.ListUsersResponse.users)
  return users_;
}

// uint32 invalid_count = 2[json_name = "invalidCount", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListUsersResponse::clear_invalid_count() {
  invalid_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListUsersResponse::_internal_invalid_count() const {
  return invalid_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListUsersResponse::invalid_count() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.ListUsersResponse.invalid_count)
  return _internal_invalid_count();
}
inline void ListUsersResponse::_internal_set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  invalid_count_ = value;
}
inline void ListUsersResponse::set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_invalid_count(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.ListUsersResponse.invalid_count)
}

// -------------------------------------------------------------------

// GetUserRequest

// string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void GetUserRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetUserRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.GetUserRequest.id)
  return _internal_id();
}
inline void GetUserRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.GetUserRequest.id)
}
inline std::string* GetUserRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.GetUserRequest.id)
  return _internal_mutable_id();
}
inline const std::string& GetUserRequest::_internal_id() const {
  return id_.Get();
}
inline void GetUserRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetUserRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.GetUserRequest.id)
}
inline void GetUserRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.GetUserRequest.id)
}
inline void GetUserRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.GetUserRequest.id)
}
inline std::string* GetUserRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetUserRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.GetUserRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetUserRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.GetUserRequest.id)
}
inline std::string* GetUserRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.GetUserRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetUserRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.GetUserRequest.id)
}

// -------------------------------------------------------------------

// GetUserResponse

// .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool GetUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetUserResponse::has_user() const {
  return _internal_has_user();
}
inline void GetUserResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202211::User& GetUserResponse::_internal_user() const {
  const ::kentik::user::v202211::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202211::User*>(
      &::kentik::user::v202211::_User_default_instance_);
}
inline const ::kentik::user::v202211::User& GetUserResponse::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.GetUserResponse.user)
  return _internal_user();
}
inline void GetUserResponse::unsafe_arena_set_allocated_user(
    ::kentik::user::v202211::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.GetUserResponse.user)
}
inline ::kentik::user::v202211::User* GetUserResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202211::User* GetUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.GetUserResponse.user)
  
  ::kentik::user::v202211::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202211::User* GetUserResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202211::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202211::User* GetUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.GetUserResponse.user)
  return _internal_mutable_user();
}
inline void GetUserResponse::set_allocated_user(::kentik::user::v202211::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.GetUserResponse.user)
}

// -------------------------------------------------------------------

// CreateUserRequest

// .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool CreateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool CreateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void CreateUserRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202211::User& CreateUserRequest::_internal_user() const {
  const ::kentik::user::v202211::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202211::User*>(
      &::kentik::user::v202211::_User_default_instance_);
}
inline const ::kentik::user::v202211::User& CreateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.CreateUserRequest.user)
  return _internal_user();
}
inline void CreateUserRequest::unsafe_arena_set_allocated_user(
    ::kentik::user::v202211::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.CreateUserRequest.user)
}
inline ::kentik::user::v202211::User* CreateUserRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202211::User* CreateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.CreateUserRequest.user)
  
  ::kentik::user::v202211::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202211::User* CreateUserRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202211::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202211::User* CreateUserRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.CreateUserRequest.user)
  return _internal_mutable_user();
}
inline void CreateUserRequest::set_allocated_user(::kentik::user::v202211::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.CreateUserRequest.user)
}

// -------------------------------------------------------------------

// CreateUserResponse

// .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool CreateUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool CreateUserResponse::has_user() const {
  return _internal_has_user();
}
inline void CreateUserResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202211::User& CreateUserResponse::_internal_user() const {
  const ::kentik::user::v202211::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202211::User*>(
      &::kentik::user::v202211::_User_default_instance_);
}
inline const ::kentik::user::v202211::User& CreateUserResponse::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.CreateUserResponse.user)
  return _internal_user();
}
inline void CreateUserResponse::unsafe_arena_set_allocated_user(
    ::kentik::user::v202211::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.CreateUserResponse.user)
}
inline ::kentik::user::v202211::User* CreateUserResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202211::User* CreateUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.CreateUserResponse.user)
  
  ::kentik::user::v202211::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202211::User* CreateUserResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202211::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202211::User* CreateUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.CreateUserResponse.user)
  return _internal_mutable_user();
}
inline void CreateUserResponse::set_allocated_user(::kentik::user::v202211::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.CreateUserResponse.user)
}

// -------------------------------------------------------------------

// UpdateUserRequest

// .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool UpdateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserRequest::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202211::User& UpdateUserRequest::_internal_user() const {
  const ::kentik::user::v202211::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202211::User*>(
      &::kentik::user::v202211::_User_default_instance_);
}
inline const ::kentik::user::v202211::User& UpdateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.UpdateUserRequest.user)
  return _internal_user();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_user(
    ::kentik::user::v202211::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.UpdateUserRequest.user)
}
inline ::kentik::user::v202211::User* UpdateUserRequest::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202211::User* UpdateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.UpdateUserRequest.user)
  
  ::kentik::user::v202211::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202211::User* UpdateUserRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202211::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202211::User* UpdateUserRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.UpdateUserRequest.user)
  return _internal_mutable_user();
}
inline void UpdateUserRequest::set_allocated_user(::kentik::user::v202211::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.UpdateUserRequest.user)
}

// -------------------------------------------------------------------

// UpdateUserResponse

// .kentik.user.v202211.User user = 1[json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool UpdateUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserResponse::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserResponse::clear_user() {
  if (GetArena() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::kentik::user::v202211::User& UpdateUserResponse::_internal_user() const {
  const ::kentik::user::v202211::User* p = user_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::user::v202211::User*>(
      &::kentik::user::v202211::_User_default_instance_);
}
inline const ::kentik::user::v202211::User& UpdateUserResponse::user() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.UpdateUserResponse.user)
  return _internal_user();
}
inline void UpdateUserResponse::unsafe_arena_set_allocated_user(
    ::kentik::user::v202211::User* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.UpdateUserResponse.user)
}
inline ::kentik::user::v202211::User* UpdateUserResponse::release_user() {
  auto temp = unsafe_arena_release_user();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::user::v202211::User* UpdateUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.UpdateUserResponse.user)
  
  ::kentik::user::v202211::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::kentik::user::v202211::User* UpdateUserResponse::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::user::v202211::User>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::kentik::user::v202211::User* UpdateUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.UpdateUserResponse.user)
  return _internal_mutable_user();
}
inline void UpdateUserResponse::set_allocated_user(::kentik::user::v202211::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.UpdateUserResponse.user)
}

// -------------------------------------------------------------------

// DeleteUserRequest

// string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void DeleteUserRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteUserRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.DeleteUserRequest.id)
  return _internal_id();
}
inline void DeleteUserRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.DeleteUserRequest.id)
}
inline std::string* DeleteUserRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.DeleteUserRequest.id)
  return _internal_mutable_id();
}
inline const std::string& DeleteUserRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteUserRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteUserRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.DeleteUserRequest.id)
}
inline void DeleteUserRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.DeleteUserRequest.id)
}
inline void DeleteUserRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.DeleteUserRequest.id)
}
inline std::string* DeleteUserRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteUserRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.DeleteUserRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteUserRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.DeleteUserRequest.id)
}
inline std::string* DeleteUserRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.DeleteUserRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DeleteUserRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.DeleteUserRequest.id)
}

// -------------------------------------------------------------------

// DeleteUserResponse

// -------------------------------------------------------------------

// ResetApiTokenRequest

// string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ResetApiTokenRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ResetApiTokenRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.ResetApiTokenRequest.id)
  return _internal_id();
}
inline void ResetApiTokenRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.ResetApiTokenRequest.id)
}
inline std::string* ResetApiTokenRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.ResetApiTokenRequest.id)
  return _internal_mutable_id();
}
inline const std::string& ResetApiTokenRequest::_internal_id() const {
  return id_.Get();
}
inline void ResetApiTokenRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResetApiTokenRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.ResetApiTokenRequest.id)
}
inline void ResetApiTokenRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.ResetApiTokenRequest.id)
}
inline void ResetApiTokenRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.ResetApiTokenRequest.id)
}
inline std::string* ResetApiTokenRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResetApiTokenRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.ResetApiTokenRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResetApiTokenRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.ResetApiTokenRequest.id)
}
inline std::string* ResetApiTokenRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.ResetApiTokenRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ResetApiTokenRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.ResetApiTokenRequest.id)
}

// -------------------------------------------------------------------

// ResetApiTokenResponse

// -------------------------------------------------------------------

// ResetActiveSessionsRequest

// string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ResetActiveSessionsRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ResetActiveSessionsRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.user.v202211.ResetActiveSessionsRequest.id)
  return _internal_id();
}
inline void ResetActiveSessionsRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.user.v202211.ResetActiveSessionsRequest.id)
}
inline std::string* ResetActiveSessionsRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.user.v202211.ResetActiveSessionsRequest.id)
  return _internal_mutable_id();
}
inline const std::string& ResetActiveSessionsRequest::_internal_id() const {
  return id_.Get();
}
inline void ResetActiveSessionsRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ResetActiveSessionsRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.user.v202211.ResetActiveSessionsRequest.id)
}
inline void ResetActiveSessionsRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.user.v202211.ResetActiveSessionsRequest.id)
}
inline void ResetActiveSessionsRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.user.v202211.ResetActiveSessionsRequest.id)
}
inline std::string* ResetActiveSessionsRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ResetActiveSessionsRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.user.v202211.ResetActiveSessionsRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ResetActiveSessionsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.user.v202211.ResetActiveSessionsRequest.id)
}
inline std::string* ResetActiveSessionsRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.user.v202211.ResetActiveSessionsRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ResetActiveSessionsRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.user.v202211.ResetActiveSessionsRequest.id)
}

// -------------------------------------------------------------------

// ResetActiveSessionsResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v202211
}  // namespace user
}  // namespace kentik

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kentik::user::v202211::Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::user::v202211::Role>() {
  return ::kentik::user::v202211::Role_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kentik_2fuser_2fv202211_2fuser_2eproto
