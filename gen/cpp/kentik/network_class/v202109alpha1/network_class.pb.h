// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kentik/network_class/v202109alpha1/network_class.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "kentik/core/v202012alpha1/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
namespace kentik {
namespace network_class {
namespace v202109alpha1 {
class CloudSubnet;
class CloudSubnetDefaultTypeInternal;
extern CloudSubnetDefaultTypeInternal _CloudSubnet_default_instance_;
class GetNetworkClassRequest;
class GetNetworkClassRequestDefaultTypeInternal;
extern GetNetworkClassRequestDefaultTypeInternal _GetNetworkClassRequest_default_instance_;
class GetNetworkClassResponse;
class GetNetworkClassResponseDefaultTypeInternal;
extern GetNetworkClassResponseDefaultTypeInternal _GetNetworkClassResponse_default_instance_;
class NetworkClass;
class NetworkClassDefaultTypeInternal;
extern NetworkClassDefaultTypeInternal _NetworkClass_default_instance_;
class UpdateNetworkClassRequest;
class UpdateNetworkClassRequestDefaultTypeInternal;
extern UpdateNetworkClassRequestDefaultTypeInternal _UpdateNetworkClassRequest_default_instance_;
class UpdateNetworkClassResponse;
class UpdateNetworkClassResponseDefaultTypeInternal;
extern UpdateNetworkClassResponseDefaultTypeInternal _UpdateNetworkClassResponse_default_instance_;
}  // namespace v202109alpha1
}  // namespace network_class
}  // namespace kentik
PROTOBUF_NAMESPACE_OPEN
template<> ::kentik::network_class::v202109alpha1::CloudSubnet* Arena::CreateMaybeMessage<::kentik::network_class::v202109alpha1::CloudSubnet>(Arena*);
template<> ::kentik::network_class::v202109alpha1::GetNetworkClassRequest* Arena::CreateMaybeMessage<::kentik::network_class::v202109alpha1::GetNetworkClassRequest>(Arena*);
template<> ::kentik::network_class::v202109alpha1::GetNetworkClassResponse* Arena::CreateMaybeMessage<::kentik::network_class::v202109alpha1::GetNetworkClassResponse>(Arena*);
template<> ::kentik::network_class::v202109alpha1::NetworkClass* Arena::CreateMaybeMessage<::kentik::network_class::v202109alpha1::NetworkClass>(Arena*);
template<> ::kentik::network_class::v202109alpha1::UpdateNetworkClassRequest* Arena::CreateMaybeMessage<::kentik::network_class::v202109alpha1::UpdateNetworkClassRequest>(Arena*);
template<> ::kentik::network_class::v202109alpha1::UpdateNetworkClassResponse* Arena::CreateMaybeMessage<::kentik::network_class::v202109alpha1::UpdateNetworkClassResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kentik {
namespace network_class {
namespace v202109alpha1 {

enum CloudType : int {
  CLOUD_TYPE_UNSPECIFIED = 0,
  CLOUD_TYPE_AWS = 1,
  CLOUD_TYPE_AZURE = 2,
  CLOUD_TYPE_GCE = 3,
  CLOUD_TYPE_IBM = 4,
  CloudType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CloudType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CloudType_IsValid(int value);
constexpr CloudType CloudType_MIN = CLOUD_TYPE_UNSPECIFIED;
constexpr CloudType CloudType_MAX = CLOUD_TYPE_IBM;
constexpr int CloudType_ARRAYSIZE = CloudType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloudType_descriptor();
template<typename T>
inline const std::string& CloudType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CloudType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CloudType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CloudType_descriptor(), enum_t_value);
}
inline bool CloudType_Parse(
    const std::string& name, CloudType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CloudType>(
    CloudType_descriptor(), name, value);
}
// ===================================================================

class CloudSubnet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.network_class.v202109alpha1.CloudSubnet) */ {
 public:
  inline CloudSubnet() : CloudSubnet(nullptr) {};
  virtual ~CloudSubnet();

  CloudSubnet(const CloudSubnet& from);
  CloudSubnet(CloudSubnet&& from) noexcept
    : CloudSubnet() {
    *this = ::std::move(from);
  }

  inline CloudSubnet& operator=(const CloudSubnet& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudSubnet& operator=(CloudSubnet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CloudSubnet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudSubnet* internal_default_instance() {
    return reinterpret_cast<const CloudSubnet*>(
               &_CloudSubnet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CloudSubnet& a, CloudSubnet& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudSubnet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudSubnet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CloudSubnet* New() const final {
    return CreateMaybeMessage<CloudSubnet>(nullptr);
  }

  CloudSubnet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CloudSubnet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CloudSubnet& from);
  void MergeFrom(const CloudSubnet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudSubnet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.network_class.v202109alpha1.CloudSubnet";
  }
  protected:
  explicit CloudSubnet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto);
    return ::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubnetsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string subnets = 2[json_name = "subnets"];
  int subnets_size() const;
  private:
  int _internal_subnets_size() const;
  public:
  void clear_subnets();
  const std::string& subnets(int index) const;
  std::string* mutable_subnets(int index);
  void set_subnets(int index, const std::string& value);
  void set_subnets(int index, std::string&& value);
  void set_subnets(int index, const char* value);
  void set_subnets(int index, const char* value, size_t size);
  std::string* add_subnets();
  void add_subnets(const std::string& value);
  void add_subnets(std::string&& value);
  void add_subnets(const char* value);
  void add_subnets(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subnets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subnets();
  private:
  const std::string& _internal_subnets(int index) const;
  std::string* _internal_add_subnets();
  public:

  // .kentik.network_class.v202109alpha1.CloudType type = 1[json_name = "type"];
  void clear_type();
  ::kentik::network_class::v202109alpha1::CloudType type() const;
  void set_type(::kentik::network_class::v202109alpha1::CloudType value);
  private:
  ::kentik::network_class::v202109alpha1::CloudType _internal_type() const;
  void _internal_set_type(::kentik::network_class::v202109alpha1::CloudType value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.network_class.v202109alpha1.CloudSubnet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subnets_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
};
// -------------------------------------------------------------------

class NetworkClass PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.network_class.v202109alpha1.NetworkClass) */ {
 public:
  inline NetworkClass() : NetworkClass(nullptr) {};
  virtual ~NetworkClass();

  NetworkClass(const NetworkClass& from);
  NetworkClass(NetworkClass&& from) noexcept
    : NetworkClass() {
    *this = ::std::move(from);
  }

  inline NetworkClass& operator=(const NetworkClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkClass& operator=(NetworkClass&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NetworkClass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkClass* internal_default_instance() {
    return reinterpret_cast<const NetworkClass*>(
               &_NetworkClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NetworkClass& a, NetworkClass& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkClass* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetworkClass* New() const final {
    return CreateMaybeMessage<NetworkClass>(nullptr);
  }

  NetworkClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetworkClass>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NetworkClass& from);
  void MergeFrom(const NetworkClass& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkClass* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.network_class.v202109alpha1.NetworkClass";
  }
  protected:
  explicit NetworkClass(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto);
    return ::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInternalAsnsFieldNumber = 1,
    kInternalIpsFieldNumber = 2,
    kCloudSubnetsFieldNumber = 5,
    kUsePrivateAsnsFieldNumber = 3,
    kUsePrivateSubnetsFieldNumber = 4,
  };
  // repeated string internal_asns = 1[json_name = "internalAsns"];
  int internal_asns_size() const;
  private:
  int _internal_internal_asns_size() const;
  public:
  void clear_internal_asns();
  const std::string& internal_asns(int index) const;
  std::string* mutable_internal_asns(int index);
  void set_internal_asns(int index, const std::string& value);
  void set_internal_asns(int index, std::string&& value);
  void set_internal_asns(int index, const char* value);
  void set_internal_asns(int index, const char* value, size_t size);
  std::string* add_internal_asns();
  void add_internal_asns(const std::string& value);
  void add_internal_asns(std::string&& value);
  void add_internal_asns(const char* value);
  void add_internal_asns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& internal_asns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_internal_asns();
  private:
  const std::string& _internal_internal_asns(int index) const;
  std::string* _internal_add_internal_asns();
  public:

  // repeated string internal_ips = 2[json_name = "internalIps"];
  int internal_ips_size() const;
  private:
  int _internal_internal_ips_size() const;
  public:
  void clear_internal_ips();
  const std::string& internal_ips(int index) const;
  std::string* mutable_internal_ips(int index);
  void set_internal_ips(int index, const std::string& value);
  void set_internal_ips(int index, std::string&& value);
  void set_internal_ips(int index, const char* value);
  void set_internal_ips(int index, const char* value, size_t size);
  std::string* add_internal_ips();
  void add_internal_ips(const std::string& value);
  void add_internal_ips(std::string&& value);
  void add_internal_ips(const char* value);
  void add_internal_ips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& internal_ips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_internal_ips();
  private:
  const std::string& _internal_internal_ips(int index) const;
  std::string* _internal_add_internal_ips();
  public:

  // repeated .kentik.network_class.v202109alpha1.CloudSubnet cloud_subnets = 5[json_name = "cloudSubnets"];
  int cloud_subnets_size() const;
  private:
  int _internal_cloud_subnets_size() const;
  public:
  void clear_cloud_subnets();
  ::kentik::network_class::v202109alpha1::CloudSubnet* mutable_cloud_subnets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::network_class::v202109alpha1::CloudSubnet >*
      mutable_cloud_subnets();
  private:
  const ::kentik::network_class::v202109alpha1::CloudSubnet& _internal_cloud_subnets(int index) const;
  ::kentik::network_class::v202109alpha1::CloudSubnet* _internal_add_cloud_subnets();
  public:
  const ::kentik::network_class::v202109alpha1::CloudSubnet& cloud_subnets(int index) const;
  ::kentik::network_class::v202109alpha1::CloudSubnet* add_cloud_subnets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::network_class::v202109alpha1::CloudSubnet >&
      cloud_subnets() const;

  // bool use_private_asns = 3[json_name = "usePrivateAsns"];
  void clear_use_private_asns();
  bool use_private_asns() const;
  void set_use_private_asns(bool value);
  private:
  bool _internal_use_private_asns() const;
  void _internal_set_use_private_asns(bool value);
  public:

  // bool use_private_subnets = 4[json_name = "usePrivateSubnets"];
  void clear_use_private_subnets();
  bool use_private_subnets() const;
  void set_use_private_subnets(bool value);
  private:
  bool _internal_use_private_subnets() const;
  void _internal_set_use_private_subnets(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.network_class.v202109alpha1.NetworkClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> internal_asns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> internal_ips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::network_class::v202109alpha1::CloudSubnet > cloud_subnets_;
  bool use_private_asns_;
  bool use_private_subnets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkClassRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.network_class.v202109alpha1.GetNetworkClassRequest) */ {
 public:
  inline GetNetworkClassRequest() : GetNetworkClassRequest(nullptr) {};
  virtual ~GetNetworkClassRequest();

  GetNetworkClassRequest(const GetNetworkClassRequest& from);
  GetNetworkClassRequest(GetNetworkClassRequest&& from) noexcept
    : GetNetworkClassRequest() {
    *this = ::std::move(from);
  }

  inline GetNetworkClassRequest& operator=(const GetNetworkClassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkClassRequest& operator=(GetNetworkClassRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetNetworkClassRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNetworkClassRequest* internal_default_instance() {
    return reinterpret_cast<const GetNetworkClassRequest*>(
               &_GetNetworkClassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetNetworkClassRequest& a, GetNetworkClassRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkClassRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkClassRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkClassRequest* New() const final {
    return CreateMaybeMessage<GetNetworkClassRequest>(nullptr);
  }

  GetNetworkClassRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkClassRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetNetworkClassRequest& from);
  void MergeFrom(const GetNetworkClassRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkClassRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.network_class.v202109alpha1.GetNetworkClassRequest";
  }
  protected:
  explicit GetNetworkClassRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto);
    return ::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.network_class.v202109alpha1.GetNetworkClassRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkClassResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.network_class.v202109alpha1.GetNetworkClassResponse) */ {
 public:
  inline GetNetworkClassResponse() : GetNetworkClassResponse(nullptr) {};
  virtual ~GetNetworkClassResponse();

  GetNetworkClassResponse(const GetNetworkClassResponse& from);
  GetNetworkClassResponse(GetNetworkClassResponse&& from) noexcept
    : GetNetworkClassResponse() {
    *this = ::std::move(from);
  }

  inline GetNetworkClassResponse& operator=(const GetNetworkClassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkClassResponse& operator=(GetNetworkClassResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetNetworkClassResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNetworkClassResponse* internal_default_instance() {
    return reinterpret_cast<const GetNetworkClassResponse*>(
               &_GetNetworkClassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetNetworkClassResponse& a, GetNetworkClassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkClassResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkClassResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkClassResponse* New() const final {
    return CreateMaybeMessage<GetNetworkClassResponse>(nullptr);
  }

  GetNetworkClassResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkClassResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetNetworkClassResponse& from);
  void MergeFrom(const GetNetworkClassResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkClassResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.network_class.v202109alpha1.GetNetworkClassResponse";
  }
  protected:
  explicit GetNetworkClassResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto);
    return ::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkClassFieldNumber = 1,
  };
  // .kentik.network_class.v202109alpha1.NetworkClass network_class = 1[json_name = "networkClass"];
  bool has_network_class() const;
  private:
  bool _internal_has_network_class() const;
  public:
  void clear_network_class();
  const ::kentik::network_class::v202109alpha1::NetworkClass& network_class() const;
  ::kentik::network_class::v202109alpha1::NetworkClass* release_network_class();
  ::kentik::network_class::v202109alpha1::NetworkClass* mutable_network_class();
  void set_allocated_network_class(::kentik::network_class::v202109alpha1::NetworkClass* network_class);
  private:
  const ::kentik::network_class::v202109alpha1::NetworkClass& _internal_network_class() const;
  ::kentik::network_class::v202109alpha1::NetworkClass* _internal_mutable_network_class();
  public:
  void unsafe_arena_set_allocated_network_class(
      ::kentik::network_class::v202109alpha1::NetworkClass* network_class);
  ::kentik::network_class::v202109alpha1::NetworkClass* unsafe_arena_release_network_class();

  // @@protoc_insertion_point(class_scope:kentik.network_class.v202109alpha1.GetNetworkClassResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::network_class::v202109alpha1::NetworkClass* network_class_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetworkClassRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest) */ {
 public:
  inline UpdateNetworkClassRequest() : UpdateNetworkClassRequest(nullptr) {};
  virtual ~UpdateNetworkClassRequest();

  UpdateNetworkClassRequest(const UpdateNetworkClassRequest& from);
  UpdateNetworkClassRequest(UpdateNetworkClassRequest&& from) noexcept
    : UpdateNetworkClassRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNetworkClassRequest& operator=(const UpdateNetworkClassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNetworkClassRequest& operator=(UpdateNetworkClassRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateNetworkClassRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNetworkClassRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNetworkClassRequest*>(
               &_UpdateNetworkClassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateNetworkClassRequest& a, UpdateNetworkClassRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNetworkClassRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNetworkClassRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNetworkClassRequest* New() const final {
    return CreateMaybeMessage<UpdateNetworkClassRequest>(nullptr);
  }

  UpdateNetworkClassRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNetworkClassRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateNetworkClassRequest& from);
  void MergeFrom(const UpdateNetworkClassRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetworkClassRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.network_class.v202109alpha1.UpdateNetworkClassRequest";
  }
  protected:
  explicit UpdateNetworkClassRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto);
    return ::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkClassFieldNumber = 1,
  };
  // .kentik.network_class.v202109alpha1.NetworkClass network_class = 1[json_name = "networkClass"];
  bool has_network_class() const;
  private:
  bool _internal_has_network_class() const;
  public:
  void clear_network_class();
  const ::kentik::network_class::v202109alpha1::NetworkClass& network_class() const;
  ::kentik::network_class::v202109alpha1::NetworkClass* release_network_class();
  ::kentik::network_class::v202109alpha1::NetworkClass* mutable_network_class();
  void set_allocated_network_class(::kentik::network_class::v202109alpha1::NetworkClass* network_class);
  private:
  const ::kentik::network_class::v202109alpha1::NetworkClass& _internal_network_class() const;
  ::kentik::network_class::v202109alpha1::NetworkClass* _internal_mutable_network_class();
  public:
  void unsafe_arena_set_allocated_network_class(
      ::kentik::network_class::v202109alpha1::NetworkClass* network_class);
  ::kentik::network_class::v202109alpha1::NetworkClass* unsafe_arena_release_network_class();

  // @@protoc_insertion_point(class_scope:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::network_class::v202109alpha1::NetworkClass* network_class_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetworkClassResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse) */ {
 public:
  inline UpdateNetworkClassResponse() : UpdateNetworkClassResponse(nullptr) {};
  virtual ~UpdateNetworkClassResponse();

  UpdateNetworkClassResponse(const UpdateNetworkClassResponse& from);
  UpdateNetworkClassResponse(UpdateNetworkClassResponse&& from) noexcept
    : UpdateNetworkClassResponse() {
    *this = ::std::move(from);
  }

  inline UpdateNetworkClassResponse& operator=(const UpdateNetworkClassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNetworkClassResponse& operator=(UpdateNetworkClassResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateNetworkClassResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNetworkClassResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateNetworkClassResponse*>(
               &_UpdateNetworkClassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateNetworkClassResponse& a, UpdateNetworkClassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNetworkClassResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNetworkClassResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNetworkClassResponse* New() const final {
    return CreateMaybeMessage<UpdateNetworkClassResponse>(nullptr);
  }

  UpdateNetworkClassResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNetworkClassResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateNetworkClassResponse& from);
  void MergeFrom(const UpdateNetworkClassResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetworkClassResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.network_class.v202109alpha1.UpdateNetworkClassResponse";
  }
  protected:
  explicit UpdateNetworkClassResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto);
    return ::descriptor_table_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkClassFieldNumber = 1,
  };
  // .kentik.network_class.v202109alpha1.NetworkClass network_class = 1[json_name = "networkClass"];
  bool has_network_class() const;
  private:
  bool _internal_has_network_class() const;
  public:
  void clear_network_class();
  const ::kentik::network_class::v202109alpha1::NetworkClass& network_class() const;
  ::kentik::network_class::v202109alpha1::NetworkClass* release_network_class();
  ::kentik::network_class::v202109alpha1::NetworkClass* mutable_network_class();
  void set_allocated_network_class(::kentik::network_class::v202109alpha1::NetworkClass* network_class);
  private:
  const ::kentik::network_class::v202109alpha1::NetworkClass& _internal_network_class() const;
  ::kentik::network_class::v202109alpha1::NetworkClass* _internal_mutable_network_class();
  public:
  void unsafe_arena_set_allocated_network_class(
      ::kentik::network_class::v202109alpha1::NetworkClass* network_class);
  ::kentik::network_class::v202109alpha1::NetworkClass* unsafe_arena_release_network_class();

  // @@protoc_insertion_point(class_scope:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::network_class::v202109alpha1::NetworkClass* network_class_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CloudSubnet

// .kentik.network_class.v202109alpha1.CloudType type = 1[json_name = "type"];
inline void CloudSubnet::clear_type() {
  type_ = 0;
}
inline ::kentik::network_class::v202109alpha1::CloudType CloudSubnet::_internal_type() const {
  return static_cast< ::kentik::network_class::v202109alpha1::CloudType >(type_);
}
inline ::kentik::network_class::v202109alpha1::CloudType CloudSubnet::type() const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.CloudSubnet.type)
  return _internal_type();
}
inline void CloudSubnet::_internal_set_type(::kentik::network_class::v202109alpha1::CloudType value) {
  
  type_ = value;
}
inline void CloudSubnet::set_type(::kentik::network_class::v202109alpha1::CloudType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.CloudSubnet.type)
}

// repeated string subnets = 2[json_name = "subnets"];
inline int CloudSubnet::_internal_subnets_size() const {
  return subnets_.size();
}
inline int CloudSubnet::subnets_size() const {
  return _internal_subnets_size();
}
inline void CloudSubnet::clear_subnets() {
  subnets_.Clear();
}
inline std::string* CloudSubnet::add_subnets() {
  // @@protoc_insertion_point(field_add_mutable:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  return _internal_add_subnets();
}
inline const std::string& CloudSubnet::_internal_subnets(int index) const {
  return subnets_.Get(index);
}
inline const std::string& CloudSubnet::subnets(int index) const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  return _internal_subnets(index);
}
inline std::string* CloudSubnet::mutable_subnets(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  return subnets_.Mutable(index);
}
inline void CloudSubnet::set_subnets(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  subnets_.Mutable(index)->assign(value);
}
inline void CloudSubnet::set_subnets(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  subnets_.Mutable(index)->assign(std::move(value));
}
inline void CloudSubnet::set_subnets(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  subnets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
}
inline void CloudSubnet::set_subnets(int index, const char* value, size_t size) {
  subnets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
}
inline std::string* CloudSubnet::_internal_add_subnets() {
  return subnets_.Add();
}
inline void CloudSubnet::add_subnets(const std::string& value) {
  subnets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
}
inline void CloudSubnet::add_subnets(std::string&& value) {
  subnets_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
}
inline void CloudSubnet::add_subnets(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  subnets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
}
inline void CloudSubnet::add_subnets(const char* value, size_t size) {
  subnets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CloudSubnet::subnets() const {
  // @@protoc_insertion_point(field_list:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  return subnets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CloudSubnet::mutable_subnets() {
  // @@protoc_insertion_point(field_mutable_list:kentik.network_class.v202109alpha1.CloudSubnet.subnets)
  return &subnets_;
}

// -------------------------------------------------------------------

// NetworkClass

// repeated string internal_asns = 1[json_name = "internalAsns"];
inline int NetworkClass::_internal_internal_asns_size() const {
  return internal_asns_.size();
}
inline int NetworkClass::internal_asns_size() const {
  return _internal_internal_asns_size();
}
inline void NetworkClass::clear_internal_asns() {
  internal_asns_.Clear();
}
inline std::string* NetworkClass::add_internal_asns() {
  // @@protoc_insertion_point(field_add_mutable:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  return _internal_add_internal_asns();
}
inline const std::string& NetworkClass::_internal_internal_asns(int index) const {
  return internal_asns_.Get(index);
}
inline const std::string& NetworkClass::internal_asns(int index) const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  return _internal_internal_asns(index);
}
inline std::string* NetworkClass::mutable_internal_asns(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  return internal_asns_.Mutable(index);
}
inline void NetworkClass::set_internal_asns(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  internal_asns_.Mutable(index)->assign(value);
}
inline void NetworkClass::set_internal_asns(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  internal_asns_.Mutable(index)->assign(std::move(value));
}
inline void NetworkClass::set_internal_asns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  internal_asns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
}
inline void NetworkClass::set_internal_asns(int index, const char* value, size_t size) {
  internal_asns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
}
inline std::string* NetworkClass::_internal_add_internal_asns() {
  return internal_asns_.Add();
}
inline void NetworkClass::add_internal_asns(const std::string& value) {
  internal_asns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
}
inline void NetworkClass::add_internal_asns(std::string&& value) {
  internal_asns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
}
inline void NetworkClass::add_internal_asns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  internal_asns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
}
inline void NetworkClass::add_internal_asns(const char* value, size_t size) {
  internal_asns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkClass::internal_asns() const {
  // @@protoc_insertion_point(field_list:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  return internal_asns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkClass::mutable_internal_asns() {
  // @@protoc_insertion_point(field_mutable_list:kentik.network_class.v202109alpha1.NetworkClass.internal_asns)
  return &internal_asns_;
}

// repeated string internal_ips = 2[json_name = "internalIps"];
inline int NetworkClass::_internal_internal_ips_size() const {
  return internal_ips_.size();
}
inline int NetworkClass::internal_ips_size() const {
  return _internal_internal_ips_size();
}
inline void NetworkClass::clear_internal_ips() {
  internal_ips_.Clear();
}
inline std::string* NetworkClass::add_internal_ips() {
  // @@protoc_insertion_point(field_add_mutable:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  return _internal_add_internal_ips();
}
inline const std::string& NetworkClass::_internal_internal_ips(int index) const {
  return internal_ips_.Get(index);
}
inline const std::string& NetworkClass::internal_ips(int index) const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  return _internal_internal_ips(index);
}
inline std::string* NetworkClass::mutable_internal_ips(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  return internal_ips_.Mutable(index);
}
inline void NetworkClass::set_internal_ips(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  internal_ips_.Mutable(index)->assign(value);
}
inline void NetworkClass::set_internal_ips(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  internal_ips_.Mutable(index)->assign(std::move(value));
}
inline void NetworkClass::set_internal_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  internal_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
}
inline void NetworkClass::set_internal_ips(int index, const char* value, size_t size) {
  internal_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
}
inline std::string* NetworkClass::_internal_add_internal_ips() {
  return internal_ips_.Add();
}
inline void NetworkClass::add_internal_ips(const std::string& value) {
  internal_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
}
inline void NetworkClass::add_internal_ips(std::string&& value) {
  internal_ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
}
inline void NetworkClass::add_internal_ips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  internal_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
}
inline void NetworkClass::add_internal_ips(const char* value, size_t size) {
  internal_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkClass::internal_ips() const {
  // @@protoc_insertion_point(field_list:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  return internal_ips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkClass::mutable_internal_ips() {
  // @@protoc_insertion_point(field_mutable_list:kentik.network_class.v202109alpha1.NetworkClass.internal_ips)
  return &internal_ips_;
}

// bool use_private_asns = 3[json_name = "usePrivateAsns"];
inline void NetworkClass::clear_use_private_asns() {
  use_private_asns_ = false;
}
inline bool NetworkClass::_internal_use_private_asns() const {
  return use_private_asns_;
}
inline bool NetworkClass::use_private_asns() const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.NetworkClass.use_private_asns)
  return _internal_use_private_asns();
}
inline void NetworkClass::_internal_set_use_private_asns(bool value) {
  
  use_private_asns_ = value;
}
inline void NetworkClass::set_use_private_asns(bool value) {
  _internal_set_use_private_asns(value);
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.NetworkClass.use_private_asns)
}

// bool use_private_subnets = 4[json_name = "usePrivateSubnets"];
inline void NetworkClass::clear_use_private_subnets() {
  use_private_subnets_ = false;
}
inline bool NetworkClass::_internal_use_private_subnets() const {
  return use_private_subnets_;
}
inline bool NetworkClass::use_private_subnets() const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.NetworkClass.use_private_subnets)
  return _internal_use_private_subnets();
}
inline void NetworkClass::_internal_set_use_private_subnets(bool value) {
  
  use_private_subnets_ = value;
}
inline void NetworkClass::set_use_private_subnets(bool value) {
  _internal_set_use_private_subnets(value);
  // @@protoc_insertion_point(field_set:kentik.network_class.v202109alpha1.NetworkClass.use_private_subnets)
}

// repeated .kentik.network_class.v202109alpha1.CloudSubnet cloud_subnets = 5[json_name = "cloudSubnets"];
inline int NetworkClass::_internal_cloud_subnets_size() const {
  return cloud_subnets_.size();
}
inline int NetworkClass::cloud_subnets_size() const {
  return _internal_cloud_subnets_size();
}
inline void NetworkClass::clear_cloud_subnets() {
  cloud_subnets_.Clear();
}
inline ::kentik::network_class::v202109alpha1::CloudSubnet* NetworkClass::mutable_cloud_subnets(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.NetworkClass.cloud_subnets)
  return cloud_subnets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::network_class::v202109alpha1::CloudSubnet >*
NetworkClass::mutable_cloud_subnets() {
  // @@protoc_insertion_point(field_mutable_list:kentik.network_class.v202109alpha1.NetworkClass.cloud_subnets)
  return &cloud_subnets_;
}
inline const ::kentik::network_class::v202109alpha1::CloudSubnet& NetworkClass::_internal_cloud_subnets(int index) const {
  return cloud_subnets_.Get(index);
}
inline const ::kentik::network_class::v202109alpha1::CloudSubnet& NetworkClass::cloud_subnets(int index) const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.NetworkClass.cloud_subnets)
  return _internal_cloud_subnets(index);
}
inline ::kentik::network_class::v202109alpha1::CloudSubnet* NetworkClass::_internal_add_cloud_subnets() {
  return cloud_subnets_.Add();
}
inline ::kentik::network_class::v202109alpha1::CloudSubnet* NetworkClass::add_cloud_subnets() {
  // @@protoc_insertion_point(field_add:kentik.network_class.v202109alpha1.NetworkClass.cloud_subnets)
  return _internal_add_cloud_subnets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::network_class::v202109alpha1::CloudSubnet >&
NetworkClass::cloud_subnets() const {
  // @@protoc_insertion_point(field_list:kentik.network_class.v202109alpha1.NetworkClass.cloud_subnets)
  return cloud_subnets_;
}

// -------------------------------------------------------------------

// GetNetworkClassRequest

// -------------------------------------------------------------------

// GetNetworkClassResponse

// .kentik.network_class.v202109alpha1.NetworkClass network_class = 1[json_name = "networkClass"];
inline bool GetNetworkClassResponse::_internal_has_network_class() const {
  return this != internal_default_instance() && network_class_ != nullptr;
}
inline bool GetNetworkClassResponse::has_network_class() const {
  return _internal_has_network_class();
}
inline void GetNetworkClassResponse::clear_network_class() {
  if (GetArena() == nullptr && network_class_ != nullptr) {
    delete network_class_;
  }
  network_class_ = nullptr;
}
inline const ::kentik::network_class::v202109alpha1::NetworkClass& GetNetworkClassResponse::_internal_network_class() const {
  const ::kentik::network_class::v202109alpha1::NetworkClass* p = network_class_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::network_class::v202109alpha1::NetworkClass*>(
      &::kentik::network_class::v202109alpha1::_NetworkClass_default_instance_);
}
inline const ::kentik::network_class::v202109alpha1::NetworkClass& GetNetworkClassResponse::network_class() const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.GetNetworkClassResponse.network_class)
  return _internal_network_class();
}
inline void GetNetworkClassResponse::unsafe_arena_set_allocated_network_class(
    ::kentik::network_class::v202109alpha1::NetworkClass* network_class) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_class_);
  }
  network_class_ = network_class;
  if (network_class) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.network_class.v202109alpha1.GetNetworkClassResponse.network_class)
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* GetNetworkClassResponse::release_network_class() {
  auto temp = unsafe_arena_release_network_class();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* GetNetworkClassResponse::unsafe_arena_release_network_class() {
  // @@protoc_insertion_point(field_release:kentik.network_class.v202109alpha1.GetNetworkClassResponse.network_class)
  
  ::kentik::network_class::v202109alpha1::NetworkClass* temp = network_class_;
  network_class_ = nullptr;
  return temp;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* GetNetworkClassResponse::_internal_mutable_network_class() {
  
  if (network_class_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::network_class::v202109alpha1::NetworkClass>(GetArena());
    network_class_ = p;
  }
  return network_class_;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* GetNetworkClassResponse::mutable_network_class() {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.GetNetworkClassResponse.network_class)
  return _internal_mutable_network_class();
}
inline void GetNetworkClassResponse::set_allocated_network_class(::kentik::network_class::v202109alpha1::NetworkClass* network_class) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete network_class_;
  }
  if (network_class) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(network_class);
    if (message_arena != submessage_arena) {
      network_class = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_class, submessage_arena);
    }
    
  } else {
    
  }
  network_class_ = network_class;
  // @@protoc_insertion_point(field_set_allocated:kentik.network_class.v202109alpha1.GetNetworkClassResponse.network_class)
}

// -------------------------------------------------------------------

// UpdateNetworkClassRequest

// .kentik.network_class.v202109alpha1.NetworkClass network_class = 1[json_name = "networkClass"];
inline bool UpdateNetworkClassRequest::_internal_has_network_class() const {
  return this != internal_default_instance() && network_class_ != nullptr;
}
inline bool UpdateNetworkClassRequest::has_network_class() const {
  return _internal_has_network_class();
}
inline void UpdateNetworkClassRequest::clear_network_class() {
  if (GetArena() == nullptr && network_class_ != nullptr) {
    delete network_class_;
  }
  network_class_ = nullptr;
}
inline const ::kentik::network_class::v202109alpha1::NetworkClass& UpdateNetworkClassRequest::_internal_network_class() const {
  const ::kentik::network_class::v202109alpha1::NetworkClass* p = network_class_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::network_class::v202109alpha1::NetworkClass*>(
      &::kentik::network_class::v202109alpha1::_NetworkClass_default_instance_);
}
inline const ::kentik::network_class::v202109alpha1::NetworkClass& UpdateNetworkClassRequest::network_class() const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest.network_class)
  return _internal_network_class();
}
inline void UpdateNetworkClassRequest::unsafe_arena_set_allocated_network_class(
    ::kentik::network_class::v202109alpha1::NetworkClass* network_class) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_class_);
  }
  network_class_ = network_class;
  if (network_class) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest.network_class)
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassRequest::release_network_class() {
  auto temp = unsafe_arena_release_network_class();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassRequest::unsafe_arena_release_network_class() {
  // @@protoc_insertion_point(field_release:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest.network_class)
  
  ::kentik::network_class::v202109alpha1::NetworkClass* temp = network_class_;
  network_class_ = nullptr;
  return temp;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassRequest::_internal_mutable_network_class() {
  
  if (network_class_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::network_class::v202109alpha1::NetworkClass>(GetArena());
    network_class_ = p;
  }
  return network_class_;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassRequest::mutable_network_class() {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest.network_class)
  return _internal_mutable_network_class();
}
inline void UpdateNetworkClassRequest::set_allocated_network_class(::kentik::network_class::v202109alpha1::NetworkClass* network_class) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete network_class_;
  }
  if (network_class) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(network_class);
    if (message_arena != submessage_arena) {
      network_class = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_class, submessage_arena);
    }
    
  } else {
    
  }
  network_class_ = network_class;
  // @@protoc_insertion_point(field_set_allocated:kentik.network_class.v202109alpha1.UpdateNetworkClassRequest.network_class)
}

// -------------------------------------------------------------------

// UpdateNetworkClassResponse

// .kentik.network_class.v202109alpha1.NetworkClass network_class = 1[json_name = "networkClass"];
inline bool UpdateNetworkClassResponse::_internal_has_network_class() const {
  return this != internal_default_instance() && network_class_ != nullptr;
}
inline bool UpdateNetworkClassResponse::has_network_class() const {
  return _internal_has_network_class();
}
inline void UpdateNetworkClassResponse::clear_network_class() {
  if (GetArena() == nullptr && network_class_ != nullptr) {
    delete network_class_;
  }
  network_class_ = nullptr;
}
inline const ::kentik::network_class::v202109alpha1::NetworkClass& UpdateNetworkClassResponse::_internal_network_class() const {
  const ::kentik::network_class::v202109alpha1::NetworkClass* p = network_class_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::network_class::v202109alpha1::NetworkClass*>(
      &::kentik::network_class::v202109alpha1::_NetworkClass_default_instance_);
}
inline const ::kentik::network_class::v202109alpha1::NetworkClass& UpdateNetworkClassResponse::network_class() const {
  // @@protoc_insertion_point(field_get:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse.network_class)
  return _internal_network_class();
}
inline void UpdateNetworkClassResponse::unsafe_arena_set_allocated_network_class(
    ::kentik::network_class::v202109alpha1::NetworkClass* network_class) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_class_);
  }
  network_class_ = network_class;
  if (network_class) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse.network_class)
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassResponse::release_network_class() {
  auto temp = unsafe_arena_release_network_class();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassResponse::unsafe_arena_release_network_class() {
  // @@protoc_insertion_point(field_release:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse.network_class)
  
  ::kentik::network_class::v202109alpha1::NetworkClass* temp = network_class_;
  network_class_ = nullptr;
  return temp;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassResponse::_internal_mutable_network_class() {
  
  if (network_class_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::network_class::v202109alpha1::NetworkClass>(GetArena());
    network_class_ = p;
  }
  return network_class_;
}
inline ::kentik::network_class::v202109alpha1::NetworkClass* UpdateNetworkClassResponse::mutable_network_class() {
  // @@protoc_insertion_point(field_mutable:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse.network_class)
  return _internal_mutable_network_class();
}
inline void UpdateNetworkClassResponse::set_allocated_network_class(::kentik::network_class::v202109alpha1::NetworkClass* network_class) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete network_class_;
  }
  if (network_class) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(network_class);
    if (message_arena != submessage_arena) {
      network_class = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_class, submessage_arena);
    }
    
  } else {
    
  }
  network_class_ = network_class;
  // @@protoc_insertion_point(field_set_allocated:kentik.network_class.v202109alpha1.UpdateNetworkClassResponse.network_class)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v202109alpha1
}  // namespace network_class
}  // namespace kentik

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kentik::network_class::v202109alpha1::CloudType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::network_class::v202109alpha1::CloudType>() {
  return ::kentik::network_class::v202109alpha1::CloudType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kentik_2fnetwork_5fclass_2fv202109alpha1_2fnetwork_5fclass_2eproto
