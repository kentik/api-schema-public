// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: kentik/mkp/v202102alpha1/mkp.proto
// Protobuf C++ Version: 5.29.3

#ifndef kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto_2epb_2eh
#define kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/protobuf/field_mask.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "kentik/core/v202303/annotations.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
namespace kentik {
namespace mkp {
namespace v202102alpha1 {
class Activate;
struct ActivateDefaultTypeInternal;
extern ActivateDefaultTypeInternal _Activate_default_instance_;
class Alert;
struct AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class Asset;
struct AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class Asset_Report;
struct Asset_ReportDefaultTypeInternal;
extern Asset_ReportDefaultTypeInternal _Asset_Report_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class CreatePackageRequest;
struct CreatePackageRequestDefaultTypeInternal;
extern CreatePackageRequestDefaultTypeInternal _CreatePackageRequest_default_instance_;
class CreatePackageResponse;
struct CreatePackageResponseDefaultTypeInternal;
extern CreatePackageResponseDefaultTypeInternal _CreatePackageResponse_default_instance_;
class CreateTenantRequest;
struct CreateTenantRequestDefaultTypeInternal;
extern CreateTenantRequestDefaultTypeInternal _CreateTenantRequest_default_instance_;
class CreateTenantResponse;
struct CreateTenantResponseDefaultTypeInternal;
extern CreateTenantResponseDefaultTypeInternal _CreateTenantResponse_default_instance_;
class CustomDimension;
struct CustomDimensionDefaultTypeInternal;
extern CustomDimensionDefaultTypeInternal _CustomDimension_default_instance_;
class DeletePackageRequest;
struct DeletePackageRequestDefaultTypeInternal;
extern DeletePackageRequestDefaultTypeInternal _DeletePackageRequest_default_instance_;
class DeletePackageResponse;
struct DeletePackageResponseDefaultTypeInternal;
extern DeletePackageResponseDefaultTypeInternal _DeletePackageResponse_default_instance_;
class DeleteTenantRequest;
struct DeleteTenantRequestDefaultTypeInternal;
extern DeleteTenantRequestDefaultTypeInternal _DeleteTenantRequest_default_instance_;
class DeleteTenantResponse;
struct DeleteTenantResponseDefaultTypeInternal;
extern DeleteTenantResponseDefaultTypeInternal _DeleteTenantResponse_default_instance_;
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class FilterField;
struct FilterFieldDefaultTypeInternal;
extern FilterFieldDefaultTypeInternal _FilterField_default_instance_;
class GetPackageRequest;
struct GetPackageRequestDefaultTypeInternal;
extern GetPackageRequestDefaultTypeInternal _GetPackageRequest_default_instance_;
class GetPackageResponse;
struct GetPackageResponseDefaultTypeInternal;
extern GetPackageResponseDefaultTypeInternal _GetPackageResponse_default_instance_;
class GetTenantRequest;
struct GetTenantRequestDefaultTypeInternal;
extern GetTenantRequestDefaultTypeInternal _GetTenantRequest_default_instance_;
class GetTenantResponse;
struct GetTenantResponseDefaultTypeInternal;
extern GetTenantResponseDefaultTypeInternal _GetTenantResponse_default_instance_;
class ListPackageRequest;
struct ListPackageRequestDefaultTypeInternal;
extern ListPackageRequestDefaultTypeInternal _ListPackageRequest_default_instance_;
class ListPackageResponse;
struct ListPackageResponseDefaultTypeInternal;
extern ListPackageResponseDefaultTypeInternal _ListPackageResponse_default_instance_;
class ListTenantRequest;
struct ListTenantRequestDefaultTypeInternal;
extern ListTenantRequestDefaultTypeInternal _ListTenantRequest_default_instance_;
class ListTenantResponse;
struct ListTenantResponseDefaultTypeInternal;
extern ListTenantResponseDefaultTypeInternal _ListTenantResponse_default_instance_;
class Mitigation;
struct MitigationDefaultTypeInternal;
extern MitigationDefaultTypeInternal _Mitigation_default_instance_;
class NotificationChannel;
struct NotificationChannelDefaultTypeInternal;
extern NotificationChannelDefaultTypeInternal _NotificationChannel_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class PatchPackageRequest;
struct PatchPackageRequestDefaultTypeInternal;
extern PatchPackageRequestDefaultTypeInternal _PatchPackageRequest_default_instance_;
class PatchPackageResponse;
struct PatchPackageResponseDefaultTypeInternal;
extern PatchPackageResponseDefaultTypeInternal _PatchPackageResponse_default_instance_;
class PatchTenantRequest;
struct PatchTenantRequestDefaultTypeInternal;
extern PatchTenantRequestDefaultTypeInternal _PatchTenantRequest_default_instance_;
class PatchTenantResponse;
struct PatchTenantResponseDefaultTypeInternal;
extern PatchTenantResponseDefaultTypeInternal _PatchTenantResponse_default_instance_;
class Tenant;
struct TenantDefaultTypeInternal;
extern TenantDefaultTypeInternal _Tenant_default_instance_;
class TenantLink;
struct TenantLinkDefaultTypeInternal;
extern TenantLinkDefaultTypeInternal _TenantLink_default_instance_;
class Threshold;
struct ThresholdDefaultTypeInternal;
extern ThresholdDefaultTypeInternal _Threshold_default_instance_;
class UpdatePackageRequest;
struct UpdatePackageRequestDefaultTypeInternal;
extern UpdatePackageRequestDefaultTypeInternal _UpdatePackageRequest_default_instance_;
class UpdatePackageResponse;
struct UpdatePackageResponseDefaultTypeInternal;
extern UpdatePackageResponseDefaultTypeInternal _UpdatePackageResponse_default_instance_;
class UpdateTenantRequest;
struct UpdateTenantRequestDefaultTypeInternal;
extern UpdateTenantRequestDefaultTypeInternal _UpdateTenantRequest_default_instance_;
class UpdateTenantResponse;
struct UpdateTenantResponseDefaultTypeInternal;
extern UpdateTenantResponseDefaultTypeInternal _UpdateTenantResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v202102alpha1
}  // namespace mkp
}  // namespace kentik
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kentik {
namespace mkp {
namespace v202102alpha1 {

// ===================================================================


// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(User* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(User));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(User* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserEmailFieldNumber = 3,
    kUserNameFieldNumber = 4,
    kUserFullNameFieldNumber = 5,
    kLastLoginFieldNumber = 7,
    kRoleFieldNumber = 9,
    kIdFieldNumber = 1,
    kCompanyIdFieldNumber = 2,
    kUserGroupIdFieldNumber = 6,
    kPermissionOverridesFieldNumber = 8,
    kUserLevelFieldNumber = 10,
  };
  // string user_email = 3 [json_name = "userEmail"];
  void clear_user_email() ;
  const std::string& user_email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_email(Arg_&& arg, Args_... args);
  std::string* mutable_user_email();
  PROTOBUF_NODISCARD std::string* release_user_email();
  void set_allocated_user_email(std::string* value);

  private:
  const std::string& _internal_user_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_email(
      const std::string& value);
  std::string* _internal_mutable_user_email();

  public:
  // string user_name = 4 [json_name = "userName"];
  void clear_user_name() ;
  const std::string& user_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_name(Arg_&& arg, Args_... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* value);

  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(
      const std::string& value);
  std::string* _internal_mutable_user_name();

  public:
  // string user_full_name = 5 [json_name = "userFullName"];
  void clear_user_full_name() ;
  const std::string& user_full_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_full_name(Arg_&& arg, Args_... args);
  std::string* mutable_user_full_name();
  PROTOBUF_NODISCARD std::string* release_user_full_name();
  void set_allocated_user_full_name(std::string* value);

  private:
  const std::string& _internal_user_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_full_name(
      const std::string& value);
  std::string* _internal_mutable_user_full_name();

  public:
  // string last_login = 7 [json_name = "lastLogin"];
  void clear_last_login() ;
  const std::string& last_login() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_login(Arg_&& arg, Args_... args);
  std::string* mutable_last_login();
  PROTOBUF_NODISCARD std::string* release_last_login();
  void set_allocated_last_login(std::string* value);

  private:
  const std::string& _internal_last_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_login(
      const std::string& value);
  std::string* _internal_mutable_last_login();

  public:
  // string role = 9 [json_name = "role"];
  void clear_role() ;
  const std::string& role() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* value);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 company_id = 2 [json_name = "companyId"];
  void clear_company_id() ;
  ::uint64_t company_id() const;
  void set_company_id(::uint64_t value);

  private:
  ::uint64_t _internal_company_id() const;
  void _internal_set_company_id(::uint64_t value);

  public:
  // uint64 user_group_id = 6 [json_name = "userGroupId"];
  void clear_user_group_id() ;
  ::uint64_t user_group_id() const;
  void set_user_group_id(::uint64_t value);

  private:
  ::uint64_t _internal_user_group_id() const;
  void _internal_set_user_group_id(::uint64_t value);

  public:
  // bool permission_overrides = 8 [json_name = "permissionOverrides"];
  void clear_permission_overrides() ;
  bool permission_overrides() const;
  void set_permission_overrides(bool value);

  private:
  bool _internal_permission_overrides() const;
  void _internal_set_permission_overrides(bool value);

  public:
  // uint32 user_level = 10 [json_name = "userLevel"];
  void clear_user_level() ;
  ::uint32_t user_level() const;
  void set_user_level(::uint32_t value);

  private:
  ::uint32_t _internal_user_level() const;
  void _internal_set_user_level(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      93, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_email_;
    ::google::protobuf::internal::ArenaStringPtr user_name_;
    ::google::protobuf::internal::ArenaStringPtr user_full_name_;
    ::google::protobuf::internal::ArenaStringPtr last_login_;
    ::google::protobuf::internal::ArenaStringPtr role_;
    ::uint64_t id_;
    ::uint64_t company_id_;
    ::uint64_t user_group_id_;
    bool permission_overrides_;
    ::uint32_t user_level_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class TenantLink final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.TenantLink) */ {
 public:
  inline TenantLink() : TenantLink(nullptr) {}
  ~TenantLink() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TenantLink* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TenantLink));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TenantLink(
      ::google::protobuf::internal::ConstantInitialized);

  inline TenantLink(const TenantLink& from) : TenantLink(nullptr, from) {}
  inline TenantLink(TenantLink&& from) noexcept
      : TenantLink(nullptr, std::move(from)) {}
  inline TenantLink& operator=(const TenantLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline TenantLink& operator=(TenantLink&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TenantLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const TenantLink* internal_default_instance() {
    return reinterpret_cast<const TenantLink*>(
        &_TenantLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TenantLink& a, TenantLink& b) { a.Swap(&b); }
  inline void Swap(TenantLink* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TenantLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TenantLink* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TenantLink>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TenantLink& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TenantLink& from) { TenantLink::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TenantLink* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.TenantLink"; }

 protected:
  explicit TenantLink(::google::protobuf::Arena* arena);
  TenantLink(::google::protobuf::Arena* arena, const TenantLink& from);
  TenantLink(::google::protobuf::Arena* arena, TenantLink&& from) noexcept
      : TenantLink(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kPivotTemplateIdFieldNumber = 2,
    kPivotUserGroupIdFieldNumber = 3,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 pivot_template_id = 2 [json_name = "pivotTemplateId"];
  void clear_pivot_template_id() ;
  ::uint64_t pivot_template_id() const;
  void set_pivot_template_id(::uint64_t value);

  private:
  ::uint64_t _internal_pivot_template_id() const;
  void _internal_set_pivot_template_id(::uint64_t value);

  public:
  // uint64 pivot_user_group_id = 3 [json_name = "pivotUserGroupId"];
  void clear_pivot_user_group_id() ;
  ::uint64_t pivot_user_group_id() const;
  void set_pivot_user_group_id(::uint64_t value);

  private:
  ::uint64_t _internal_pivot_user_group_id() const;
  void _internal_set_pivot_user_group_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.TenantLink)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TenantLink& from_msg);
    ::uint64_t id_;
    ::uint64_t pivot_template_id_;
    ::uint64_t pivot_user_group_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class NotificationChannel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.NotificationChannel) */ {
 public:
  inline NotificationChannel() : NotificationChannel(nullptr) {}
  ~NotificationChannel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NotificationChannel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NotificationChannel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotificationChannel(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotificationChannel(const NotificationChannel& from) : NotificationChannel(nullptr, from) {}
  inline NotificationChannel(NotificationChannel&& from) noexcept
      : NotificationChannel(nullptr, std::move(from)) {}
  inline NotificationChannel& operator=(const NotificationChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationChannel& operator=(NotificationChannel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotificationChannel* internal_default_instance() {
    return reinterpret_cast<const NotificationChannel*>(
        &_NotificationChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(NotificationChannel& a, NotificationChannel& b) { a.Swap(&b); }
  inline void Swap(NotificationChannel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationChannel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NotificationChannel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotificationChannel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotificationChannel& from) { NotificationChannel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NotificationChannel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.NotificationChannel"; }

 protected:
  explicit NotificationChannel(::google::protobuf::Arena* arena);
  NotificationChannel(::google::protobuf::Arena* arena, const NotificationChannel& from);
  NotificationChannel(::google::protobuf::Arena* arena, NotificationChannel&& from) noexcept
      : NotificationChannel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.NotificationChannel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NotificationChannel& from_msg);
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Mitigation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Mitigation) */ {
 public:
  inline Mitigation() : Mitigation(nullptr) {}
  ~Mitigation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Mitigation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Mitigation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Mitigation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Mitigation(const Mitigation& from) : Mitigation(nullptr, from) {}
  inline Mitigation(Mitigation&& from) noexcept
      : Mitigation(nullptr, std::move(from)) {}
  inline Mitigation& operator=(const Mitigation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mitigation& operator=(Mitigation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mitigation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mitigation* internal_default_instance() {
    return reinterpret_cast<const Mitigation*>(
        &_Mitigation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Mitigation& a, Mitigation& b) { a.Swap(&b); }
  inline void Swap(Mitigation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mitigation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mitigation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Mitigation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mitigation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Mitigation& from) { Mitigation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Mitigation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Mitigation"; }

 protected:
  explicit Mitigation(::google::protobuf::Arena* arena);
  Mitigation(::google::protobuf::Arena* arena, const Mitigation& from);
  Mitigation(::google::protobuf::Arena* arena, Mitigation&& from) noexcept
      : Mitigation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kMitigationApplyTypeFieldNumber = 6,
    kMitigationClearTypeFieldNumber = 7,
    kCdateFieldNumber = 11,
    kEdateFieldNumber = 12,
    kCompanyIdFieldNumber = 2,
    kPairingIdFieldNumber = 3,
    kThresholdIdFieldNumber = 4,
    kIsMethodOverridableFieldNumber = 5,
    kIsPlatformOverridableFieldNumber = 10,
    kMitigationApplyTimerFieldNumber = 8,
    kIdFieldNumber = 13,
    kMitigationClearTimerFieldNumber = 9,
  };
  // string status = 1 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string mitigation_apply_type = 6 [json_name = "mitigationApplyType"];
  void clear_mitigation_apply_type() ;
  const std::string& mitigation_apply_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mitigation_apply_type(Arg_&& arg, Args_... args);
  std::string* mutable_mitigation_apply_type();
  PROTOBUF_NODISCARD std::string* release_mitigation_apply_type();
  void set_allocated_mitigation_apply_type(std::string* value);

  private:
  const std::string& _internal_mitigation_apply_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mitigation_apply_type(
      const std::string& value);
  std::string* _internal_mutable_mitigation_apply_type();

  public:
  // string mitigation_clear_type = 7 [json_name = "mitigationClearType"];
  void clear_mitigation_clear_type() ;
  const std::string& mitigation_clear_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mitigation_clear_type(Arg_&& arg, Args_... args);
  std::string* mutable_mitigation_clear_type();
  PROTOBUF_NODISCARD std::string* release_mitigation_clear_type();
  void set_allocated_mitigation_clear_type(std::string* value);

  private:
  const std::string& _internal_mitigation_clear_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mitigation_clear_type(
      const std::string& value);
  std::string* _internal_mutable_mitigation_clear_type();

  public:
  // string cdate = 11 [json_name = "cdate"];
  void clear_cdate() ;
  const std::string& cdate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cdate(Arg_&& arg, Args_... args);
  std::string* mutable_cdate();
  PROTOBUF_NODISCARD std::string* release_cdate();
  void set_allocated_cdate(std::string* value);

  private:
  const std::string& _internal_cdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cdate(
      const std::string& value);
  std::string* _internal_mutable_cdate();

  public:
  // string edate = 12 [json_name = "edate"];
  void clear_edate() ;
  const std::string& edate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_edate(Arg_&& arg, Args_... args);
  std::string* mutable_edate();
  PROTOBUF_NODISCARD std::string* release_edate();
  void set_allocated_edate(std::string* value);

  private:
  const std::string& _internal_edate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edate(
      const std::string& value);
  std::string* _internal_mutable_edate();

  public:
  // uint64 company_id = 2 [json_name = "companyId"];
  void clear_company_id() ;
  ::uint64_t company_id() const;
  void set_company_id(::uint64_t value);

  private:
  ::uint64_t _internal_company_id() const;
  void _internal_set_company_id(::uint64_t value);

  public:
  // uint64 pairing_id = 3 [json_name = "pairingId"];
  void clear_pairing_id() ;
  ::uint64_t pairing_id() const;
  void set_pairing_id(::uint64_t value);

  private:
  ::uint64_t _internal_pairing_id() const;
  void _internal_set_pairing_id(::uint64_t value);

  public:
  // uint64 threshold_id = 4 [json_name = "thresholdId"];
  void clear_threshold_id() ;
  ::uint64_t threshold_id() const;
  void set_threshold_id(::uint64_t value);

  private:
  ::uint64_t _internal_threshold_id() const;
  void _internal_set_threshold_id(::uint64_t value);

  public:
  // bool is_method_overridable = 5 [json_name = "isMethodOverridable"];
  void clear_is_method_overridable() ;
  bool is_method_overridable() const;
  void set_is_method_overridable(bool value);

  private:
  bool _internal_is_method_overridable() const;
  void _internal_set_is_method_overridable(bool value);

  public:
  // bool is_platform_overridable = 10 [json_name = "isPlatformOverridable"];
  void clear_is_platform_overridable() ;
  bool is_platform_overridable() const;
  void set_is_platform_overridable(bool value);

  private:
  bool _internal_is_platform_overridable() const;
  void _internal_set_is_platform_overridable(bool value);

  public:
  // uint32 mitigation_apply_timer = 8 [json_name = "mitigationApplyTimer"];
  void clear_mitigation_apply_timer() ;
  ::uint32_t mitigation_apply_timer() const;
  void set_mitigation_apply_timer(::uint32_t value);

  private:
  ::uint32_t _internal_mitigation_apply_timer() const;
  void _internal_set_mitigation_apply_timer(::uint32_t value);

  public:
  // uint64 id = 13 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint32 mitigation_clear_timer = 9 [json_name = "mitigationClearTimer"];
  void clear_mitigation_clear_timer() ;
  ::uint32_t mitigation_clear_timer() const;
  void set_mitigation_clear_timer(::uint32_t value);

  private:
  ::uint32_t _internal_mitigation_clear_timer() const;
  void _internal_set_mitigation_clear_timer(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Mitigation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 0,
      110, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Mitigation& from_msg);
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr mitigation_apply_type_;
    ::google::protobuf::internal::ArenaStringPtr mitigation_clear_type_;
    ::google::protobuf::internal::ArenaStringPtr cdate_;
    ::google::protobuf::internal::ArenaStringPtr edate_;
    ::uint64_t company_id_;
    ::uint64_t pairing_id_;
    ::uint64_t threshold_id_;
    bool is_method_overridable_;
    bool is_platform_overridable_;
    ::uint32_t mitigation_apply_timer_;
    ::uint64_t id_;
    ::uint32_t mitigation_clear_timer_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class ListTenantRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.ListTenantRequest) */ {
 public:
  inline ListTenantRequest() : ListTenantRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListTenantRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListTenantRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListTenantRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListTenantRequest(const ListTenantRequest& from) : ListTenantRequest(nullptr, from) {}
  inline ListTenantRequest(ListTenantRequest&& from) noexcept
      : ListTenantRequest(nullptr, std::move(from)) {}
  inline ListTenantRequest& operator=(const ListTenantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTenantRequest& operator=(ListTenantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTenantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTenantRequest* internal_default_instance() {
    return reinterpret_cast<const ListTenantRequest*>(
        &_ListTenantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ListTenantRequest& a, ListTenantRequest& b) { a.Swap(&b); }
  inline void Swap(ListTenantRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTenantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTenantRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ListTenantRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListTenantRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListTenantRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.ListTenantRequest"; }

 protected:
  explicit ListTenantRequest(::google::protobuf::Arena* arena);
  ListTenantRequest(::google::protobuf::Arena* arena, const ListTenantRequest& from);
  ListTenantRequest(::google::protobuf::Arena* arena, ListTenantRequest&& from) noexcept
      : ListTenantRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.ListTenantRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListTenantRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class ListPackageRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.ListPackageRequest) */ {
 public:
  inline ListPackageRequest() : ListPackageRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListPackageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListPackageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListPackageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListPackageRequest(const ListPackageRequest& from) : ListPackageRequest(nullptr, from) {}
  inline ListPackageRequest(ListPackageRequest&& from) noexcept
      : ListPackageRequest(nullptr, std::move(from)) {}
  inline ListPackageRequest& operator=(const ListPackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPackageRequest& operator=(ListPackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPackageRequest* internal_default_instance() {
    return reinterpret_cast<const ListPackageRequest*>(
        &_ListPackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ListPackageRequest& a, ListPackageRequest& b) { a.Swap(&b); }
  inline void Swap(ListPackageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPackageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPackageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ListPackageRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListPackageRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListPackageRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.ListPackageRequest"; }

 protected:
  explicit ListPackageRequest(::google::protobuf::Arena* arena);
  ListPackageRequest(::google::protobuf::Arena* arena, const ListPackageRequest& from);
  ListPackageRequest(::google::protobuf::Arena* arena, ListPackageRequest&& from) noexcept
      : ListPackageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.ListPackageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListPackageRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class GetTenantRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.GetTenantRequest) */ {
 public:
  inline GetTenantRequest() : GetTenantRequest(nullptr) {}
  ~GetTenantRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTenantRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTenantRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTenantRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTenantRequest(const GetTenantRequest& from) : GetTenantRequest(nullptr, from) {}
  inline GetTenantRequest(GetTenantRequest&& from) noexcept
      : GetTenantRequest(nullptr, std::move(from)) {}
  inline GetTenantRequest& operator=(const GetTenantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTenantRequest& operator=(GetTenantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTenantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTenantRequest* internal_default_instance() {
    return reinterpret_cast<const GetTenantRequest*>(
        &_GetTenantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(GetTenantRequest& a, GetTenantRequest& b) { a.Swap(&b); }
  inline void Swap(GetTenantRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTenantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTenantRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTenantRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTenantRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTenantRequest& from) { GetTenantRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTenantRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.GetTenantRequest"; }

 protected:
  explicit GetTenantRequest(::google::protobuf::Arena* arena);
  GetTenantRequest(::google::protobuf::Arena* arena, const GetTenantRequest& from);
  GetTenantRequest(::google::protobuf::Arena* arena, GetTenantRequest&& from) noexcept
      : GetTenantRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.GetTenantRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTenantRequest& from_msg);
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class GetPackageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.GetPackageRequest) */ {
 public:
  inline GetPackageRequest() : GetPackageRequest(nullptr) {}
  ~GetPackageRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPackageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPackageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPackageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPackageRequest(const GetPackageRequest& from) : GetPackageRequest(nullptr, from) {}
  inline GetPackageRequest(GetPackageRequest&& from) noexcept
      : GetPackageRequest(nullptr, std::move(from)) {}
  inline GetPackageRequest& operator=(const GetPackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPackageRequest& operator=(GetPackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPackageRequest* internal_default_instance() {
    return reinterpret_cast<const GetPackageRequest*>(
        &_GetPackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(GetPackageRequest& a, GetPackageRequest& b) { a.Swap(&b); }
  inline void Swap(GetPackageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPackageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPackageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPackageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPackageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPackageRequest& from) { GetPackageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPackageRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.GetPackageRequest"; }

 protected:
  explicit GetPackageRequest(::google::protobuf::Arena* arena);
  GetPackageRequest(::google::protobuf::Arena* arena, const GetPackageRequest& from);
  GetPackageRequest(::google::protobuf::Arena* arena, GetPackageRequest&& from) noexcept
      : GetPackageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.GetPackageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPackageRequest& from_msg);
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class FilterField final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.FilterField) */ {
 public:
  inline FilterField() : FilterField(nullptr) {}
  ~FilterField() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FilterField* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FilterField));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FilterField(
      ::google::protobuf::internal::ConstantInitialized);

  inline FilterField(const FilterField& from) : FilterField(nullptr, from) {}
  inline FilterField(FilterField&& from) noexcept
      : FilterField(nullptr, std::move(from)) {}
  inline FilterField& operator=(const FilterField& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterField& operator=(FilterField&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterField& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterField* internal_default_instance() {
    return reinterpret_cast<const FilterField*>(
        &_FilterField_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(FilterField& a, FilterField& b) { a.Swap(&b); }
  inline void Swap(FilterField* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterField* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FilterField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FilterField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FilterField& from) { FilterField::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FilterField* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.FilterField"; }

 protected:
  explicit FilterField(::google::protobuf::Arena* arena);
  FilterField(::google::protobuf::Arena* arena, const FilterField& from);
  FilterField(::google::protobuf::Arena* arena, FilterField&& from) noexcept
      : FilterField(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilterFieldFieldNumber = 1,
    kOperatorFieldNumber = 2,
    kFilterValueFieldNumber = 3,
  };
  // string filter_field = 1 [json_name = "filterField"];
  void clear_filter_field() ;
  const std::string& filter_field() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter_field(Arg_&& arg, Args_... args);
  std::string* mutable_filter_field();
  PROTOBUF_NODISCARD std::string* release_filter_field();
  void set_allocated_filter_field(std::string* value);

  private:
  const std::string& _internal_filter_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_field(
      const std::string& value);
  std::string* _internal_mutable_filter_field();

  public:
  // string operator = 2 [json_name = "operator"];
  void clear_operator_() ;
  const std::string& operator_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_(Arg_&& arg, Args_... args);
  std::string* mutable_operator_();
  PROTOBUF_NODISCARD std::string* release_operator_();
  void set_allocated_operator_(std::string* value);

  private:
  const std::string& _internal_operator_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_(
      const std::string& value);
  std::string* _internal_mutable_operator_();

  public:
  // string filter_value = 3 [json_name = "filterValue"];
  void clear_filter_value() ;
  const std::string& filter_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter_value(Arg_&& arg, Args_... args);
  std::string* mutable_filter_value();
  PROTOBUF_NODISCARD std::string* release_filter_value();
  void set_allocated_filter_value(std::string* value);

  private:
  const std::string& _internal_filter_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_value(
      const std::string& value);
  std::string* _internal_mutable_filter_value();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.FilterField)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      77, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FilterField& from_msg);
    ::google::protobuf::internal::ArenaStringPtr filter_field_;
    ::google::protobuf::internal::ArenaStringPtr operator__;
    ::google::protobuf::internal::ArenaStringPtr filter_value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Device final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Device* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Device));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Device(
      ::google::protobuf::internal::ConstantInitialized);

  inline Device(const Device& from) : Device(nullptr, from) {}
  inline Device(Device&& from) noexcept
      : Device(nullptr, std::move(from)) {}
  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
        &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Device& a, Device& b) { a.Swap(&b); }
  inline void Swap(Device* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Device* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Device>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Device& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Device& from) { Device::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Device* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Device"; }

 protected:
  explicit Device(::google::protobuf::Arena* arena);
  Device(::google::protobuf::Arena* arena, const Device& from);
  Device(::google::protobuf::Arena* arena, Device&& from) noexcept
      : Device(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceTypesFieldNumber = 2,
    kDeviceLabelsFieldNumber = 3,
    kDeviceSitesFieldNumber = 4,
    kDeviceNameFieldNumber = 5,
    kAllDevicesFieldNumber = 1,
  };
  // repeated string device_types = 2 [json_name = "deviceTypes"];
  int device_types_size() const;
  private:
  int _internal_device_types_size() const;

  public:
  void clear_device_types() ;
  const std::string& device_types(int index) const;
  std::string* mutable_device_types(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_types(int index, Arg_&& value, Args_... args);
  std::string* add_device_types();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_device_types(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& device_types() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_device_types();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_device_types() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_device_types();

  public:
  // repeated uint32 device_labels = 3 [json_name = "deviceLabels"];
  int device_labels_size() const;
  private:
  int _internal_device_labels_size() const;

  public:
  void clear_device_labels() ;
  ::uint32_t device_labels(int index) const;
  void set_device_labels(int index, ::uint32_t value);
  void add_device_labels(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& device_labels() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_device_labels();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_device_labels() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_device_labels();

  public:
  // repeated uint32 device_sites = 4 [json_name = "deviceSites"];
  int device_sites_size() const;
  private:
  int _internal_device_sites_size() const;

  public:
  void clear_device_sites() ;
  ::uint32_t device_sites(int index) const;
  void set_device_sites(int index, ::uint32_t value);
  void add_device_sites(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& device_sites() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_device_sites();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_device_sites() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_device_sites();

  public:
  // repeated string device_name = 5 [json_name = "deviceName"];
  int device_name_size() const;
  private:
  int _internal_device_name_size() const;

  public:
  void clear_device_name() ;
  const std::string& device_name(int index) const;
  std::string* mutable_device_name(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_name(int index, Arg_&& value, Args_... args);
  std::string* add_device_name();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_device_name(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& device_name() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_device_name();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_device_name() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_device_name();

  public:
  // bool all_devices = 1 [json_name = "allDevices"];
  void clear_all_devices() ;
  bool all_devices() const;
  void set_all_devices(bool value);

  private:
  bool _internal_all_devices() const;
  void _internal_set_all_devices(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Device)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      63, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Device& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> device_types_;
    ::google::protobuf::RepeatedField<::uint32_t> device_labels_;
    ::google::protobuf::internal::CachedSize _device_labels_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> device_sites_;
    ::google::protobuf::internal::CachedSize _device_sites_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> device_name_;
    bool all_devices_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class DeleteTenantResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.DeleteTenantResponse) */ {
 public:
  inline DeleteTenantResponse() : DeleteTenantResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteTenantResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteTenantResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteTenantResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteTenantResponse(const DeleteTenantResponse& from) : DeleteTenantResponse(nullptr, from) {}
  inline DeleteTenantResponse(DeleteTenantResponse&& from) noexcept
      : DeleteTenantResponse(nullptr, std::move(from)) {}
  inline DeleteTenantResponse& operator=(const DeleteTenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTenantResponse& operator=(DeleteTenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTenantResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTenantResponse*>(
        &_DeleteTenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(DeleteTenantResponse& a, DeleteTenantResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteTenantResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTenantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTenantResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteTenantResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteTenantResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteTenantResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.DeleteTenantResponse"; }

 protected:
  explicit DeleteTenantResponse(::google::protobuf::Arena* arena);
  DeleteTenantResponse(::google::protobuf::Arena* arena, const DeleteTenantResponse& from);
  DeleteTenantResponse(::google::protobuf::Arena* arena, DeleteTenantResponse&& from) noexcept
      : DeleteTenantResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.DeleteTenantResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteTenantResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class DeleteTenantRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.DeleteTenantRequest) */ {
 public:
  inline DeleteTenantRequest() : DeleteTenantRequest(nullptr) {}
  ~DeleteTenantRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteTenantRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteTenantRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteTenantRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteTenantRequest(const DeleteTenantRequest& from) : DeleteTenantRequest(nullptr, from) {}
  inline DeleteTenantRequest(DeleteTenantRequest&& from) noexcept
      : DeleteTenantRequest(nullptr, std::move(from)) {}
  inline DeleteTenantRequest& operator=(const DeleteTenantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTenantRequest& operator=(DeleteTenantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTenantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTenantRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTenantRequest*>(
        &_DeleteTenantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(DeleteTenantRequest& a, DeleteTenantRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteTenantRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTenantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTenantRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteTenantRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteTenantRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteTenantRequest& from) { DeleteTenantRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteTenantRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.DeleteTenantRequest"; }

 protected:
  explicit DeleteTenantRequest(::google::protobuf::Arena* arena);
  DeleteTenantRequest(::google::protobuf::Arena* arena, const DeleteTenantRequest& from);
  DeleteTenantRequest(::google::protobuf::Arena* arena, DeleteTenantRequest&& from) noexcept
      : DeleteTenantRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.DeleteTenantRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteTenantRequest& from_msg);
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class DeletePackageResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.DeletePackageResponse) */ {
 public:
  inline DeletePackageResponse() : DeletePackageResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePackageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePackageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePackageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeletePackageResponse(const DeletePackageResponse& from) : DeletePackageResponse(nullptr, from) {}
  inline DeletePackageResponse(DeletePackageResponse&& from) noexcept
      : DeletePackageResponse(nullptr, std::move(from)) {}
  inline DeletePackageResponse& operator=(const DeletePackageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePackageResponse& operator=(DeletePackageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePackageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePackageResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePackageResponse*>(
        &_DeletePackageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(DeletePackageResponse& a, DeletePackageResponse& b) { a.Swap(&b); }
  inline void Swap(DeletePackageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePackageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePackageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeletePackageResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeletePackageResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeletePackageResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.DeletePackageResponse"; }

 protected:
  explicit DeletePackageResponse(::google::protobuf::Arena* arena);
  DeletePackageResponse(::google::protobuf::Arena* arena, const DeletePackageResponse& from);
  DeletePackageResponse(::google::protobuf::Arena* arena, DeletePackageResponse&& from) noexcept
      : DeletePackageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.DeletePackageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeletePackageResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class DeletePackageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.DeletePackageRequest) */ {
 public:
  inline DeletePackageRequest() : DeletePackageRequest(nullptr) {}
  ~DeletePackageRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeletePackageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeletePackageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeletePackageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeletePackageRequest(const DeletePackageRequest& from) : DeletePackageRequest(nullptr, from) {}
  inline DeletePackageRequest(DeletePackageRequest&& from) noexcept
      : DeletePackageRequest(nullptr, std::move(from)) {}
  inline DeletePackageRequest& operator=(const DeletePackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePackageRequest& operator=(DeletePackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePackageRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePackageRequest*>(
        &_DeletePackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(DeletePackageRequest& a, DeletePackageRequest& b) { a.Swap(&b); }
  inline void Swap(DeletePackageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePackageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePackageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeletePackageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeletePackageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeletePackageRequest& from) { DeletePackageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeletePackageRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.DeletePackageRequest"; }

 protected:
  explicit DeletePackageRequest(::google::protobuf::Arena* arena);
  DeletePackageRequest(::google::protobuf::Arena* arena, const DeletePackageRequest& from);
  DeletePackageRequest(::google::protobuf::Arena* arena, DeletePackageRequest&& from) noexcept
      : DeletePackageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.DeletePackageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeletePackageRequest& from_msg);
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class CustomDimension final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.CustomDimension) */ {
 public:
  inline CustomDimension() : CustomDimension(nullptr) {}
  ~CustomDimension() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CustomDimension* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CustomDimension));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CustomDimension(
      ::google::protobuf::internal::ConstantInitialized);

  inline CustomDimension(const CustomDimension& from) : CustomDimension(nullptr, from) {}
  inline CustomDimension(CustomDimension&& from) noexcept
      : CustomDimension(nullptr, std::move(from)) {}
  inline CustomDimension& operator=(const CustomDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomDimension& operator=(CustomDimension&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomDimension* internal_default_instance() {
    return reinterpret_cast<const CustomDimension*>(
        &_CustomDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(CustomDimension& a, CustomDimension& b) { a.Swap(&b); }
  inline void Swap(CustomDimension* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomDimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomDimension* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CustomDimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomDimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CustomDimension& from) { CustomDimension::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CustomDimension* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.CustomDimension"; }

 protected:
  explicit CustomDimension(::google::protobuf::Arena* arena);
  CustomDimension(::google::protobuf::Arena* arena, const CustomDimension& from);
  CustomDimension(::google::protobuf::Arena* arena, CustomDimension&& from) noexcept
      : CustomDimension(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionFieldNumber = 1,
    kPopulatorFieldNumber = 2,
  };
  // string dimension = 1 [json_name = "dimension"];
  void clear_dimension() ;
  const std::string& dimension() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimension(Arg_&& arg, Args_... args);
  std::string* mutable_dimension();
  PROTOBUF_NODISCARD std::string* release_dimension();
  void set_allocated_dimension(std::string* value);

  private:
  const std::string& _internal_dimension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimension(
      const std::string& value);
  std::string* _internal_mutable_dimension();

  public:
  // string populator = 2 [json_name = "populator"];
  void clear_populator() ;
  const std::string& populator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_populator(Arg_&& arg, Args_... args);
  std::string* mutable_populator();
  PROTOBUF_NODISCARD std::string* release_populator();
  void set_allocated_populator(std::string* value);

  private:
  const std::string& _internal_populator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_populator(
      const std::string& value);
  std::string* _internal_mutable_populator();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.CustomDimension)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CustomDimension& from_msg);
    ::google::protobuf::internal::ArenaStringPtr dimension_;
    ::google::protobuf::internal::ArenaStringPtr populator_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Condition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Condition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Condition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Condition(
      ::google::protobuf::internal::ConstantInitialized);

  inline Condition(const Condition& from) : Condition(nullptr, from) {}
  inline Condition(Condition&& from) noexcept
      : Condition(nullptr, std::move(from)) {}
  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
        &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Condition& a, Condition& b) { a.Swap(&b); }
  inline void Swap(Condition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Condition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Condition& from) { Condition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Condition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Condition"; }

 protected:
  explicit Condition(::google::protobuf::Arena* arena);
  Condition(::google::protobuf::Arena* arena, const Condition& from);
  Condition(::google::protobuf::Arena* arena, Condition&& from) noexcept
      : Condition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kMetricFieldNumber = 3,
    kOperatorFieldNumber = 4,
    kValueTypeFieldNumber = 5,
    kValueSelectFieldNumber = 6,
    kValueFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string metric = 3 [json_name = "metric"];
  void clear_metric() ;
  const std::string& metric() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metric(Arg_&& arg, Args_... args);
  std::string* mutable_metric();
  PROTOBUF_NODISCARD std::string* release_metric();
  void set_allocated_metric(std::string* value);

  private:
  const std::string& _internal_metric() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric(
      const std::string& value);
  std::string* _internal_mutable_metric();

  public:
  // string operator = 4 [json_name = "operator"];
  void clear_operator_() ;
  const std::string& operator_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_(Arg_&& arg, Args_... args);
  std::string* mutable_operator_();
  PROTOBUF_NODISCARD std::string* release_operator_();
  void set_allocated_operator_(std::string* value);

  private:
  const std::string& _internal_operator_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_(
      const std::string& value);
  std::string* _internal_mutable_operator_();

  public:
  // string value_type = 5 [json_name = "valueType"];
  void clear_value_type() ;
  const std::string& value_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value_type(Arg_&& arg, Args_... args);
  std::string* mutable_value_type();
  PROTOBUF_NODISCARD std::string* release_value_type();
  void set_allocated_value_type(std::string* value);

  private:
  const std::string& _internal_value_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_type(
      const std::string& value);
  std::string* _internal_mutable_value_type();

  public:
  // string value_select = 6 [json_name = "valueSelect"];
  void clear_value_select() ;
  const std::string& value_select() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value_select(Arg_&& arg, Args_... args);
  std::string* mutable_value_select();
  PROTOBUF_NODISCARD std::string* release_value_select();
  void set_allocated_value_select(std::string* value);

  private:
  const std::string& _internal_value_select() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_select(
      const std::string& value);
  std::string* _internal_mutable_value_select();

  public:
  // uint32 value = 2 [json_name = "value"];
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Condition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      83, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Condition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr metric_;
    ::google::protobuf::internal::ArenaStringPtr operator__;
    ::google::protobuf::internal::ArenaStringPtr value_type_;
    ::google::protobuf::internal::ArenaStringPtr value_select_;
    ::uint32_t value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Asset_Report final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Asset.Report) */ {
 public:
  inline Asset_Report() : Asset_Report(nullptr) {}
  ~Asset_Report() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Asset_Report* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Asset_Report));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Asset_Report(
      ::google::protobuf::internal::ConstantInitialized);

  inline Asset_Report(const Asset_Report& from) : Asset_Report(nullptr, from) {}
  inline Asset_Report(Asset_Report&& from) noexcept
      : Asset_Report(nullptr, std::move(from)) {}
  inline Asset_Report& operator=(const Asset_Report& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset_Report& operator=(Asset_Report&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Asset_Report& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset_Report* internal_default_instance() {
    return reinterpret_cast<const Asset_Report*>(
        &_Asset_Report_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Asset_Report& a, Asset_Report& b) { a.Swap(&b); }
  inline void Swap(Asset_Report* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset_Report* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Asset_Report* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Asset_Report>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Asset_Report& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Asset_Report& from) { Asset_Report::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Asset_Report* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Asset.Report"; }

 protected:
  explicit Asset_Report(::google::protobuf::Arena* arena);
  Asset_Report(::google::protobuf::Arena* arena, const Asset_Report& from);
  Asset_Report(::google::protobuf::Arena* arena, Asset_Report&& from) noexcept
      : Asset_Report(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string type = 2 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Asset.Report)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Asset_Report& from_msg);
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Activate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Activate) */ {
 public:
  inline Activate() : Activate(nullptr) {}
  ~Activate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Activate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Activate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Activate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Activate(const Activate& from) : Activate(nullptr, from) {}
  inline Activate(Activate&& from) noexcept
      : Activate(nullptr, std::move(from)) {}
  inline Activate& operator=(const Activate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Activate& operator=(Activate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Activate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Activate* internal_default_instance() {
    return reinterpret_cast<const Activate*>(
        &_Activate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Activate& a, Activate& b) { a.Swap(&b); }
  inline void Swap(Activate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Activate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Activate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Activate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Activate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Activate& from) { Activate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Activate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Activate"; }

 protected:
  explicit Activate(::google::protobuf::Arena* arena);
  Activate(::google::protobuf::Arena* arena, const Activate& from);
  Activate(::google::protobuf::Arena* arena, Activate&& from) noexcept
      : Activate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperatorFieldNumber = 2,
    kTimeUnitFieldNumber = 3,
    kTimesFieldNumber = 1,
    kTimeWindowFieldNumber = 4,
    kGracePeriodFieldNumber = 5,
  };
  // string operator = 2 [json_name = "operator"];
  void clear_operator_() ;
  const std::string& operator_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_(Arg_&& arg, Args_... args);
  std::string* mutable_operator_();
  PROTOBUF_NODISCARD std::string* release_operator_();
  void set_allocated_operator_(std::string* value);

  private:
  const std::string& _internal_operator_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_(
      const std::string& value);
  std::string* _internal_mutable_operator_();

  public:
  // string time_unit = 3 [json_name = "timeUnit"];
  void clear_time_unit() ;
  const std::string& time_unit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_unit(Arg_&& arg, Args_... args);
  std::string* mutable_time_unit();
  PROTOBUF_NODISCARD std::string* release_time_unit();
  void set_allocated_time_unit(std::string* value);

  private:
  const std::string& _internal_time_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_unit(
      const std::string& value);
  std::string* _internal_mutable_time_unit();

  public:
  // uint32 times = 1 [json_name = "times"];
  void clear_times() ;
  ::uint32_t times() const;
  void set_times(::uint32_t value);

  private:
  ::uint32_t _internal_times() const;
  void _internal_set_times(::uint32_t value);

  public:
  // uint32 time_window = 4 [json_name = "timeWindow"];
  void clear_time_window() ;
  ::uint32_t time_window() const;
  void set_time_window(::uint32_t value);

  private:
  ::uint32_t _internal_time_window() const;
  void _internal_set_time_window(::uint32_t value);

  public:
  // uint32 grace_period = 5 [json_name = "gracePeriod"];
  void clear_grace_period() ;
  ::uint32_t grace_period() const;
  void set_grace_period(::uint32_t value);

  private:
  ::uint32_t _internal_grace_period() const;
  void _internal_set_grace_period(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Activate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      59, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Activate& from_msg);
    ::google::protobuf::internal::ArenaStringPtr operator__;
    ::google::protobuf::internal::ArenaStringPtr time_unit_;
    ::uint32_t times_;
    ::uint32_t time_window_;
    ::uint32_t grace_period_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Threshold final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Threshold) */ {
 public:
  inline Threshold() : Threshold(nullptr) {}
  ~Threshold() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Threshold* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Threshold));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Threshold(
      ::google::protobuf::internal::ConstantInitialized);

  inline Threshold(const Threshold& from) : Threshold(nullptr, from) {}
  inline Threshold(Threshold&& from) noexcept
      : Threshold(nullptr, std::move(from)) {}
  inline Threshold& operator=(const Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline Threshold& operator=(Threshold&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Threshold& default_instance() {
    return *internal_default_instance();
  }
  static inline const Threshold* internal_default_instance() {
    return reinterpret_cast<const Threshold*>(
        &_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Threshold& a, Threshold& b) { a.Swap(&b); }
  inline void Swap(Threshold* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Threshold* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Threshold* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Threshold>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Threshold& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Threshold& from) { Threshold::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Threshold* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Threshold"; }

 protected:
  explicit Threshold(::google::protobuf::Arena* arena);
  Threshold(::google::protobuf::Arena* arena, const Threshold& from);
  Threshold(::google::protobuf::Arena* arena, Threshold&& from) noexcept
      : Threshold(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConditionsFieldNumber = 4,
    kMitigationsFieldNumber = 5,
    kNotificationChannelsFieldNumber = 6,
    kSeverityFieldNumber = 3,
    kActivateFieldNumber = 2,
    kIdFieldNumber = 1,
    kThresholdAckRequiredFieldNumber = 7,
    kEnableTenantNotificationsFieldNumber = 8,
    kReceiveLandlordNotificationsFieldNumber = 9,
  };
  // repeated .kentik.mkp.v202102alpha1.Condition conditions = 4 [json_name = "conditions"];
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;

  public:
  void clear_conditions() ;
  ::kentik::mkp::v202102alpha1::Condition* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>* mutable_conditions();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>& _internal_conditions() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>* _internal_mutable_conditions();
  public:
  const ::kentik::mkp::v202102alpha1::Condition& conditions(int index) const;
  ::kentik::mkp::v202102alpha1::Condition* add_conditions();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>& conditions() const;
  // repeated .kentik.mkp.v202102alpha1.Mitigation mitigations = 5 [json_name = "mitigations"];
  int mitigations_size() const;
  private:
  int _internal_mitigations_size() const;

  public:
  void clear_mitigations() ;
  ::kentik::mkp::v202102alpha1::Mitigation* mutable_mitigations(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>* mutable_mitigations();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>& _internal_mitigations() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>* _internal_mutable_mitigations();
  public:
  const ::kentik::mkp::v202102alpha1::Mitigation& mitigations(int index) const;
  ::kentik::mkp::v202102alpha1::Mitigation* add_mitigations();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>& mitigations() const;
  // repeated .kentik.mkp.v202102alpha1.NotificationChannel notification_channels = 6 [json_name = "notificationChannels"];
  int notification_channels_size() const;
  private:
  int _internal_notification_channels_size() const;

  public:
  void clear_notification_channels() ;
  ::kentik::mkp::v202102alpha1::NotificationChannel* mutable_notification_channels(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>* mutable_notification_channels();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>& _internal_notification_channels() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>* _internal_mutable_notification_channels();
  public:
  const ::kentik::mkp::v202102alpha1::NotificationChannel& notification_channels(int index) const;
  ::kentik::mkp::v202102alpha1::NotificationChannel* add_notification_channels();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>& notification_channels() const;
  // string severity = 3 [json_name = "severity"];
  void clear_severity() ;
  const std::string& severity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_severity(Arg_&& arg, Args_... args);
  std::string* mutable_severity();
  PROTOBUF_NODISCARD std::string* release_severity();
  void set_allocated_severity(std::string* value);

  private:
  const std::string& _internal_severity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_severity(
      const std::string& value);
  std::string* _internal_mutable_severity();

  public:
  // .kentik.mkp.v202102alpha1.Activate activate = 2 [json_name = "activate"];
  bool has_activate() const;
  void clear_activate() ;
  const ::kentik::mkp::v202102alpha1::Activate& activate() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Activate* release_activate();
  ::kentik::mkp::v202102alpha1::Activate* mutable_activate();
  void set_allocated_activate(::kentik::mkp::v202102alpha1::Activate* value);
  void unsafe_arena_set_allocated_activate(::kentik::mkp::v202102alpha1::Activate* value);
  ::kentik::mkp::v202102alpha1::Activate* unsafe_arena_release_activate();

  private:
  const ::kentik::mkp::v202102alpha1::Activate& _internal_activate() const;
  ::kentik::mkp::v202102alpha1::Activate* _internal_mutable_activate();

  public:
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool threshold_ack_required = 7 [json_name = "thresholdAckRequired"];
  void clear_threshold_ack_required() ;
  bool threshold_ack_required() const;
  void set_threshold_ack_required(bool value);

  private:
  bool _internal_threshold_ack_required() const;
  void _internal_set_threshold_ack_required(bool value);

  public:
  // bool enable_tenant_notifications = 8 [json_name = "enableTenantNotifications"];
  void clear_enable_tenant_notifications() ;
  bool enable_tenant_notifications() const;
  void set_enable_tenant_notifications(bool value);

  private:
  bool _internal_enable_tenant_notifications() const;
  void _internal_set_enable_tenant_notifications(bool value);

  public:
  // bool receive_landlord_notifications = 9 [json_name = "receiveLandlordNotifications"];
  void clear_receive_landlord_notifications() ;
  bool receive_landlord_notifications() const;
  void set_receive_landlord_notifications(bool value);

  private:
  bool _internal_receive_landlord_notifications() const;
  void _internal_set_receive_landlord_notifications(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Threshold)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 4,
      59, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Threshold& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Condition > conditions_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Mitigation > mitigations_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::NotificationChannel > notification_channels_;
    ::google::protobuf::internal::ArenaStringPtr severity_;
    ::kentik::mkp::v202102alpha1::Activate* activate_;
    ::uint64_t id_;
    bool threshold_ack_required_;
    bool enable_tenant_notifications_;
    bool receive_landlord_notifications_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Filter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Filter* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Filter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Filter(
      ::google::protobuf::internal::ConstantInitialized);

  inline Filter(const Filter& from) : Filter(nullptr, from) {}
  inline Filter(Filter&& from) noexcept
      : Filter(nullptr, std::move(from)) {}
  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
        &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Filter& a, Filter& b) { a.Swap(&b); }
  inline void Swap(Filter* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Filter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Filter& from) { Filter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Filter* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Filter"; }

 protected:
  explicit Filter(::google::protobuf::Arena* arena);
  Filter(::google::protobuf::Arena* arena, const Filter& from);
  Filter(::google::protobuf::Arena* arena, Filter&& from) noexcept
      : Filter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSavedFiltersFieldNumber = 6,
    kFiltersFieldNumber = 7,
    kFilterGroupsFieldNumber = 8,
    kMetricFieldNumber = 9,
    kNameFieldNumber = 1,
    kConnectorFieldNumber = 3,
    kAutoAddedFieldNumber = 5,
    kNamedFieldNumber = 2,
    kNotFieldNumber = 4,
  };
  // repeated string saved_filters = 6 [json_name = "savedFilters"];
  int saved_filters_size() const;
  private:
  int _internal_saved_filters_size() const;

  public:
  void clear_saved_filters() ;
  const std::string& saved_filters(int index) const;
  std::string* mutable_saved_filters(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_saved_filters(int index, Arg_&& value, Args_... args);
  std::string* add_saved_filters();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_saved_filters(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& saved_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_saved_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_saved_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_saved_filters();

  public:
  // repeated .kentik.mkp.v202102alpha1.FilterField filters = 7 [json_name = "filters"];
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  ::kentik::mkp::v202102alpha1::FilterField* mutable_filters(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>* mutable_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>* _internal_mutable_filters();
  public:
  const ::kentik::mkp::v202102alpha1::FilterField& filters(int index) const;
  ::kentik::mkp::v202102alpha1::FilterField* add_filters();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>& filters() const;
  // repeated .kentik.mkp.v202102alpha1.Filter filter_groups = 8 [json_name = "filterGroups"];
  int filter_groups_size() const;
  private:
  int _internal_filter_groups_size() const;

  public:
  void clear_filter_groups() ;
  ::kentik::mkp::v202102alpha1::Filter* mutable_filter_groups(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>* mutable_filter_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>& _internal_filter_groups() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>* _internal_mutable_filter_groups();
  public:
  const ::kentik::mkp::v202102alpha1::Filter& filter_groups(int index) const;
  ::kentik::mkp::v202102alpha1::Filter* add_filter_groups();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>& filter_groups() const;
  // repeated string metric = 9 [json_name = "metric"];
  int metric_size() const;
  private:
  int _internal_metric_size() const;

  public:
  void clear_metric() ;
  const std::string& metric(int index) const;
  std::string* mutable_metric(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metric(int index, Arg_&& value, Args_... args);
  std::string* add_metric();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_metric(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& metric() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_metric();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_metric() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_metric();

  public:
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string connector = 3 [json_name = "connector"];
  void clear_connector() ;
  const std::string& connector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connector(Arg_&& arg, Args_... args);
  std::string* mutable_connector();
  PROTOBUF_NODISCARD std::string* release_connector();
  void set_allocated_connector(std::string* value);

  private:
  const std::string& _internal_connector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connector(
      const std::string& value);
  std::string* _internal_mutable_connector();

  public:
  // string auto_added = 5 [json_name = "autoAdded"];
  void clear_auto_added() ;
  const std::string& auto_added() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auto_added(Arg_&& arg, Args_... args);
  std::string* mutable_auto_added();
  PROTOBUF_NODISCARD std::string* release_auto_added();
  void set_allocated_auto_added(std::string* value);

  private:
  const std::string& _internal_auto_added() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auto_added(
      const std::string& value);
  std::string* _internal_mutable_auto_added();

  public:
  // bool named = 2 [json_name = "named"];
  void clear_named() ;
  bool named() const;
  void set_named(bool value);

  private:
  bool _internal_named() const;
  void _internal_set_named(bool value);

  public:
  // bool not = 4 [json_name = "not"];
  void clear_not_() ;
  bool not_() const;
  void set_not_(bool value);

  private:
  bool _internal_not_() const;
  void _internal_set_not_(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Filter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      90, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Filter& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> saved_filters_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::FilterField > filters_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Filter > filter_groups_;
    ::google::protobuf::RepeatedPtrField<std::string> metric_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr connector_;
    ::google::protobuf::internal::ArenaStringPtr auto_added_;
    bool named_;
    bool not__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Asset final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Asset) */ {
 public:
  inline Asset() : Asset(nullptr) {}
  ~Asset() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Asset* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Asset));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Asset(
      ::google::protobuf::internal::ConstantInitialized);

  inline Asset(const Asset& from) : Asset(nullptr, from) {}
  inline Asset(Asset&& from) noexcept
      : Asset(nullptr, std::move(from)) {}
  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset& operator=(Asset&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Asset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
        &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Asset& a, Asset& b) { a.Swap(&b); }
  inline void Swap(Asset* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Asset* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Asset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Asset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Asset& from) { Asset::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Asset* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Asset"; }

 protected:
  explicit Asset(::google::protobuf::Arena* arena);
  Asset(::google::protobuf::Arena* arena, const Asset& from);
  Asset(::google::protobuf::Arena* arena, Asset&& from) noexcept
      : Asset(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Report = Asset_Report;

  // accessors -------------------------------------------------------
  enum : int {
    kReportsFieldNumber = 1,
    kDefaultReportFieldNumber = 2,
  };
  // repeated .kentik.mkp.v202102alpha1.Asset.Report reports = 1 [json_name = "reports"];
  int reports_size() const;
  private:
  int _internal_reports_size() const;

  public:
  void clear_reports() ;
  ::kentik::mkp::v202102alpha1::Asset_Report* mutable_reports(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>* mutable_reports();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>& _internal_reports() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>* _internal_mutable_reports();
  public:
  const ::kentik::mkp::v202102alpha1::Asset_Report& reports(int index) const;
  ::kentik::mkp::v202102alpha1::Asset_Report* add_reports();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>& reports() const;
  // .kentik.mkp.v202102alpha1.Asset.Report default_report = 2 [json_name = "defaultReport"];
  bool has_default_report() const;
  void clear_default_report() ;
  const ::kentik::mkp::v202102alpha1::Asset_Report& default_report() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Asset_Report* release_default_report();
  ::kentik::mkp::v202102alpha1::Asset_Report* mutable_default_report();
  void set_allocated_default_report(::kentik::mkp::v202102alpha1::Asset_Report* value);
  void unsafe_arena_set_allocated_default_report(::kentik::mkp::v202102alpha1::Asset_Report* value);
  ::kentik::mkp::v202102alpha1::Asset_Report* unsafe_arena_release_default_report();

  private:
  const ::kentik::mkp::v202102alpha1::Asset_Report& _internal_default_report() const;
  ::kentik::mkp::v202102alpha1::Asset_Report* _internal_mutable_default_report();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Asset)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Asset& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Asset_Report > reports_;
    ::kentik::mkp::v202102alpha1::Asset_Report* default_report_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Alert final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Alert) */ {
 public:
  inline Alert() : Alert(nullptr) {}
  ~Alert() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Alert* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Alert));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Alert(
      ::google::protobuf::internal::ConstantInitialized);

  inline Alert(const Alert& from) : Alert(nullptr, from) {}
  inline Alert(Alert&& from) noexcept
      : Alert(nullptr, std::move(from)) {}
  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alert& operator=(Alert&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alert& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
        &_Alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Alert& a, Alert& b) { a.Swap(&b); }
  inline void Swap(Alert* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alert* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alert* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Alert>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Alert& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Alert& from) { Alert::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Alert* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Alert"; }

 protected:
  explicit Alert(::google::protobuf::Arena* arena);
  Alert(::google::protobuf::Arena* arena, const Alert& from);
  Alert(::google::protobuf::Arena* arena, Alert&& from) noexcept
      : Alert(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kThresholdsFieldNumber = 3,
    kSecondaryMetricsFieldNumber = 5,
    kPrimaryMetricFieldNumber = 4,
    kSubpolicyIdFieldNumber = 7,
    kPolicyIdFieldNumber = 2,
    kSavedFieldNumber = 1,
    kIsTemplateFieldNumber = 6,
  };
  // repeated .kentik.mkp.v202102alpha1.Threshold thresholds = 3 [json_name = "thresholds"];
  int thresholds_size() const;
  private:
  int _internal_thresholds_size() const;

  public:
  void clear_thresholds() ;
  ::kentik::mkp::v202102alpha1::Threshold* mutable_thresholds(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>* mutable_thresholds();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>& _internal_thresholds() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>* _internal_mutable_thresholds();
  public:
  const ::kentik::mkp::v202102alpha1::Threshold& thresholds(int index) const;
  ::kentik::mkp::v202102alpha1::Threshold* add_thresholds();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>& thresholds() const;
  // repeated string secondary_metrics = 5 [json_name = "secondaryMetrics"];
  int secondary_metrics_size() const;
  private:
  int _internal_secondary_metrics_size() const;

  public:
  void clear_secondary_metrics() ;
  const std::string& secondary_metrics(int index) const;
  std::string* mutable_secondary_metrics(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secondary_metrics(int index, Arg_&& value, Args_... args);
  std::string* add_secondary_metrics();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_secondary_metrics(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& secondary_metrics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_secondary_metrics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_secondary_metrics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_secondary_metrics();

  public:
  // string primary_metric = 4 [json_name = "primaryMetric"];
  void clear_primary_metric() ;
  const std::string& primary_metric() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_metric(Arg_&& arg, Args_... args);
  std::string* mutable_primary_metric();
  PROTOBUF_NODISCARD std::string* release_primary_metric();
  void set_allocated_primary_metric(std::string* value);

  private:
  const std::string& _internal_primary_metric() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_metric(
      const std::string& value);
  std::string* _internal_mutable_primary_metric();

  public:
  // string subpolicy_id = 7 [json_name = "subpolicyId"];
  void clear_subpolicy_id() ;
  const std::string& subpolicy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subpolicy_id(Arg_&& arg, Args_... args);
  std::string* mutable_subpolicy_id();
  PROTOBUF_NODISCARD std::string* release_subpolicy_id();
  void set_allocated_subpolicy_id(std::string* value);

  private:
  const std::string& _internal_subpolicy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subpolicy_id(
      const std::string& value);
  std::string* _internal_mutable_subpolicy_id();

  public:
  // uint64 policy_id = 2 [json_name = "policyId"];
  void clear_policy_id() ;
  ::uint64_t policy_id() const;
  void set_policy_id(::uint64_t value);

  private:
  ::uint64_t _internal_policy_id() const;
  void _internal_set_policy_id(::uint64_t value);

  public:
  // bool saved = 1 [json_name = "saved"];
  void clear_saved() ;
  bool saved() const;
  void set_saved(bool value);

  private:
  bool _internal_saved() const;
  void _internal_set_saved(bool value);

  public:
  // bool is_template = 6 [json_name = "isTemplate"];
  void clear_is_template() ;
  bool is_template() const;
  void set_is_template(bool value);

  private:
  bool _internal_is_template() const;
  void _internal_set_is_template(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Alert)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      82, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Alert& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Threshold > thresholds_;
    ::google::protobuf::RepeatedPtrField<std::string> secondary_metrics_;
    ::google::protobuf::internal::ArenaStringPtr primary_metric_;
    ::google::protobuf::internal::ArenaStringPtr subpolicy_id_;
    ::uint64_t policy_id_;
    bool saved_;
    bool is_template_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Package final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Package* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Package));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Package(
      ::google::protobuf::internal::ConstantInitialized);

  inline Package(const Package& from) : Package(nullptr, from) {}
  inline Package(Package&& from) noexcept
      : Package(nullptr, std::move(from)) {}
  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
        &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Package& a, Package& b) { a.Swap(&b); }
  inline void Swap(Package* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Package* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Package>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Package& from) { Package::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Package* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Package"; }

 protected:
  explicit Package(::google::protobuf::Arena* arena);
  Package(::google::protobuf::Arena* arena, const Package& from);
  Package(::google::protobuf::Arena* arena, Package&& from) noexcept
      : Package(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlertsFieldNumber = 7,
    kTenantsFieldNumber = 10,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kIconFieldNumber = 5,
    kColorFieldNumber = 6,
    kAssetsFieldNumber = 8,
    kIdFieldNumber = 1,
    kCompanyIdFieldNumber = 2,
    kIsDefaultFieldNumber = 9,
  };
  // repeated .kentik.mkp.v202102alpha1.Alert alerts = 7 [json_name = "alerts"];
  int alerts_size() const;
  private:
  int _internal_alerts_size() const;

  public:
  void clear_alerts() ;
  ::kentik::mkp::v202102alpha1::Alert* mutable_alerts(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>* mutable_alerts();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>& _internal_alerts() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>* _internal_mutable_alerts();
  public:
  const ::kentik::mkp::v202102alpha1::Alert& alerts(int index) const;
  ::kentik::mkp::v202102alpha1::Alert* add_alerts();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>& alerts() const;
  // repeated .kentik.mkp.v202102alpha1.TenantLink tenants = 10 [json_name = "tenants"];
  int tenants_size() const;
  private:
  int _internal_tenants_size() const;

  public:
  void clear_tenants() ;
  ::kentik::mkp::v202102alpha1::TenantLink* mutable_tenants(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>* mutable_tenants();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>& _internal_tenants() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>* _internal_mutable_tenants();
  public:
  const ::kentik::mkp::v202102alpha1::TenantLink& tenants(int index) const;
  ::kentik::mkp::v202102alpha1::TenantLink* add_tenants();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>& tenants() const;
  // string name = 3 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 4 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string icon = 5 [json_name = "icon"];
  void clear_icon() ;
  const std::string& icon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_icon(Arg_&& arg, Args_... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* value);

  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(
      const std::string& value);
  std::string* _internal_mutable_icon();

  public:
  // string color = 6 [json_name = "color"];
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .kentik.mkp.v202102alpha1.Asset assets = 8 [json_name = "assets"];
  bool has_assets() const;
  void clear_assets() ;
  const ::kentik::mkp::v202102alpha1::Asset& assets() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Asset* release_assets();
  ::kentik::mkp::v202102alpha1::Asset* mutable_assets();
  void set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value);
  void unsafe_arena_set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value);
  ::kentik::mkp::v202102alpha1::Asset* unsafe_arena_release_assets();

  private:
  const ::kentik::mkp::v202102alpha1::Asset& _internal_assets() const;
  ::kentik::mkp::v202102alpha1::Asset* _internal_mutable_assets();

  public:
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 company_id = 2 [json_name = "companyId"];
  void clear_company_id() ;
  ::uint64_t company_id() const;
  void set_company_id(::uint64_t value);

  private:
  ::uint64_t _internal_company_id() const;
  void _internal_set_company_id(::uint64_t value);

  public:
  // bool is_default = 9 [json_name = "isDefault"];
  void clear_is_default() ;
  bool is_default() const;
  void set_is_default(bool value);

  private:
  bool _internal_is_default() const;
  void _internal_set_is_default(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Package)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Package& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Alert > alerts_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::TenantLink > tenants_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr icon_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::kentik::mkp::v202102alpha1::Asset* assets_;
    ::uint64_t id_;
    ::uint64_t company_id_;
    bool is_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class UpdatePackageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.UpdatePackageResponse) */ {
 public:
  inline UpdatePackageResponse() : UpdatePackageResponse(nullptr) {}
  ~UpdatePackageResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdatePackageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdatePackageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePackageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdatePackageResponse(const UpdatePackageResponse& from) : UpdatePackageResponse(nullptr, from) {}
  inline UpdatePackageResponse(UpdatePackageResponse&& from) noexcept
      : UpdatePackageResponse(nullptr, std::move(from)) {}
  inline UpdatePackageResponse& operator=(const UpdatePackageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePackageResponse& operator=(UpdatePackageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePackageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePackageResponse* internal_default_instance() {
    return reinterpret_cast<const UpdatePackageResponse*>(
        &_UpdatePackageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(UpdatePackageResponse& a, UpdatePackageResponse& b) { a.Swap(&b); }
  inline void Swap(UpdatePackageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePackageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePackageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdatePackageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePackageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdatePackageResponse& from) { UpdatePackageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdatePackageResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.UpdatePackageResponse"; }

 protected:
  explicit UpdatePackageResponse(::google::protobuf::Arena* arena);
  UpdatePackageResponse(::google::protobuf::Arena* arena, const UpdatePackageResponse& from);
  UpdatePackageResponse(::google::protobuf::Arena* arena, UpdatePackageResponse&& from) noexcept
      : UpdatePackageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.UpdatePackageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdatePackageResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class UpdatePackageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.UpdatePackageRequest) */ {
 public:
  inline UpdatePackageRequest() : UpdatePackageRequest(nullptr) {}
  ~UpdatePackageRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdatePackageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdatePackageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdatePackageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdatePackageRequest(const UpdatePackageRequest& from) : UpdatePackageRequest(nullptr, from) {}
  inline UpdatePackageRequest(UpdatePackageRequest&& from) noexcept
      : UpdatePackageRequest(nullptr, std::move(from)) {}
  inline UpdatePackageRequest& operator=(const UpdatePackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePackageRequest& operator=(UpdatePackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePackageRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePackageRequest*>(
        &_UpdatePackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(UpdatePackageRequest& a, UpdatePackageRequest& b) { a.Swap(&b); }
  inline void Swap(UpdatePackageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePackageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePackageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdatePackageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdatePackageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdatePackageRequest& from) { UpdatePackageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdatePackageRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.UpdatePackageRequest"; }

 protected:
  explicit UpdatePackageRequest(::google::protobuf::Arena* arena);
  UpdatePackageRequest(::google::protobuf::Arena* arena, const UpdatePackageRequest& from);
  UpdatePackageRequest(::google::protobuf::Arena* arena, UpdatePackageRequest&& from) noexcept
      : UpdatePackageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.UpdatePackageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdatePackageRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class Tenant final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.Tenant) */ {
 public:
  inline Tenant() : Tenant(nullptr) {}
  ~Tenant() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Tenant* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Tenant));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Tenant(
      ::google::protobuf::internal::ConstantInitialized);

  inline Tenant(const Tenant& from) : Tenant(nullptr, from) {}
  inline Tenant(Tenant&& from) noexcept
      : Tenant(nullptr, std::move(from)) {}
  inline Tenant& operator=(const Tenant& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tenant& operator=(Tenant&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tenant& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tenant* internal_default_instance() {
    return reinterpret_cast<const Tenant*>(
        &_Tenant_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Tenant& a, Tenant& b) { a.Swap(&b); }
  inline void Swap(Tenant* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tenant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tenant* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Tenant>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tenant& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Tenant& from) { Tenant::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Tenant* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.Tenant"; }

 protected:
  explicit Tenant(::google::protobuf::Arena* arena);
  Tenant(::google::protobuf::Arena* arena, const Tenant& from);
  Tenant(::google::protobuf::Arena* arena, Tenant&& from) noexcept
      : Tenant(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlertsFieldNumber = 7,
    kCustomDimensionsFieldNumber = 10,
    kPackagesFieldNumber = 16,
    kUsersFieldNumber = 17,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kTypeFieldNumber = 5,
    kAsnFieldNumber = 8,
    kCidrFieldNumber = 9,
    kInterfaceNameFieldNumber = 13,
    kSnmpAliasFieldNumber = 14,
    kDevicesFieldNumber = 11,
    kFiltersFieldNumber = 12,
    kAssetsFieldNumber = 15,
    kIdFieldNumber = 1,
    kCompanyIdFieldNumber = 2,
    kEnabledFieldNumber = 6,
    kTemplateIdFieldNumber = 18,
  };
  // repeated .kentik.mkp.v202102alpha1.Alert alerts = 7 [json_name = "alerts"];
  int alerts_size() const;
  private:
  int _internal_alerts_size() const;

  public:
  void clear_alerts() ;
  ::kentik::mkp::v202102alpha1::Alert* mutable_alerts(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>* mutable_alerts();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>& _internal_alerts() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>* _internal_mutable_alerts();
  public:
  const ::kentik::mkp::v202102alpha1::Alert& alerts(int index) const;
  ::kentik::mkp::v202102alpha1::Alert* add_alerts();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>& alerts() const;
  // repeated .kentik.mkp.v202102alpha1.CustomDimension custom_dimensions = 10 [json_name = "customDimensions"];
  int custom_dimensions_size() const;
  private:
  int _internal_custom_dimensions_size() const;

  public:
  void clear_custom_dimensions() ;
  ::kentik::mkp::v202102alpha1::CustomDimension* mutable_custom_dimensions(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>* mutable_custom_dimensions();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>& _internal_custom_dimensions() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>* _internal_mutable_custom_dimensions();
  public:
  const ::kentik::mkp::v202102alpha1::CustomDimension& custom_dimensions(int index) const;
  ::kentik::mkp::v202102alpha1::CustomDimension* add_custom_dimensions();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>& custom_dimensions() const;
  // repeated .kentik.mkp.v202102alpha1.Package packages = 16 [json_name = "packages"];
  int packages_size() const;
  private:
  int _internal_packages_size() const;

  public:
  void clear_packages() ;
  ::kentik::mkp::v202102alpha1::Package* mutable_packages(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>* mutable_packages();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>& _internal_packages() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>* _internal_mutable_packages();
  public:
  const ::kentik::mkp::v202102alpha1::Package& packages(int index) const;
  ::kentik::mkp::v202102alpha1::Package* add_packages();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>& packages() const;
  // repeated .kentik.mkp.v202102alpha1.User users = 17 [json_name = "users"];
  int users_size() const;
  private:
  int _internal_users_size() const;

  public:
  void clear_users() ;
  ::kentik::mkp::v202102alpha1::User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>* mutable_users();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>& _internal_users() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>* _internal_mutable_users();
  public:
  const ::kentik::mkp::v202102alpha1::User& users(int index) const;
  ::kentik::mkp::v202102alpha1::User* add_users();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>& users() const;
  // string name = 3 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 4 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string type = 5 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string asn = 8 [json_name = "asn"];
  void clear_asn() ;
  const std::string& asn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_asn(Arg_&& arg, Args_... args);
  std::string* mutable_asn();
  PROTOBUF_NODISCARD std::string* release_asn();
  void set_allocated_asn(std::string* value);

  private:
  const std::string& _internal_asn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asn(
      const std::string& value);
  std::string* _internal_mutable_asn();

  public:
  // string cidr = 9 [json_name = "cidr"];
  void clear_cidr() ;
  const std::string& cidr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cidr(Arg_&& arg, Args_... args);
  std::string* mutable_cidr();
  PROTOBUF_NODISCARD std::string* release_cidr();
  void set_allocated_cidr(std::string* value);

  private:
  const std::string& _internal_cidr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cidr(
      const std::string& value);
  std::string* _internal_mutable_cidr();

  public:
  // string interface_name = 13 [json_name = "interfaceName"];
  void clear_interface_name() ;
  const std::string& interface_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_name(Arg_&& arg, Args_... args);
  std::string* mutable_interface_name();
  PROTOBUF_NODISCARD std::string* release_interface_name();
  void set_allocated_interface_name(std::string* value);

  private:
  const std::string& _internal_interface_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_name(
      const std::string& value);
  std::string* _internal_mutable_interface_name();

  public:
  // string snmp_alias = 14 [json_name = "snmpAlias"];
  void clear_snmp_alias() ;
  const std::string& snmp_alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_snmp_alias(Arg_&& arg, Args_... args);
  std::string* mutable_snmp_alias();
  PROTOBUF_NODISCARD std::string* release_snmp_alias();
  void set_allocated_snmp_alias(std::string* value);

  private:
  const std::string& _internal_snmp_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snmp_alias(
      const std::string& value);
  std::string* _internal_mutable_snmp_alias();

  public:
  // .kentik.mkp.v202102alpha1.Device devices = 11 [json_name = "devices"];
  bool has_devices() const;
  void clear_devices() ;
  const ::kentik::mkp::v202102alpha1::Device& devices() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Device* release_devices();
  ::kentik::mkp::v202102alpha1::Device* mutable_devices();
  void set_allocated_devices(::kentik::mkp::v202102alpha1::Device* value);
  void unsafe_arena_set_allocated_devices(::kentik::mkp::v202102alpha1::Device* value);
  ::kentik::mkp::v202102alpha1::Device* unsafe_arena_release_devices();

  private:
  const ::kentik::mkp::v202102alpha1::Device& _internal_devices() const;
  ::kentik::mkp::v202102alpha1::Device* _internal_mutable_devices();

  public:
  // .kentik.mkp.v202102alpha1.Filter filters = 12 [json_name = "filters"];
  bool has_filters() const;
  void clear_filters() ;
  const ::kentik::mkp::v202102alpha1::Filter& filters() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Filter* release_filters();
  ::kentik::mkp::v202102alpha1::Filter* mutable_filters();
  void set_allocated_filters(::kentik::mkp::v202102alpha1::Filter* value);
  void unsafe_arena_set_allocated_filters(::kentik::mkp::v202102alpha1::Filter* value);
  ::kentik::mkp::v202102alpha1::Filter* unsafe_arena_release_filters();

  private:
  const ::kentik::mkp::v202102alpha1::Filter& _internal_filters() const;
  ::kentik::mkp::v202102alpha1::Filter* _internal_mutable_filters();

  public:
  // .kentik.mkp.v202102alpha1.Asset assets = 15 [json_name = "assets"];
  bool has_assets() const;
  void clear_assets() ;
  const ::kentik::mkp::v202102alpha1::Asset& assets() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Asset* release_assets();
  ::kentik::mkp::v202102alpha1::Asset* mutable_assets();
  void set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value);
  void unsafe_arena_set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value);
  ::kentik::mkp::v202102alpha1::Asset* unsafe_arena_release_assets();

  private:
  const ::kentik::mkp::v202102alpha1::Asset& _internal_assets() const;
  ::kentik::mkp::v202102alpha1::Asset* _internal_mutable_assets();

  public:
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 company_id = 2 [json_name = "companyId"];
  void clear_company_id() ;
  ::uint64_t company_id() const;
  void set_company_id(::uint64_t value);

  private:
  ::uint64_t _internal_company_id() const;
  void _internal_set_company_id(::uint64_t value);

  public:
  // bool enabled = 6 [json_name = "enabled"];
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // uint32 template_id = 18 [json_name = "templateId"];
  void clear_template_id() ;
  ::uint32_t template_id() const;
  void set_template_id(::uint32_t value);

  private:
  ::uint32_t _internal_template_id() const;
  void _internal_set_template_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.Tenant)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 18, 7,
      106, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Tenant& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Alert > alerts_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::CustomDimension > custom_dimensions_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Package > packages_;
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::User > users_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr asn_;
    ::google::protobuf::internal::ArenaStringPtr cidr_;
    ::google::protobuf::internal::ArenaStringPtr interface_name_;
    ::google::protobuf::internal::ArenaStringPtr snmp_alias_;
    ::kentik::mkp::v202102alpha1::Device* devices_;
    ::kentik::mkp::v202102alpha1::Filter* filters_;
    ::kentik::mkp::v202102alpha1::Asset* assets_;
    ::uint64_t id_;
    ::uint64_t company_id_;
    bool enabled_;
    ::uint32_t template_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class PatchPackageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.PatchPackageResponse) */ {
 public:
  inline PatchPackageResponse() : PatchPackageResponse(nullptr) {}
  ~PatchPackageResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchPackageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchPackageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchPackageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchPackageResponse(const PatchPackageResponse& from) : PatchPackageResponse(nullptr, from) {}
  inline PatchPackageResponse(PatchPackageResponse&& from) noexcept
      : PatchPackageResponse(nullptr, std::move(from)) {}
  inline PatchPackageResponse& operator=(const PatchPackageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchPackageResponse& operator=(PatchPackageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchPackageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchPackageResponse* internal_default_instance() {
    return reinterpret_cast<const PatchPackageResponse*>(
        &_PatchPackageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(PatchPackageResponse& a, PatchPackageResponse& b) { a.Swap(&b); }
  inline void Swap(PatchPackageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchPackageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchPackageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchPackageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchPackageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchPackageResponse& from) { PatchPackageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchPackageResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.PatchPackageResponse"; }

 protected:
  explicit PatchPackageResponse(::google::protobuf::Arena* arena);
  PatchPackageResponse(::google::protobuf::Arena* arena, const PatchPackageResponse& from);
  PatchPackageResponse(::google::protobuf::Arena* arena, PatchPackageResponse&& from) noexcept
      : PatchPackageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.PatchPackageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchPackageResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class PatchPackageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.PatchPackageRequest) */ {
 public:
  inline PatchPackageRequest() : PatchPackageRequest(nullptr) {}
  ~PatchPackageRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchPackageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchPackageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchPackageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchPackageRequest(const PatchPackageRequest& from) : PatchPackageRequest(nullptr, from) {}
  inline PatchPackageRequest(PatchPackageRequest&& from) noexcept
      : PatchPackageRequest(nullptr, std::move(from)) {}
  inline PatchPackageRequest& operator=(const PatchPackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchPackageRequest& operator=(PatchPackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchPackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchPackageRequest* internal_default_instance() {
    return reinterpret_cast<const PatchPackageRequest*>(
        &_PatchPackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(PatchPackageRequest& a, PatchPackageRequest& b) { a.Swap(&b); }
  inline void Swap(PatchPackageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchPackageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchPackageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchPackageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchPackageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchPackageRequest& from) { PatchPackageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchPackageRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.PatchPackageRequest"; }

 protected:
  explicit PatchPackageRequest(::google::protobuf::Arena* arena);
  PatchPackageRequest(::google::protobuf::Arena* arena, const PatchPackageRequest& from);
  PatchPackageRequest(::google::protobuf::Arena* arena, PatchPackageRequest&& from) noexcept
      : PatchPackageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
    kMaskFieldNumber = 2,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
  bool has_mask() const;
  void clear_mask() ;
  const ::google::protobuf::FieldMask& mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_mask();
  ::google::protobuf::FieldMask* mutable_mask();
  void set_allocated_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_mask();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.PatchPackageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchPackageRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    ::google::protobuf::FieldMask* mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class ListPackageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.ListPackageResponse) */ {
 public:
  inline ListPackageResponse() : ListPackageResponse(nullptr) {}
  ~ListPackageResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListPackageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListPackageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListPackageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListPackageResponse(const ListPackageResponse& from) : ListPackageResponse(nullptr, from) {}
  inline ListPackageResponse(ListPackageResponse&& from) noexcept
      : ListPackageResponse(nullptr, std::move(from)) {}
  inline ListPackageResponse& operator=(const ListPackageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPackageResponse& operator=(ListPackageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPackageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPackageResponse* internal_default_instance() {
    return reinterpret_cast<const ListPackageResponse*>(
        &_ListPackageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ListPackageResponse& a, ListPackageResponse& b) { a.Swap(&b); }
  inline void Swap(ListPackageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPackageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPackageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListPackageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListPackageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListPackageResponse& from) { ListPackageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListPackageResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.ListPackageResponse"; }

 protected:
  explicit ListPackageResponse(::google::protobuf::Arena* arena);
  ListPackageResponse(::google::protobuf::Arena* arena, const ListPackageResponse& from);
  ListPackageResponse(::google::protobuf::Arena* arena, ListPackageResponse&& from) noexcept
      : ListPackageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackagesFieldNumber = 1,
    kInvalidCountFieldNumber = 2,
  };
  // repeated .kentik.mkp.v202102alpha1.Package packages = 1 [json_name = "packages"];
  int packages_size() const;
  private:
  int _internal_packages_size() const;

  public:
  void clear_packages() ;
  ::kentik::mkp::v202102alpha1::Package* mutable_packages(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>* mutable_packages();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>& _internal_packages() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>* _internal_mutable_packages();
  public:
  const ::kentik::mkp::v202102alpha1::Package& packages(int index) const;
  ::kentik::mkp::v202102alpha1::Package* add_packages();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>& packages() const;
  // uint32 invalid_count = 2 [json_name = "invalidCount"];
  void clear_invalid_count() ;
  ::uint32_t invalid_count() const;
  void set_invalid_count(::uint32_t value);

  private:
  ::uint32_t _internal_invalid_count() const;
  void _internal_set_invalid_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.ListPackageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListPackageResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Package > packages_;
    ::uint32_t invalid_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class GetPackageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.GetPackageResponse) */ {
 public:
  inline GetPackageResponse() : GetPackageResponse(nullptr) {}
  ~GetPackageResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetPackageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetPackageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPackageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetPackageResponse(const GetPackageResponse& from) : GetPackageResponse(nullptr, from) {}
  inline GetPackageResponse(GetPackageResponse&& from) noexcept
      : GetPackageResponse(nullptr, std::move(from)) {}
  inline GetPackageResponse& operator=(const GetPackageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPackageResponse& operator=(GetPackageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPackageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPackageResponse* internal_default_instance() {
    return reinterpret_cast<const GetPackageResponse*>(
        &_GetPackageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GetPackageResponse& a, GetPackageResponse& b) { a.Swap(&b); }
  inline void Swap(GetPackageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPackageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPackageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetPackageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPackageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetPackageResponse& from) { GetPackageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetPackageResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.GetPackageResponse"; }

 protected:
  explicit GetPackageResponse(::google::protobuf::Arena* arena);
  GetPackageResponse(::google::protobuf::Arena* arena, const GetPackageResponse& from);
  GetPackageResponse(::google::protobuf::Arena* arena, GetPackageResponse&& from) noexcept
      : GetPackageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.GetPackageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetPackageResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class CreatePackageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.CreatePackageResponse) */ {
 public:
  inline CreatePackageResponse() : CreatePackageResponse(nullptr) {}
  ~CreatePackageResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreatePackageResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreatePackageResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreatePackageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreatePackageResponse(const CreatePackageResponse& from) : CreatePackageResponse(nullptr, from) {}
  inline CreatePackageResponse(CreatePackageResponse&& from) noexcept
      : CreatePackageResponse(nullptr, std::move(from)) {}
  inline CreatePackageResponse& operator=(const CreatePackageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePackageResponse& operator=(CreatePackageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePackageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePackageResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePackageResponse*>(
        &_CreatePackageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(CreatePackageResponse& a, CreatePackageResponse& b) { a.Swap(&b); }
  inline void Swap(CreatePackageResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePackageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePackageResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreatePackageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreatePackageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreatePackageResponse& from) { CreatePackageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreatePackageResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.CreatePackageResponse"; }

 protected:
  explicit CreatePackageResponse(::google::protobuf::Arena* arena);
  CreatePackageResponse(::google::protobuf::Arena* arena, const CreatePackageResponse& from);
  CreatePackageResponse(::google::protobuf::Arena* arena, CreatePackageResponse&& from) noexcept
      : CreatePackageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.CreatePackageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreatePackageResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class CreatePackageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.CreatePackageRequest) */ {
 public:
  inline CreatePackageRequest() : CreatePackageRequest(nullptr) {}
  ~CreatePackageRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreatePackageRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreatePackageRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreatePackageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreatePackageRequest(const CreatePackageRequest& from) : CreatePackageRequest(nullptr, from) {}
  inline CreatePackageRequest(CreatePackageRequest&& from) noexcept
      : CreatePackageRequest(nullptr, std::move(from)) {}
  inline CreatePackageRequest& operator=(const CreatePackageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePackageRequest& operator=(CreatePackageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePackageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePackageRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePackageRequest*>(
        &_CreatePackageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(CreatePackageRequest& a, CreatePackageRequest& b) { a.Swap(&b); }
  inline void Swap(CreatePackageRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePackageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePackageRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreatePackageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreatePackageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreatePackageRequest& from) { CreatePackageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreatePackageRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.CreatePackageRequest"; }

 protected:
  explicit CreatePackageRequest(::google::protobuf::Arena* arena);
  CreatePackageRequest(::google::protobuf::Arena* arena, const CreatePackageRequest& from);
  CreatePackageRequest(::google::protobuf::Arena* arena, CreatePackageRequest&& from) noexcept
      : CreatePackageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
  bool has_package() const;
  void clear_package() ;
  const ::kentik::mkp::v202102alpha1::Package& package() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Package* release_package();
  ::kentik::mkp::v202102alpha1::Package* mutable_package();
  void set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  void unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value);
  ::kentik::mkp::v202102alpha1::Package* unsafe_arena_release_package();

  private:
  const ::kentik::mkp::v202102alpha1::Package& _internal_package() const;
  ::kentik::mkp::v202102alpha1::Package* _internal_mutable_package();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.CreatePackageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreatePackageRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Package* package_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class UpdateTenantResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.UpdateTenantResponse) */ {
 public:
  inline UpdateTenantResponse() : UpdateTenantResponse(nullptr) {}
  ~UpdateTenantResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateTenantResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateTenantResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTenantResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateTenantResponse(const UpdateTenantResponse& from) : UpdateTenantResponse(nullptr, from) {}
  inline UpdateTenantResponse(UpdateTenantResponse&& from) noexcept
      : UpdateTenantResponse(nullptr, std::move(from)) {}
  inline UpdateTenantResponse& operator=(const UpdateTenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTenantResponse& operator=(UpdateTenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTenantResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateTenantResponse*>(
        &_UpdateTenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(UpdateTenantResponse& a, UpdateTenantResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateTenantResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTenantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTenantResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateTenantResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTenantResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateTenantResponse& from) { UpdateTenantResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateTenantResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.UpdateTenantResponse"; }

 protected:
  explicit UpdateTenantResponse(::google::protobuf::Arena* arena);
  UpdateTenantResponse(::google::protobuf::Arena* arena, const UpdateTenantResponse& from);
  UpdateTenantResponse(::google::protobuf::Arena* arena, UpdateTenantResponse&& from) noexcept
      : UpdateTenantResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.UpdateTenantResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateTenantResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class UpdateTenantRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.UpdateTenantRequest) */ {
 public:
  inline UpdateTenantRequest() : UpdateTenantRequest(nullptr) {}
  ~UpdateTenantRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateTenantRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateTenantRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTenantRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateTenantRequest(const UpdateTenantRequest& from) : UpdateTenantRequest(nullptr, from) {}
  inline UpdateTenantRequest(UpdateTenantRequest&& from) noexcept
      : UpdateTenantRequest(nullptr, std::move(from)) {}
  inline UpdateTenantRequest& operator=(const UpdateTenantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTenantRequest& operator=(UpdateTenantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTenantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTenantRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTenantRequest*>(
        &_UpdateTenantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(UpdateTenantRequest& a, UpdateTenantRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateTenantRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTenantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTenantRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateTenantRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTenantRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateTenantRequest& from) { UpdateTenantRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateTenantRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.UpdateTenantRequest"; }

 protected:
  explicit UpdateTenantRequest(::google::protobuf::Arena* arena);
  UpdateTenantRequest(::google::protobuf::Arena* arena, const UpdateTenantRequest& from);
  UpdateTenantRequest(::google::protobuf::Arena* arena, UpdateTenantRequest&& from) noexcept
      : UpdateTenantRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.UpdateTenantRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateTenantRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class PatchTenantResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.PatchTenantResponse) */ {
 public:
  inline PatchTenantResponse() : PatchTenantResponse(nullptr) {}
  ~PatchTenantResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchTenantResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchTenantResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchTenantResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchTenantResponse(const PatchTenantResponse& from) : PatchTenantResponse(nullptr, from) {}
  inline PatchTenantResponse(PatchTenantResponse&& from) noexcept
      : PatchTenantResponse(nullptr, std::move(from)) {}
  inline PatchTenantResponse& operator=(const PatchTenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchTenantResponse& operator=(PatchTenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchTenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchTenantResponse* internal_default_instance() {
    return reinterpret_cast<const PatchTenantResponse*>(
        &_PatchTenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(PatchTenantResponse& a, PatchTenantResponse& b) { a.Swap(&b); }
  inline void Swap(PatchTenantResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchTenantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchTenantResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchTenantResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchTenantResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchTenantResponse& from) { PatchTenantResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchTenantResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.PatchTenantResponse"; }

 protected:
  explicit PatchTenantResponse(::google::protobuf::Arena* arena);
  PatchTenantResponse(::google::protobuf::Arena* arena, const PatchTenantResponse& from);
  PatchTenantResponse(::google::protobuf::Arena* arena, PatchTenantResponse&& from) noexcept
      : PatchTenantResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.PatchTenantResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchTenantResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class PatchTenantRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.PatchTenantRequest) */ {
 public:
  inline PatchTenantRequest() : PatchTenantRequest(nullptr) {}
  ~PatchTenantRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchTenantRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchTenantRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchTenantRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchTenantRequest(const PatchTenantRequest& from) : PatchTenantRequest(nullptr, from) {}
  inline PatchTenantRequest(PatchTenantRequest&& from) noexcept
      : PatchTenantRequest(nullptr, std::move(from)) {}
  inline PatchTenantRequest& operator=(const PatchTenantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchTenantRequest& operator=(PatchTenantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchTenantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchTenantRequest* internal_default_instance() {
    return reinterpret_cast<const PatchTenantRequest*>(
        &_PatchTenantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(PatchTenantRequest& a, PatchTenantRequest& b) { a.Swap(&b); }
  inline void Swap(PatchTenantRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchTenantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchTenantRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchTenantRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchTenantRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchTenantRequest& from) { PatchTenantRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchTenantRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.PatchTenantRequest"; }

 protected:
  explicit PatchTenantRequest(::google::protobuf::Arena* arena);
  PatchTenantRequest(::google::protobuf::Arena* arena, const PatchTenantRequest& from);
  PatchTenantRequest(::google::protobuf::Arena* arena, PatchTenantRequest&& from) noexcept
      : PatchTenantRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
    kMaskFieldNumber = 2,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
  bool has_mask() const;
  void clear_mask() ;
  const ::google::protobuf::FieldMask& mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_mask();
  ::google::protobuf::FieldMask* mutable_mask();
  void set_allocated_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_mask();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.PatchTenantRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchTenantRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    ::google::protobuf::FieldMask* mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class ListTenantResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.ListTenantResponse) */ {
 public:
  inline ListTenantResponse() : ListTenantResponse(nullptr) {}
  ~ListTenantResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListTenantResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListTenantResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListTenantResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListTenantResponse(const ListTenantResponse& from) : ListTenantResponse(nullptr, from) {}
  inline ListTenantResponse(ListTenantResponse&& from) noexcept
      : ListTenantResponse(nullptr, std::move(from)) {}
  inline ListTenantResponse& operator=(const ListTenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTenantResponse& operator=(ListTenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTenantResponse* internal_default_instance() {
    return reinterpret_cast<const ListTenantResponse*>(
        &_ListTenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(ListTenantResponse& a, ListTenantResponse& b) { a.Swap(&b); }
  inline void Swap(ListTenantResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTenantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTenantResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListTenantResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListTenantResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListTenantResponse& from) { ListTenantResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListTenantResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.ListTenantResponse"; }

 protected:
  explicit ListTenantResponse(::google::protobuf::Arena* arena);
  ListTenantResponse(::google::protobuf::Arena* arena, const ListTenantResponse& from);
  ListTenantResponse(::google::protobuf::Arena* arena, ListTenantResponse&& from) noexcept
      : ListTenantResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantsFieldNumber = 1,
    kInvalidCountFieldNumber = 2,
  };
  // repeated .kentik.mkp.v202102alpha1.Tenant tenants = 1 [json_name = "tenants"];
  int tenants_size() const;
  private:
  int _internal_tenants_size() const;

  public:
  void clear_tenants() ;
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenants(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>* mutable_tenants();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>& _internal_tenants() const;
  ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>* _internal_mutable_tenants();
  public:
  const ::kentik::mkp::v202102alpha1::Tenant& tenants(int index) const;
  ::kentik::mkp::v202102alpha1::Tenant* add_tenants();
  const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>& tenants() const;
  // uint32 invalid_count = 2 [json_name = "invalidCount"];
  void clear_invalid_count() ;
  ::uint32_t invalid_count() const;
  void set_invalid_count(::uint32_t value);

  private:
  ::uint32_t _internal_invalid_count() const;
  void _internal_set_invalid_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.ListTenantResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListTenantResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::mkp::v202102alpha1::Tenant > tenants_;
    ::uint32_t invalid_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class GetTenantResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.GetTenantResponse) */ {
 public:
  inline GetTenantResponse() : GetTenantResponse(nullptr) {}
  ~GetTenantResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTenantResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTenantResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTenantResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTenantResponse(const GetTenantResponse& from) : GetTenantResponse(nullptr, from) {}
  inline GetTenantResponse(GetTenantResponse&& from) noexcept
      : GetTenantResponse(nullptr, std::move(from)) {}
  inline GetTenantResponse& operator=(const GetTenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTenantResponse& operator=(GetTenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTenantResponse* internal_default_instance() {
    return reinterpret_cast<const GetTenantResponse*>(
        &_GetTenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(GetTenantResponse& a, GetTenantResponse& b) { a.Swap(&b); }
  inline void Swap(GetTenantResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTenantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTenantResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTenantResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTenantResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTenantResponse& from) { GetTenantResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTenantResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.GetTenantResponse"; }

 protected:
  explicit GetTenantResponse(::google::protobuf::Arena* arena);
  GetTenantResponse(::google::protobuf::Arena* arena, const GetTenantResponse& from);
  GetTenantResponse(::google::protobuf::Arena* arena, GetTenantResponse&& from) noexcept
      : GetTenantResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.GetTenantResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTenantResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class CreateTenantResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.CreateTenantResponse) */ {
 public:
  inline CreateTenantResponse() : CreateTenantResponse(nullptr) {}
  ~CreateTenantResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateTenantResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateTenantResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTenantResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTenantResponse(const CreateTenantResponse& from) : CreateTenantResponse(nullptr, from) {}
  inline CreateTenantResponse(CreateTenantResponse&& from) noexcept
      : CreateTenantResponse(nullptr, std::move(from)) {}
  inline CreateTenantResponse& operator=(const CreateTenantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTenantResponse& operator=(CreateTenantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTenantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTenantResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTenantResponse*>(
        &_CreateTenantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(CreateTenantResponse& a, CreateTenantResponse& b) { a.Swap(&b); }
  inline void Swap(CreateTenantResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTenantResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTenantResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateTenantResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTenantResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTenantResponse& from) { CreateTenantResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateTenantResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.CreateTenantResponse"; }

 protected:
  explicit CreateTenantResponse(::google::protobuf::Arena* arena);
  CreateTenantResponse(::google::protobuf::Arena* arena, const CreateTenantResponse& from);
  CreateTenantResponse(::google::protobuf::Arena* arena, CreateTenantResponse&& from) noexcept
      : CreateTenantResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.CreateTenantResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTenantResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};
// -------------------------------------------------------------------

class CreateTenantRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.mkp.v202102alpha1.CreateTenantRequest) */ {
 public:
  inline CreateTenantRequest() : CreateTenantRequest(nullptr) {}
  ~CreateTenantRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateTenantRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateTenantRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTenantRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTenantRequest(const CreateTenantRequest& from) : CreateTenantRequest(nullptr, from) {}
  inline CreateTenantRequest(CreateTenantRequest&& from) noexcept
      : CreateTenantRequest(nullptr, std::move(from)) {}
  inline CreateTenantRequest& operator=(const CreateTenantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTenantRequest& operator=(CreateTenantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTenantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTenantRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTenantRequest*>(
        &_CreateTenantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(CreateTenantRequest& a, CreateTenantRequest& b) { a.Swap(&b); }
  inline void Swap(CreateTenantRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTenantRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTenantRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateTenantRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTenantRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTenantRequest& from) { CreateTenantRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateTenantRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.mkp.v202102alpha1.CreateTenantRequest"; }

 protected:
  explicit CreateTenantRequest(::google::protobuf::Arena* arena);
  CreateTenantRequest(::google::protobuf::Arena* arena, const CreateTenantRequest& from);
  CreateTenantRequest(::google::protobuf::Arena* arena, CreateTenantRequest&& from) noexcept
      : CreateTenantRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTenantFieldNumber = 1,
  };
  // .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
  bool has_tenant() const;
  void clear_tenant() ;
  const ::kentik::mkp::v202102alpha1::Tenant& tenant() const;
  PROTOBUF_NODISCARD ::kentik::mkp::v202102alpha1::Tenant* release_tenant();
  ::kentik::mkp::v202102alpha1::Tenant* mutable_tenant();
  void set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  void unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value);
  ::kentik::mkp::v202102alpha1::Tenant* unsafe_arena_release_tenant();

  private:
  const ::kentik::mkp::v202102alpha1::Tenant& _internal_tenant() const;
  ::kentik::mkp::v202102alpha1::Tenant* _internal_mutable_tenant();

  public:
  // @@protoc_insertion_point(class_scope:kentik.mkp.v202102alpha1.CreateTenantRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTenantRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::mkp::v202102alpha1::Tenant* tenant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Alert

// bool saved = 1 [json_name = "saved"];
inline void Alert::clear_saved() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saved_ = false;
}
inline bool Alert::saved() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.saved)
  return _internal_saved();
}
inline void Alert::set_saved(bool value) {
  _internal_set_saved(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Alert.saved)
}
inline bool Alert::_internal_saved() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saved_;
}
inline void Alert::_internal_set_saved(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saved_ = value;
}

// uint64 policy_id = 2 [json_name = "policyId"];
inline void Alert::clear_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_ = ::uint64_t{0u};
}
inline ::uint64_t Alert::policy_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.policy_id)
  return _internal_policy_id();
}
inline void Alert::set_policy_id(::uint64_t value) {
  _internal_set_policy_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Alert.policy_id)
}
inline ::uint64_t Alert::_internal_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.policy_id_;
}
inline void Alert::_internal_set_policy_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_ = value;
}

// repeated .kentik.mkp.v202102alpha1.Threshold thresholds = 3 [json_name = "thresholds"];
inline int Alert::_internal_thresholds_size() const {
  return _internal_thresholds().size();
}
inline int Alert::thresholds_size() const {
  return _internal_thresholds_size();
}
inline void Alert::clear_thresholds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.thresholds_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Threshold* Alert::mutable_thresholds(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Alert.thresholds)
  return _internal_mutable_thresholds()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>* Alert::mutable_thresholds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Alert.thresholds)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_thresholds();
}
inline const ::kentik::mkp::v202102alpha1::Threshold& Alert::thresholds(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.thresholds)
  return _internal_thresholds().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Threshold* Alert::add_thresholds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Threshold* _add = _internal_mutable_thresholds()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Alert.thresholds)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>& Alert::thresholds() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Alert.thresholds)
  return _internal_thresholds();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>&
Alert::_internal_thresholds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.thresholds_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Threshold>*
Alert::_internal_mutable_thresholds() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.thresholds_;
}

// string primary_metric = 4 [json_name = "primaryMetric"];
inline void Alert::clear_primary_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_metric_.ClearToEmpty();
}
inline const std::string& Alert::primary_metric() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.primary_metric)
  return _internal_primary_metric();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alert::set_primary_metric(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_metric_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Alert.primary_metric)
}
inline std::string* Alert::mutable_primary_metric() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_metric();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Alert.primary_metric)
  return _s;
}
inline const std::string& Alert::_internal_primary_metric() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_metric_.Get();
}
inline void Alert::_internal_set_primary_metric(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_metric_.Set(value, GetArena());
}
inline std::string* Alert::_internal_mutable_primary_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.primary_metric_.Mutable( GetArena());
}
inline std::string* Alert::release_primary_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Alert.primary_metric)
  return _impl_.primary_metric_.Release();
}
inline void Alert::set_allocated_primary_metric(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_metric_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.primary_metric_.IsDefault()) {
    _impl_.primary_metric_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Alert.primary_metric)
}

// repeated string secondary_metrics = 5 [json_name = "secondaryMetrics"];
inline int Alert::_internal_secondary_metrics_size() const {
  return _internal_secondary_metrics().size();
}
inline int Alert::secondary_metrics_size() const {
  return _internal_secondary_metrics_size();
}
inline void Alert::clear_secondary_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_metrics_.Clear();
}
inline std::string* Alert::add_secondary_metrics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_secondary_metrics()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
  return _s;
}
inline const std::string& Alert::secondary_metrics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
  return _internal_secondary_metrics().Get(index);
}
inline std::string* Alert::mutable_secondary_metrics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
  return _internal_mutable_secondary_metrics()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Alert::set_secondary_metrics(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_secondary_metrics()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
}
template <typename Arg_, typename... Args_>
inline void Alert::add_secondary_metrics(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_secondary_metrics(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Alert::secondary_metrics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
  return _internal_secondary_metrics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Alert::mutable_secondary_metrics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Alert.secondary_metrics)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_secondary_metrics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Alert::_internal_secondary_metrics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secondary_metrics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Alert::_internal_mutable_secondary_metrics() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.secondary_metrics_;
}

// bool is_template = 6 [json_name = "isTemplate"];
inline void Alert::clear_is_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_template_ = false;
}
inline bool Alert::is_template() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.is_template)
  return _internal_is_template();
}
inline void Alert::set_is_template(bool value) {
  _internal_set_is_template(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Alert.is_template)
}
inline bool Alert::_internal_is_template() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_template_;
}
inline void Alert::_internal_set_is_template(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_template_ = value;
}

// string subpolicy_id = 7 [json_name = "subpolicyId"];
inline void Alert::clear_subpolicy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subpolicy_id_.ClearToEmpty();
}
inline const std::string& Alert::subpolicy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Alert.subpolicy_id)
  return _internal_subpolicy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alert::set_subpolicy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subpolicy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Alert.subpolicy_id)
}
inline std::string* Alert::mutable_subpolicy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subpolicy_id();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Alert.subpolicy_id)
  return _s;
}
inline const std::string& Alert::_internal_subpolicy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subpolicy_id_.Get();
}
inline void Alert::_internal_set_subpolicy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subpolicy_id_.Set(value, GetArena());
}
inline std::string* Alert::_internal_mutable_subpolicy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.subpolicy_id_.Mutable( GetArena());
}
inline std::string* Alert::release_subpolicy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Alert.subpolicy_id)
  return _impl_.subpolicy_id_.Release();
}
inline void Alert::set_allocated_subpolicy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subpolicy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.subpolicy_id_.IsDefault()) {
    _impl_.subpolicy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Alert.subpolicy_id)
}

// -------------------------------------------------------------------

// Asset_Report

// uint64 id = 1 [json_name = "id"];
inline void Asset_Report::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Asset_Report::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Asset.Report.id)
  return _internal_id();
}
inline void Asset_Report::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Asset.Report.id)
}
inline ::uint64_t Asset_Report::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Asset_Report::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string type = 2 [json_name = "type"];
inline void Asset_Report::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Asset_Report::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Asset.Report.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Report::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Asset.Report.type)
}
inline std::string* Asset_Report::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Asset.Report.type)
  return _s;
}
inline const std::string& Asset_Report::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Asset_Report::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Asset_Report::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Asset_Report::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Asset.Report.type)
  return _impl_.type_.Release();
}
inline void Asset_Report::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Asset.Report.type)
}

// -------------------------------------------------------------------

// Asset

// repeated .kentik.mkp.v202102alpha1.Asset.Report reports = 1 [json_name = "reports"];
inline int Asset::_internal_reports_size() const {
  return _internal_reports().size();
}
inline int Asset::reports_size() const {
  return _internal_reports_size();
}
inline void Asset::clear_reports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reports_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Asset_Report* Asset::mutable_reports(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Asset.reports)
  return _internal_mutable_reports()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>* Asset::mutable_reports()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Asset.reports)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_reports();
}
inline const ::kentik::mkp::v202102alpha1::Asset_Report& Asset::reports(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Asset.reports)
  return _internal_reports().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Asset_Report* Asset::add_reports() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Asset_Report* _add = _internal_mutable_reports()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Asset.reports)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>& Asset::reports() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Asset.reports)
  return _internal_reports();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>&
Asset::_internal_reports() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reports_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Asset_Report>*
Asset::_internal_mutable_reports() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.reports_;
}

// .kentik.mkp.v202102alpha1.Asset.Report default_report = 2 [json_name = "defaultReport"];
inline bool Asset::has_default_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.default_report_ != nullptr);
  return value;
}
inline void Asset::clear_default_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.default_report_ != nullptr) _impl_.default_report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Asset_Report& Asset::_internal_default_report() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Asset_Report* p = _impl_.default_report_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Asset_Report&>(::kentik::mkp::v202102alpha1::_Asset_Report_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Asset_Report& Asset::default_report() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Asset.default_report)
  return _internal_default_report();
}
inline void Asset::unsafe_arena_set_allocated_default_report(::kentik::mkp::v202102alpha1::Asset_Report* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.default_report_);
  }
  _impl_.default_report_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset_Report*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.Asset.default_report)
}
inline ::kentik::mkp::v202102alpha1::Asset_Report* Asset::release_default_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Asset_Report* released = _impl_.default_report_;
  _impl_.default_report_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Asset_Report* Asset::unsafe_arena_release_default_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Asset.default_report)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Asset_Report* temp = _impl_.default_report_;
  _impl_.default_report_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Asset_Report* Asset::_internal_mutable_default_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.default_report_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Asset_Report>(GetArena());
    _impl_.default_report_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset_Report*>(p);
  }
  return _impl_.default_report_;
}
inline ::kentik::mkp::v202102alpha1::Asset_Report* Asset::mutable_default_report() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Asset_Report* _msg = _internal_mutable_default_report();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Asset.default_report)
  return _msg;
}
inline void Asset::set_allocated_default_report(::kentik::mkp::v202102alpha1::Asset_Report* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.default_report_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.default_report_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset_Report*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Asset.default_report)
}

// -------------------------------------------------------------------

// Threshold

// uint64 id = 1 [json_name = "id"];
inline void Threshold::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Threshold::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.id)
  return _internal_id();
}
inline void Threshold::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Threshold.id)
}
inline ::uint64_t Threshold::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Threshold::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .kentik.mkp.v202102alpha1.Activate activate = 2 [json_name = "activate"];
inline bool Threshold::has_activate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activate_ != nullptr);
  return value;
}
inline void Threshold::clear_activate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.activate_ != nullptr) _impl_.activate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Activate& Threshold::_internal_activate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Activate* p = _impl_.activate_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Activate&>(::kentik::mkp::v202102alpha1::_Activate_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Activate& Threshold::activate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.activate)
  return _internal_activate();
}
inline void Threshold::unsafe_arena_set_allocated_activate(::kentik::mkp::v202102alpha1::Activate* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.activate_);
  }
  _impl_.activate_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Activate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.Threshold.activate)
}
inline ::kentik::mkp::v202102alpha1::Activate* Threshold::release_activate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Activate* released = _impl_.activate_;
  _impl_.activate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Activate* Threshold::unsafe_arena_release_activate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Threshold.activate)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Activate* temp = _impl_.activate_;
  _impl_.activate_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Activate* Threshold::_internal_mutable_activate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.activate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Activate>(GetArena());
    _impl_.activate_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Activate*>(p);
  }
  return _impl_.activate_;
}
inline ::kentik::mkp::v202102alpha1::Activate* Threshold::mutable_activate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Activate* _msg = _internal_mutable_activate();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Threshold.activate)
  return _msg;
}
inline void Threshold::set_allocated_activate(::kentik::mkp::v202102alpha1::Activate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.activate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.activate_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Activate*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Threshold.activate)
}

// string severity = 3 [json_name = "severity"];
inline void Threshold::clear_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_.ClearToEmpty();
}
inline const std::string& Threshold::severity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.severity)
  return _internal_severity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Threshold::set_severity(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Threshold.severity)
}
inline std::string* Threshold::mutable_severity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_severity();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Threshold.severity)
  return _s;
}
inline const std::string& Threshold::_internal_severity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.severity_.Get();
}
inline void Threshold::_internal_set_severity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_.Set(value, GetArena());
}
inline std::string* Threshold::_internal_mutable_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.severity_.Mutable( GetArena());
}
inline std::string* Threshold::release_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Threshold.severity)
  return _impl_.severity_.Release();
}
inline void Threshold::set_allocated_severity(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.severity_.IsDefault()) {
    _impl_.severity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Threshold.severity)
}

// repeated .kentik.mkp.v202102alpha1.Condition conditions = 4 [json_name = "conditions"];
inline int Threshold::_internal_conditions_size() const {
  return _internal_conditions().size();
}
inline int Threshold::conditions_size() const {
  return _internal_conditions_size();
}
inline void Threshold::clear_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditions_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Condition* Threshold::mutable_conditions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Threshold.conditions)
  return _internal_mutable_conditions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>* Threshold::mutable_conditions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Threshold.conditions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_conditions();
}
inline const ::kentik::mkp::v202102alpha1::Condition& Threshold::conditions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.conditions)
  return _internal_conditions().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Condition* Threshold::add_conditions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Condition* _add = _internal_mutable_conditions()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Threshold.conditions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>& Threshold::conditions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Threshold.conditions)
  return _internal_conditions();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>&
Threshold::_internal_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conditions_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Condition>*
Threshold::_internal_mutable_conditions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.conditions_;
}

// repeated .kentik.mkp.v202102alpha1.Mitigation mitigations = 5 [json_name = "mitigations"];
inline int Threshold::_internal_mitigations_size() const {
  return _internal_mitigations().size();
}
inline int Threshold::mitigations_size() const {
  return _internal_mitigations_size();
}
inline void Threshold::clear_mitigations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigations_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Mitigation* Threshold::mutable_mitigations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Threshold.mitigations)
  return _internal_mutable_mitigations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>* Threshold::mutable_mitigations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Threshold.mitigations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_mitigations();
}
inline const ::kentik::mkp::v202102alpha1::Mitigation& Threshold::mitigations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.mitigations)
  return _internal_mitigations().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Mitigation* Threshold::add_mitigations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Mitigation* _add = _internal_mutable_mitigations()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Threshold.mitigations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>& Threshold::mitigations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Threshold.mitigations)
  return _internal_mitigations();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>&
Threshold::_internal_mitigations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mitigations_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Mitigation>*
Threshold::_internal_mutable_mitigations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.mitigations_;
}

// repeated .kentik.mkp.v202102alpha1.NotificationChannel notification_channels = 6 [json_name = "notificationChannels"];
inline int Threshold::_internal_notification_channels_size() const {
  return _internal_notification_channels().size();
}
inline int Threshold::notification_channels_size() const {
  return _internal_notification_channels_size();
}
inline void Threshold::clear_notification_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notification_channels_.Clear();
}
inline ::kentik::mkp::v202102alpha1::NotificationChannel* Threshold::mutable_notification_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Threshold.notification_channels)
  return _internal_mutable_notification_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>* Threshold::mutable_notification_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Threshold.notification_channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_notification_channels();
}
inline const ::kentik::mkp::v202102alpha1::NotificationChannel& Threshold::notification_channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.notification_channels)
  return _internal_notification_channels().Get(index);
}
inline ::kentik::mkp::v202102alpha1::NotificationChannel* Threshold::add_notification_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::NotificationChannel* _add = _internal_mutable_notification_channels()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Threshold.notification_channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>& Threshold::notification_channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Threshold.notification_channels)
  return _internal_notification_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>&
Threshold::_internal_notification_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notification_channels_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::NotificationChannel>*
Threshold::_internal_mutable_notification_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.notification_channels_;
}

// bool threshold_ack_required = 7 [json_name = "thresholdAckRequired"];
inline void Threshold::clear_threshold_ack_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_ack_required_ = false;
}
inline bool Threshold::threshold_ack_required() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.threshold_ack_required)
  return _internal_threshold_ack_required();
}
inline void Threshold::set_threshold_ack_required(bool value) {
  _internal_set_threshold_ack_required(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Threshold.threshold_ack_required)
}
inline bool Threshold::_internal_threshold_ack_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threshold_ack_required_;
}
inline void Threshold::_internal_set_threshold_ack_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_ack_required_ = value;
}

// bool enable_tenant_notifications = 8 [json_name = "enableTenantNotifications"];
inline void Threshold::clear_enable_tenant_notifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_tenant_notifications_ = false;
}
inline bool Threshold::enable_tenant_notifications() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.enable_tenant_notifications)
  return _internal_enable_tenant_notifications();
}
inline void Threshold::set_enable_tenant_notifications(bool value) {
  _internal_set_enable_tenant_notifications(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Threshold.enable_tenant_notifications)
}
inline bool Threshold::_internal_enable_tenant_notifications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_tenant_notifications_;
}
inline void Threshold::_internal_set_enable_tenant_notifications(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_tenant_notifications_ = value;
}

// bool receive_landlord_notifications = 9 [json_name = "receiveLandlordNotifications"];
inline void Threshold::clear_receive_landlord_notifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.receive_landlord_notifications_ = false;
}
inline bool Threshold::receive_landlord_notifications() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Threshold.receive_landlord_notifications)
  return _internal_receive_landlord_notifications();
}
inline void Threshold::set_receive_landlord_notifications(bool value) {
  _internal_set_receive_landlord_notifications(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Threshold.receive_landlord_notifications)
}
inline bool Threshold::_internal_receive_landlord_notifications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.receive_landlord_notifications_;
}
inline void Threshold::_internal_set_receive_landlord_notifications(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.receive_landlord_notifications_ = value;
}

// -------------------------------------------------------------------

// Activate

// uint32 times = 1 [json_name = "times"];
inline void Activate::clear_times() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.times_ = 0u;
}
inline ::uint32_t Activate::times() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Activate.times)
  return _internal_times();
}
inline void Activate::set_times(::uint32_t value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Activate.times)
}
inline ::uint32_t Activate::_internal_times() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.times_;
}
inline void Activate::_internal_set_times(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.times_ = value;
}

// string operator = 2 [json_name = "operator"];
inline void Activate::clear_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.ClearToEmpty();
}
inline const std::string& Activate::operator_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Activate.operator)
  return _internal_operator_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Activate::set_operator_(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Activate.operator)
}
inline std::string* Activate::mutable_operator_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Activate.operator)
  return _s;
}
inline const std::string& Activate::_internal_operator_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operator__.Get();
}
inline void Activate::_internal_set_operator_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.Set(value, GetArena());
}
inline std::string* Activate::_internal_mutable_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operator__.Mutable( GetArena());
}
inline std::string* Activate::release_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Activate.operator)
  return _impl_.operator__.Release();
}
inline void Activate::set_allocated_operator_(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operator__.IsDefault()) {
    _impl_.operator__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Activate.operator)
}

// string time_unit = 3 [json_name = "timeUnit"];
inline void Activate::clear_time_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_unit_.ClearToEmpty();
}
inline const std::string& Activate::time_unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Activate.time_unit)
  return _internal_time_unit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Activate::set_time_unit(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Activate.time_unit)
}
inline std::string* Activate::mutable_time_unit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_unit();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Activate.time_unit)
  return _s;
}
inline const std::string& Activate::_internal_time_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_unit_.Get();
}
inline void Activate::_internal_set_time_unit(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_unit_.Set(value, GetArena());
}
inline std::string* Activate::_internal_mutable_time_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_unit_.Mutable( GetArena());
}
inline std::string* Activate::release_time_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Activate.time_unit)
  return _impl_.time_unit_.Release();
}
inline void Activate::set_allocated_time_unit(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_unit_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.time_unit_.IsDefault()) {
    _impl_.time_unit_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Activate.time_unit)
}

// uint32 time_window = 4 [json_name = "timeWindow"];
inline void Activate::clear_time_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_window_ = 0u;
}
inline ::uint32_t Activate::time_window() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Activate.time_window)
  return _internal_time_window();
}
inline void Activate::set_time_window(::uint32_t value) {
  _internal_set_time_window(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Activate.time_window)
}
inline ::uint32_t Activate::_internal_time_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_window_;
}
inline void Activate::_internal_set_time_window(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_window_ = value;
}

// uint32 grace_period = 5 [json_name = "gracePeriod"];
inline void Activate::clear_grace_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grace_period_ = 0u;
}
inline ::uint32_t Activate::grace_period() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Activate.grace_period)
  return _internal_grace_period();
}
inline void Activate::set_grace_period(::uint32_t value) {
  _internal_set_grace_period(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Activate.grace_period)
}
inline ::uint32_t Activate::_internal_grace_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grace_period_;
}
inline void Activate::_internal_set_grace_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grace_period_ = value;
}

// -------------------------------------------------------------------

// Condition

// string type = 1 [json_name = "type"];
inline void Condition::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Condition::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Condition.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Condition::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Condition.type)
}
inline std::string* Condition::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Condition.type)
  return _s;
}
inline const std::string& Condition::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Condition::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Condition::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Condition::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Condition.type)
  return _impl_.type_.Release();
}
inline void Condition::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Condition.type)
}

// uint32 value = 2 [json_name = "value"];
inline void Condition::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0u;
}
inline ::uint32_t Condition::value() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Condition.value)
  return _internal_value();
}
inline void Condition::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Condition.value)
}
inline ::uint32_t Condition::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void Condition::_internal_set_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// string metric = 3 [json_name = "metric"];
inline void Condition::clear_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metric_.ClearToEmpty();
}
inline const std::string& Condition::metric() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Condition.metric)
  return _internal_metric();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Condition::set_metric(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metric_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Condition.metric)
}
inline std::string* Condition::mutable_metric() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metric();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Condition.metric)
  return _s;
}
inline const std::string& Condition::_internal_metric() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metric_.Get();
}
inline void Condition::_internal_set_metric(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metric_.Set(value, GetArena());
}
inline std::string* Condition::_internal_mutable_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metric_.Mutable( GetArena());
}
inline std::string* Condition::release_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Condition.metric)
  return _impl_.metric_.Release();
}
inline void Condition::set_allocated_metric(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metric_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.metric_.IsDefault()) {
    _impl_.metric_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Condition.metric)
}

// string operator = 4 [json_name = "operator"];
inline void Condition::clear_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.ClearToEmpty();
}
inline const std::string& Condition::operator_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Condition.operator)
  return _internal_operator_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Condition::set_operator_(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Condition.operator)
}
inline std::string* Condition::mutable_operator_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Condition.operator)
  return _s;
}
inline const std::string& Condition::_internal_operator_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operator__.Get();
}
inline void Condition::_internal_set_operator_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.Set(value, GetArena());
}
inline std::string* Condition::_internal_mutable_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operator__.Mutable( GetArena());
}
inline std::string* Condition::release_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Condition.operator)
  return _impl_.operator__.Release();
}
inline void Condition::set_allocated_operator_(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operator__.IsDefault()) {
    _impl_.operator__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Condition.operator)
}

// string value_type = 5 [json_name = "valueType"];
inline void Condition::clear_value_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_type_.ClearToEmpty();
}
inline const std::string& Condition::value_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Condition.value_type)
  return _internal_value_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Condition::set_value_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Condition.value_type)
}
inline std::string* Condition::mutable_value_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value_type();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Condition.value_type)
  return _s;
}
inline const std::string& Condition::_internal_value_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_type_.Get();
}
inline void Condition::_internal_set_value_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_type_.Set(value, GetArena());
}
inline std::string* Condition::_internal_mutable_value_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_type_.Mutable( GetArena());
}
inline std::string* Condition::release_value_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Condition.value_type)
  return _impl_.value_type_.Release();
}
inline void Condition::set_allocated_value_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_type_.IsDefault()) {
    _impl_.value_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Condition.value_type)
}

// string value_select = 6 [json_name = "valueSelect"];
inline void Condition::clear_value_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_select_.ClearToEmpty();
}
inline const std::string& Condition::value_select() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Condition.value_select)
  return _internal_value_select();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Condition::set_value_select(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_select_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Condition.value_select)
}
inline std::string* Condition::mutable_value_select() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value_select();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Condition.value_select)
  return _s;
}
inline const std::string& Condition::_internal_value_select() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_select_.Get();
}
inline void Condition::_internal_set_value_select(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_select_.Set(value, GetArena());
}
inline std::string* Condition::_internal_mutable_value_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_select_.Mutable( GetArena());
}
inline std::string* Condition::release_value_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Condition.value_select)
  return _impl_.value_select_.Release();
}
inline void Condition::set_allocated_value_select(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_select_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_select_.IsDefault()) {
    _impl_.value_select_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Condition.value_select)
}

// -------------------------------------------------------------------

// Mitigation

// uint64 id = 13 [json_name = "id"];
inline void Mitigation::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Mitigation::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.id)
  return _internal_id();
}
inline void Mitigation::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.id)
}
inline ::uint64_t Mitigation::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Mitigation::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string status = 1 [json_name = "status"];
inline void Mitigation::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& Mitigation::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mitigation::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.status)
}
inline std::string* Mitigation::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Mitigation.status)
  return _s;
}
inline const std::string& Mitigation::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void Mitigation::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* Mitigation::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* Mitigation::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Mitigation.status)
  return _impl_.status_.Release();
}
inline void Mitigation::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Mitigation.status)
}

// uint64 company_id = 2 [json_name = "companyId"];
inline void Mitigation::clear_company_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = ::uint64_t{0u};
}
inline ::uint64_t Mitigation::company_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.company_id)
  return _internal_company_id();
}
inline void Mitigation::set_company_id(::uint64_t value) {
  _internal_set_company_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.company_id)
}
inline ::uint64_t Mitigation::_internal_company_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.company_id_;
}
inline void Mitigation::_internal_set_company_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = value;
}

// uint64 pairing_id = 3 [json_name = "pairingId"];
inline void Mitigation::clear_pairing_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pairing_id_ = ::uint64_t{0u};
}
inline ::uint64_t Mitigation::pairing_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.pairing_id)
  return _internal_pairing_id();
}
inline void Mitigation::set_pairing_id(::uint64_t value) {
  _internal_set_pairing_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.pairing_id)
}
inline ::uint64_t Mitigation::_internal_pairing_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pairing_id_;
}
inline void Mitigation::_internal_set_pairing_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pairing_id_ = value;
}

// uint64 threshold_id = 4 [json_name = "thresholdId"];
inline void Mitigation::clear_threshold_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_id_ = ::uint64_t{0u};
}
inline ::uint64_t Mitigation::threshold_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.threshold_id)
  return _internal_threshold_id();
}
inline void Mitigation::set_threshold_id(::uint64_t value) {
  _internal_set_threshold_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.threshold_id)
}
inline ::uint64_t Mitigation::_internal_threshold_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threshold_id_;
}
inline void Mitigation::_internal_set_threshold_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_id_ = value;
}

// bool is_method_overridable = 5 [json_name = "isMethodOverridable"];
inline void Mitigation::clear_is_method_overridable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_method_overridable_ = false;
}
inline bool Mitigation::is_method_overridable() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.is_method_overridable)
  return _internal_is_method_overridable();
}
inline void Mitigation::set_is_method_overridable(bool value) {
  _internal_set_is_method_overridable(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.is_method_overridable)
}
inline bool Mitigation::_internal_is_method_overridable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_method_overridable_;
}
inline void Mitigation::_internal_set_is_method_overridable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_method_overridable_ = value;
}

// string mitigation_apply_type = 6 [json_name = "mitigationApplyType"];
inline void Mitigation::clear_mitigation_apply_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_apply_type_.ClearToEmpty();
}
inline const std::string& Mitigation::mitigation_apply_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_type)
  return _internal_mitigation_apply_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mitigation::set_mitigation_apply_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_apply_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_type)
}
inline std::string* Mitigation::mutable_mitigation_apply_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mitigation_apply_type();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_type)
  return _s;
}
inline const std::string& Mitigation::_internal_mitigation_apply_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mitigation_apply_type_.Get();
}
inline void Mitigation::_internal_set_mitigation_apply_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_apply_type_.Set(value, GetArena());
}
inline std::string* Mitigation::_internal_mutable_mitigation_apply_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mitigation_apply_type_.Mutable( GetArena());
}
inline std::string* Mitigation::release_mitigation_apply_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_type)
  return _impl_.mitigation_apply_type_.Release();
}
inline void Mitigation::set_allocated_mitigation_apply_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_apply_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mitigation_apply_type_.IsDefault()) {
    _impl_.mitigation_apply_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_type)
}

// string mitigation_clear_type = 7 [json_name = "mitigationClearType"];
inline void Mitigation::clear_mitigation_clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_clear_type_.ClearToEmpty();
}
inline const std::string& Mitigation::mitigation_clear_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_type)
  return _internal_mitigation_clear_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mitigation::set_mitigation_clear_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_clear_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_type)
}
inline std::string* Mitigation::mutable_mitigation_clear_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mitigation_clear_type();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_type)
  return _s;
}
inline const std::string& Mitigation::_internal_mitigation_clear_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mitigation_clear_type_.Get();
}
inline void Mitigation::_internal_set_mitigation_clear_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_clear_type_.Set(value, GetArena());
}
inline std::string* Mitigation::_internal_mutable_mitigation_clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mitigation_clear_type_.Mutable( GetArena());
}
inline std::string* Mitigation::release_mitigation_clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_type)
  return _impl_.mitigation_clear_type_.Release();
}
inline void Mitigation::set_allocated_mitigation_clear_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_clear_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mitigation_clear_type_.IsDefault()) {
    _impl_.mitigation_clear_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_type)
}

// uint32 mitigation_apply_timer = 8 [json_name = "mitigationApplyTimer"];
inline void Mitigation::clear_mitigation_apply_timer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_apply_timer_ = 0u;
}
inline ::uint32_t Mitigation::mitigation_apply_timer() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_timer)
  return _internal_mitigation_apply_timer();
}
inline void Mitigation::set_mitigation_apply_timer(::uint32_t value) {
  _internal_set_mitigation_apply_timer(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.mitigation_apply_timer)
}
inline ::uint32_t Mitigation::_internal_mitigation_apply_timer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mitigation_apply_timer_;
}
inline void Mitigation::_internal_set_mitigation_apply_timer(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_apply_timer_ = value;
}

// uint32 mitigation_clear_timer = 9 [json_name = "mitigationClearTimer"];
inline void Mitigation::clear_mitigation_clear_timer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_clear_timer_ = 0u;
}
inline ::uint32_t Mitigation::mitigation_clear_timer() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_timer)
  return _internal_mitigation_clear_timer();
}
inline void Mitigation::set_mitigation_clear_timer(::uint32_t value) {
  _internal_set_mitigation_clear_timer(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.mitigation_clear_timer)
}
inline ::uint32_t Mitigation::_internal_mitigation_clear_timer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mitigation_clear_timer_;
}
inline void Mitigation::_internal_set_mitigation_clear_timer(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mitigation_clear_timer_ = value;
}

// bool is_platform_overridable = 10 [json_name = "isPlatformOverridable"];
inline void Mitigation::clear_is_platform_overridable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_platform_overridable_ = false;
}
inline bool Mitigation::is_platform_overridable() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.is_platform_overridable)
  return _internal_is_platform_overridable();
}
inline void Mitigation::set_is_platform_overridable(bool value) {
  _internal_set_is_platform_overridable(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.is_platform_overridable)
}
inline bool Mitigation::_internal_is_platform_overridable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_platform_overridable_;
}
inline void Mitigation::_internal_set_is_platform_overridable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_platform_overridable_ = value;
}

// string cdate = 11 [json_name = "cdate"];
inline void Mitigation::clear_cdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cdate_.ClearToEmpty();
}
inline const std::string& Mitigation::cdate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.cdate)
  return _internal_cdate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mitigation::set_cdate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cdate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.cdate)
}
inline std::string* Mitigation::mutable_cdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cdate();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Mitigation.cdate)
  return _s;
}
inline const std::string& Mitigation::_internal_cdate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cdate_.Get();
}
inline void Mitigation::_internal_set_cdate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cdate_.Set(value, GetArena());
}
inline std::string* Mitigation::_internal_mutable_cdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cdate_.Mutable( GetArena());
}
inline std::string* Mitigation::release_cdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Mitigation.cdate)
  return _impl_.cdate_.Release();
}
inline void Mitigation::set_allocated_cdate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cdate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cdate_.IsDefault()) {
    _impl_.cdate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Mitigation.cdate)
}

// string edate = 12 [json_name = "edate"];
inline void Mitigation::clear_edate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.edate_.ClearToEmpty();
}
inline const std::string& Mitigation::edate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Mitigation.edate)
  return _internal_edate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mitigation::set_edate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.edate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Mitigation.edate)
}
inline std::string* Mitigation::mutable_edate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_edate();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Mitigation.edate)
  return _s;
}
inline const std::string& Mitigation::_internal_edate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.edate_.Get();
}
inline void Mitigation::_internal_set_edate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.edate_.Set(value, GetArena());
}
inline std::string* Mitigation::_internal_mutable_edate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.edate_.Mutable( GetArena());
}
inline std::string* Mitigation::release_edate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Mitigation.edate)
  return _impl_.edate_.Release();
}
inline void Mitigation::set_allocated_edate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.edate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.edate_.IsDefault()) {
    _impl_.edate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Mitigation.edate)
}

// -------------------------------------------------------------------

// NotificationChannel

// uint64 id = 1 [json_name = "id"];
inline void NotificationChannel::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t NotificationChannel::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.NotificationChannel.id)
  return _internal_id();
}
inline void NotificationChannel::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.NotificationChannel.id)
}
inline ::uint64_t NotificationChannel::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void NotificationChannel::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// User

// uint64 id = 1 [json_name = "id"];
inline void User::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t User::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.id)
  return _internal_id();
}
inline void User::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.id)
}
inline ::uint64_t User::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void User::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// uint64 company_id = 2 [json_name = "companyId"];
inline void User::clear_company_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = ::uint64_t{0u};
}
inline ::uint64_t User::company_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.company_id)
  return _internal_company_id();
}
inline void User::set_company_id(::uint64_t value) {
  _internal_set_company_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.company_id)
}
inline ::uint64_t User::_internal_company_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.company_id_;
}
inline void User::_internal_set_company_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = value;
}

// string user_email = 3 [json_name = "userEmail"];
inline void User::clear_user_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_email_.ClearToEmpty();
}
inline const std::string& User::user_email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.user_email)
  return _internal_user_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_user_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.user_email)
}
inline std::string* User::mutable_user_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_email();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.User.user_email)
  return _s;
}
inline const std::string& User::_internal_user_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_email_.Get();
}
inline void User::_internal_set_user_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_email_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_user_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_email_.Mutable( GetArena());
}
inline std::string* User::release_user_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.User.user_email)
  return _impl_.user_email_.Release();
}
inline void User::set_allocated_user_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_email_.IsDefault()) {
    _impl_.user_email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.User.user_email)
}

// string user_name = 4 [json_name = "userName"];
inline void User::clear_user_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& User::user_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.user_name)
  return _internal_user_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_user_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.user_name)
}
inline std::string* User::mutable_user_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.User.user_name)
  return _s;
}
inline const std::string& User::_internal_user_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_name_.Get();
}
inline void User::_internal_set_user_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_user_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_name_.Mutable( GetArena());
}
inline std::string* User::release_user_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.User.user_name)
  return _impl_.user_name_.Release();
}
inline void User::set_allocated_user_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.User.user_name)
}

// string user_full_name = 5 [json_name = "userFullName"];
inline void User::clear_user_full_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_full_name_.ClearToEmpty();
}
inline const std::string& User::user_full_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.user_full_name)
  return _internal_user_full_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_user_full_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_full_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.user_full_name)
}
inline std::string* User::mutable_user_full_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_full_name();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.User.user_full_name)
  return _s;
}
inline const std::string& User::_internal_user_full_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_full_name_.Get();
}
inline void User::_internal_set_user_full_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_full_name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_user_full_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_full_name_.Mutable( GetArena());
}
inline std::string* User::release_user_full_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.User.user_full_name)
  return _impl_.user_full_name_.Release();
}
inline void User::set_allocated_user_full_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_full_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_full_name_.IsDefault()) {
    _impl_.user_full_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.User.user_full_name)
}

// uint64 user_group_id = 6 [json_name = "userGroupId"];
inline void User::clear_user_group_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_group_id_ = ::uint64_t{0u};
}
inline ::uint64_t User::user_group_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.user_group_id)
  return _internal_user_group_id();
}
inline void User::set_user_group_id(::uint64_t value) {
  _internal_set_user_group_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.user_group_id)
}
inline ::uint64_t User::_internal_user_group_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_group_id_;
}
inline void User::_internal_set_user_group_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_group_id_ = value;
}

// string last_login = 7 [json_name = "lastLogin"];
inline void User::clear_last_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_login_.ClearToEmpty();
}
inline const std::string& User::last_login() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.last_login)
  return _internal_last_login();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_last_login(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_login_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.last_login)
}
inline std::string* User::mutable_last_login() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_login();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.User.last_login)
  return _s;
}
inline const std::string& User::_internal_last_login() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_login_.Get();
}
inline void User::_internal_set_last_login(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_login_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_last_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_login_.Mutable( GetArena());
}
inline std::string* User::release_last_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.User.last_login)
  return _impl_.last_login_.Release();
}
inline void User::set_allocated_last_login(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_login_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_login_.IsDefault()) {
    _impl_.last_login_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.User.last_login)
}

// bool permission_overrides = 8 [json_name = "permissionOverrides"];
inline void User::clear_permission_overrides() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permission_overrides_ = false;
}
inline bool User::permission_overrides() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.permission_overrides)
  return _internal_permission_overrides();
}
inline void User::set_permission_overrides(bool value) {
  _internal_set_permission_overrides(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.permission_overrides)
}
inline bool User::_internal_permission_overrides() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permission_overrides_;
}
inline void User::_internal_set_permission_overrides(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permission_overrides_ = value;
}

// string role = 9 [json_name = "role"];
inline void User::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.ClearToEmpty();
}
inline const std::string& User::role() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_role(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.role)
}
inline std::string* User::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.User.role)
  return _s;
}
inline const std::string& User::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_.Get();
}
inline void User::_internal_set_role(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.role_.Mutable( GetArena());
}
inline std::string* User::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.User.role)
  return _impl_.role_.Release();
}
inline void User::set_allocated_role(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.role_.IsDefault()) {
    _impl_.role_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.User.role)
}

// uint32 user_level = 10 [json_name = "userLevel"];
inline void User::clear_user_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_level_ = 0u;
}
inline ::uint32_t User::user_level() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.User.user_level)
  return _internal_user_level();
}
inline void User::set_user_level(::uint32_t value) {
  _internal_set_user_level(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.User.user_level)
}
inline ::uint32_t User::_internal_user_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_level_;
}
inline void User::_internal_set_user_level(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_level_ = value;
}

// -------------------------------------------------------------------

// TenantLink

// uint64 id = 1 [json_name = "id"];
inline void TenantLink::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t TenantLink::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.TenantLink.id)
  return _internal_id();
}
inline void TenantLink::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.TenantLink.id)
}
inline ::uint64_t TenantLink::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void TenantLink::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// uint64 pivot_template_id = 2 [json_name = "pivotTemplateId"];
inline void TenantLink::clear_pivot_template_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pivot_template_id_ = ::uint64_t{0u};
}
inline ::uint64_t TenantLink::pivot_template_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.TenantLink.pivot_template_id)
  return _internal_pivot_template_id();
}
inline void TenantLink::set_pivot_template_id(::uint64_t value) {
  _internal_set_pivot_template_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.TenantLink.pivot_template_id)
}
inline ::uint64_t TenantLink::_internal_pivot_template_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pivot_template_id_;
}
inline void TenantLink::_internal_set_pivot_template_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pivot_template_id_ = value;
}

// uint64 pivot_user_group_id = 3 [json_name = "pivotUserGroupId"];
inline void TenantLink::clear_pivot_user_group_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pivot_user_group_id_ = ::uint64_t{0u};
}
inline ::uint64_t TenantLink::pivot_user_group_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.TenantLink.pivot_user_group_id)
  return _internal_pivot_user_group_id();
}
inline void TenantLink::set_pivot_user_group_id(::uint64_t value) {
  _internal_set_pivot_user_group_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.TenantLink.pivot_user_group_id)
}
inline ::uint64_t TenantLink::_internal_pivot_user_group_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pivot_user_group_id_;
}
inline void TenantLink::_internal_set_pivot_user_group_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pivot_user_group_id_ = value;
}

// -------------------------------------------------------------------

// Package

// uint64 id = 1 [json_name = "id"];
inline void Package::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Package::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.id)
  return _internal_id();
}
inline void Package::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.id)
}
inline ::uint64_t Package::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Package::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// uint64 company_id = 2 [json_name = "companyId"];
inline void Package::clear_company_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = ::uint64_t{0u};
}
inline ::uint64_t Package::company_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.company_id)
  return _internal_company_id();
}
inline void Package::set_company_id(::uint64_t value) {
  _internal_set_company_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.company_id)
}
inline ::uint64_t Package::_internal_company_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.company_id_;
}
inline void Package::_internal_set_company_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = value;
}

// string name = 3 [json_name = "name"];
inline void Package::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Package::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Package::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.name)
}
inline std::string* Package::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.name)
  return _s;
}
inline const std::string& Package::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Package::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Package::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Package::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Package.name)
  return _impl_.name_.Release();
}
inline void Package::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Package.name)
}

// string description = 4 [json_name = "description"];
inline void Package::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Package::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Package::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.description)
}
inline std::string* Package::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.description)
  return _s;
}
inline const std::string& Package::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Package::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Package::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Package::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Package.description)
  return _impl_.description_.Release();
}
inline void Package::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Package.description)
}

// string icon = 5 [json_name = "icon"];
inline void Package::clear_icon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.icon_.ClearToEmpty();
}
inline const std::string& Package::icon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.icon)
  return _internal_icon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Package::set_icon(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.icon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.icon)
}
inline std::string* Package::mutable_icon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.icon)
  return _s;
}
inline const std::string& Package::_internal_icon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.icon_.Get();
}
inline void Package::_internal_set_icon(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.icon_.Set(value, GetArena());
}
inline std::string* Package::_internal_mutable_icon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.icon_.Mutable( GetArena());
}
inline std::string* Package::release_icon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Package.icon)
  return _impl_.icon_.Release();
}
inline void Package::set_allocated_icon(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.icon_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.icon_.IsDefault()) {
    _impl_.icon_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Package.icon)
}

// string color = 6 [json_name = "color"];
inline void Package::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& Package::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Package::set_color(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.color)
}
inline std::string* Package::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.color)
  return _s;
}
inline const std::string& Package::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_.Get();
}
inline void Package::_internal_set_color(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_.Set(value, GetArena());
}
inline std::string* Package::_internal_mutable_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* Package::release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Package.color)
  return _impl_.color_.Release();
}
inline void Package::set_allocated_color(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Package.color)
}

// repeated .kentik.mkp.v202102alpha1.Alert alerts = 7 [json_name = "alerts"];
inline int Package::_internal_alerts_size() const {
  return _internal_alerts().size();
}
inline int Package::alerts_size() const {
  return _internal_alerts_size();
}
inline void Package::clear_alerts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alerts_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Alert* Package::mutable_alerts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.alerts)
  return _internal_mutable_alerts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>* Package::mutable_alerts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Package.alerts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_alerts();
}
inline const ::kentik::mkp::v202102alpha1::Alert& Package::alerts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.alerts)
  return _internal_alerts().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Alert* Package::add_alerts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Alert* _add = _internal_mutable_alerts()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Package.alerts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>& Package::alerts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Package.alerts)
  return _internal_alerts();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>&
Package::_internal_alerts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alerts_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>*
Package::_internal_mutable_alerts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.alerts_;
}

// .kentik.mkp.v202102alpha1.Asset assets = 8 [json_name = "assets"];
inline bool Package::has_assets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.assets_ != nullptr);
  return value;
}
inline void Package::clear_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assets_ != nullptr) _impl_.assets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Asset& Package::_internal_assets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Asset* p = _impl_.assets_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Asset&>(::kentik::mkp::v202102alpha1::_Asset_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Asset& Package::assets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.assets)
  return _internal_assets();
}
inline void Package::unsafe_arena_set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.assets_);
  }
  _impl_.assets_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.Package.assets)
}
inline ::kentik::mkp::v202102alpha1::Asset* Package::release_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Asset* released = _impl_.assets_;
  _impl_.assets_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Asset* Package::unsafe_arena_release_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Package.assets)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Asset* temp = _impl_.assets_;
  _impl_.assets_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Asset* Package::_internal_mutable_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assets_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Asset>(GetArena());
    _impl_.assets_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset*>(p);
  }
  return _impl_.assets_;
}
inline ::kentik::mkp::v202102alpha1::Asset* Package::mutable_assets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Asset* _msg = _internal_mutable_assets();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.assets)
  return _msg;
}
inline void Package::set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.assets_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.assets_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Package.assets)
}

// bool is_default = 9 [json_name = "isDefault"];
inline void Package::clear_is_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = false;
}
inline bool Package::is_default() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.is_default)
  return _internal_is_default();
}
inline void Package::set_is_default(bool value) {
  _internal_set_is_default(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Package.is_default)
}
inline bool Package::_internal_is_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_default_;
}
inline void Package::_internal_set_is_default(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = value;
}

// repeated .kentik.mkp.v202102alpha1.TenantLink tenants = 10 [json_name = "tenants"];
inline int Package::_internal_tenants_size() const {
  return _internal_tenants().size();
}
inline int Package::tenants_size() const {
  return _internal_tenants_size();
}
inline void Package::clear_tenants() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tenants_.Clear();
}
inline ::kentik::mkp::v202102alpha1::TenantLink* Package::mutable_tenants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Package.tenants)
  return _internal_mutable_tenants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>* Package::mutable_tenants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Package.tenants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tenants();
}
inline const ::kentik::mkp::v202102alpha1::TenantLink& Package::tenants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Package.tenants)
  return _internal_tenants().Get(index);
}
inline ::kentik::mkp::v202102alpha1::TenantLink* Package::add_tenants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::TenantLink* _add = _internal_mutable_tenants()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Package.tenants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>& Package::tenants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Package.tenants)
  return _internal_tenants();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>&
Package::_internal_tenants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tenants_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::TenantLink>*
Package::_internal_mutable_tenants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tenants_;
}

// -------------------------------------------------------------------

// CustomDimension

// string dimension = 1 [json_name = "dimension"];
inline void CustomDimension::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_.ClearToEmpty();
}
inline const std::string& CustomDimension::dimension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.CustomDimension.dimension)
  return _internal_dimension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomDimension::set_dimension(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.CustomDimension.dimension)
}
inline std::string* CustomDimension::mutable_dimension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.CustomDimension.dimension)
  return _s;
}
inline const std::string& CustomDimension::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dimension_.Get();
}
inline void CustomDimension::_internal_set_dimension(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_.Set(value, GetArena());
}
inline std::string* CustomDimension::_internal_mutable_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dimension_.Mutable( GetArena());
}
inline std::string* CustomDimension::release_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.CustomDimension.dimension)
  return _impl_.dimension_.Release();
}
inline void CustomDimension::set_allocated_dimension(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dimension_.IsDefault()) {
    _impl_.dimension_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.CustomDimension.dimension)
}

// string populator = 2 [json_name = "populator"];
inline void CustomDimension::clear_populator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.populator_.ClearToEmpty();
}
inline const std::string& CustomDimension::populator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.CustomDimension.populator)
  return _internal_populator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomDimension::set_populator(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.populator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.CustomDimension.populator)
}
inline std::string* CustomDimension::mutable_populator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_populator();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.CustomDimension.populator)
  return _s;
}
inline const std::string& CustomDimension::_internal_populator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.populator_.Get();
}
inline void CustomDimension::_internal_set_populator(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.populator_.Set(value, GetArena());
}
inline std::string* CustomDimension::_internal_mutable_populator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.populator_.Mutable( GetArena());
}
inline std::string* CustomDimension::release_populator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.CustomDimension.populator)
  return _impl_.populator_.Release();
}
inline void CustomDimension::set_allocated_populator(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.populator_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.populator_.IsDefault()) {
    _impl_.populator_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.CustomDimension.populator)
}

// -------------------------------------------------------------------

// Device

// bool all_devices = 1 [json_name = "allDevices"];
inline void Device::clear_all_devices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_devices_ = false;
}
inline bool Device::all_devices() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Device.all_devices)
  return _internal_all_devices();
}
inline void Device::set_all_devices(bool value) {
  _internal_set_all_devices(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Device.all_devices)
}
inline bool Device::_internal_all_devices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_devices_;
}
inline void Device::_internal_set_all_devices(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_devices_ = value;
}

// repeated string device_types = 2 [json_name = "deviceTypes"];
inline int Device::_internal_device_types_size() const {
  return _internal_device_types().size();
}
inline int Device::device_types_size() const {
  return _internal_device_types_size();
}
inline void Device::clear_device_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_types_.Clear();
}
inline std::string* Device::add_device_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_device_types()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.mkp.v202102alpha1.Device.device_types)
  return _s;
}
inline const std::string& Device::device_types(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Device.device_types)
  return _internal_device_types().Get(index);
}
inline std::string* Device::mutable_device_types(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Device.device_types)
  return _internal_mutable_device_types()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Device::set_device_types(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_device_types()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Device.device_types)
}
template <typename Arg_, typename... Args_>
inline void Device::add_device_types(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_device_types(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Device.device_types)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Device::device_types() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Device.device_types)
  return _internal_device_types();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Device::mutable_device_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Device.device_types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_types();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Device::_internal_device_types() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_types_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Device::_internal_mutable_device_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_types_;
}

// repeated uint32 device_labels = 3 [json_name = "deviceLabels"];
inline int Device::_internal_device_labels_size() const {
  return _internal_device_labels().size();
}
inline int Device::device_labels_size() const {
  return _internal_device_labels_size();
}
inline void Device::clear_device_labels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_labels_.Clear();
}
inline ::uint32_t Device::device_labels(int index) const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Device.device_labels)
  return _internal_device_labels().Get(index);
}
inline void Device::set_device_labels(int index, ::uint32_t value) {
  _internal_mutable_device_labels()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Device.device_labels)
}
inline void Device::add_device_labels(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_device_labels()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Device.device_labels)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Device::device_labels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Device.device_labels)
  return _internal_device_labels();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Device::mutable_device_labels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Device.device_labels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_labels();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Device::_internal_device_labels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_labels_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Device::_internal_mutable_device_labels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_labels_;
}

// repeated uint32 device_sites = 4 [json_name = "deviceSites"];
inline int Device::_internal_device_sites_size() const {
  return _internal_device_sites().size();
}
inline int Device::device_sites_size() const {
  return _internal_device_sites_size();
}
inline void Device::clear_device_sites() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_sites_.Clear();
}
inline ::uint32_t Device::device_sites(int index) const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Device.device_sites)
  return _internal_device_sites().Get(index);
}
inline void Device::set_device_sites(int index, ::uint32_t value) {
  _internal_mutable_device_sites()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Device.device_sites)
}
inline void Device::add_device_sites(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_device_sites()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Device.device_sites)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Device::device_sites() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Device.device_sites)
  return _internal_device_sites();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Device::mutable_device_sites()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Device.device_sites)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_sites();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Device::_internal_device_sites() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_sites_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Device::_internal_mutable_device_sites() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_sites_;
}

// repeated string device_name = 5 [json_name = "deviceName"];
inline int Device::_internal_device_name_size() const {
  return _internal_device_name().size();
}
inline int Device::device_name_size() const {
  return _internal_device_name_size();
}
inline void Device::clear_device_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_name_.Clear();
}
inline std::string* Device::add_device_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_device_name()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.mkp.v202102alpha1.Device.device_name)
  return _s;
}
inline const std::string& Device::device_name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Device.device_name)
  return _internal_device_name().Get(index);
}
inline std::string* Device::mutable_device_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Device.device_name)
  return _internal_mutable_device_name()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Device::set_device_name(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_device_name()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Device.device_name)
}
template <typename Arg_, typename... Args_>
inline void Device::add_device_name(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_device_name(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Device.device_name)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Device::device_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Device.device_name)
  return _internal_device_name();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Device::mutable_device_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Device.device_name)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_name();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Device::_internal_device_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_name_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Device::_internal_mutable_device_name() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_name_;
}

// -------------------------------------------------------------------

// FilterField

// string filter_field = 1 [json_name = "filterField"];
inline void FilterField::clear_filter_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_field_.ClearToEmpty();
}
inline const std::string& FilterField::filter_field() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.FilterField.filter_field)
  return _internal_filter_field();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FilterField::set_filter_field(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_field_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.FilterField.filter_field)
}
inline std::string* FilterField::mutable_filter_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filter_field();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.FilterField.filter_field)
  return _s;
}
inline const std::string& FilterField::_internal_filter_field() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_field_.Get();
}
inline void FilterField::_internal_set_filter_field(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_field_.Set(value, GetArena());
}
inline std::string* FilterField::_internal_mutable_filter_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filter_field_.Mutable( GetArena());
}
inline std::string* FilterField::release_filter_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.FilterField.filter_field)
  return _impl_.filter_field_.Release();
}
inline void FilterField::set_allocated_filter_field(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_field_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filter_field_.IsDefault()) {
    _impl_.filter_field_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.FilterField.filter_field)
}

// string operator = 2 [json_name = "operator"];
inline void FilterField::clear_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.ClearToEmpty();
}
inline const std::string& FilterField::operator_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.FilterField.operator)
  return _internal_operator_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FilterField::set_operator_(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.FilterField.operator)
}
inline std::string* FilterField::mutable_operator_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.FilterField.operator)
  return _s;
}
inline const std::string& FilterField::_internal_operator_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operator__.Get();
}
inline void FilterField::_internal_set_operator_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.Set(value, GetArena());
}
inline std::string* FilterField::_internal_mutable_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operator__.Mutable( GetArena());
}
inline std::string* FilterField::release_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.FilterField.operator)
  return _impl_.operator__.Release();
}
inline void FilterField::set_allocated_operator_(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operator__.IsDefault()) {
    _impl_.operator__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.FilterField.operator)
}

// string filter_value = 3 [json_name = "filterValue"];
inline void FilterField::clear_filter_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_value_.ClearToEmpty();
}
inline const std::string& FilterField::filter_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.FilterField.filter_value)
  return _internal_filter_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FilterField::set_filter_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.FilterField.filter_value)
}
inline std::string* FilterField::mutable_filter_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filter_value();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.FilterField.filter_value)
  return _s;
}
inline const std::string& FilterField::_internal_filter_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_value_.Get();
}
inline void FilterField::_internal_set_filter_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_value_.Set(value, GetArena());
}
inline std::string* FilterField::_internal_mutable_filter_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filter_value_.Mutable( GetArena());
}
inline std::string* FilterField::release_filter_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.FilterField.filter_value)
  return _impl_.filter_value_.Release();
}
inline void FilterField::set_allocated_filter_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filter_value_.IsDefault()) {
    _impl_.filter_value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.FilterField.filter_value)
}

// -------------------------------------------------------------------

// Filter

// string name = 1 [json_name = "name"];
inline void Filter::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Filter::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Filter::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.name)
}
inline std::string* Filter::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.name)
  return _s;
}
inline const std::string& Filter::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Filter::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Filter::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Filter::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Filter.name)
  return _impl_.name_.Release();
}
inline void Filter::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Filter.name)
}

// bool named = 2 [json_name = "named"];
inline void Filter::clear_named() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.named_ = false;
}
inline bool Filter::named() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.named)
  return _internal_named();
}
inline void Filter::set_named(bool value) {
  _internal_set_named(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.named)
}
inline bool Filter::_internal_named() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.named_;
}
inline void Filter::_internal_set_named(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.named_ = value;
}

// string connector = 3 [json_name = "connector"];
inline void Filter::clear_connector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connector_.ClearToEmpty();
}
inline const std::string& Filter::connector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.connector)
  return _internal_connector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Filter::set_connector(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connector_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.connector)
}
inline std::string* Filter::mutable_connector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connector();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.connector)
  return _s;
}
inline const std::string& Filter::_internal_connector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connector_.Get();
}
inline void Filter::_internal_set_connector(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connector_.Set(value, GetArena());
}
inline std::string* Filter::_internal_mutable_connector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connector_.Mutable( GetArena());
}
inline std::string* Filter::release_connector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Filter.connector)
  return _impl_.connector_.Release();
}
inline void Filter::set_allocated_connector(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connector_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connector_.IsDefault()) {
    _impl_.connector_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Filter.connector)
}

// bool not = 4 [json_name = "not"];
inline void Filter::clear_not_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not__ = false;
}
inline bool Filter::not_() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.not)
  return _internal_not_();
}
inline void Filter::set_not_(bool value) {
  _internal_set_not_(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.not)
}
inline bool Filter::_internal_not_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not__;
}
inline void Filter::_internal_set_not_(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not__ = value;
}

// string auto_added = 5 [json_name = "autoAdded"];
inline void Filter::clear_auto_added() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_added_.ClearToEmpty();
}
inline const std::string& Filter::auto_added() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.auto_added)
  return _internal_auto_added();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Filter::set_auto_added(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_added_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.auto_added)
}
inline std::string* Filter::mutable_auto_added() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auto_added();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.auto_added)
  return _s;
}
inline const std::string& Filter::_internal_auto_added() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_added_.Get();
}
inline void Filter::_internal_set_auto_added(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_added_.Set(value, GetArena());
}
inline std::string* Filter::_internal_mutable_auto_added() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.auto_added_.Mutable( GetArena());
}
inline std::string* Filter::release_auto_added() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Filter.auto_added)
  return _impl_.auto_added_.Release();
}
inline void Filter::set_allocated_auto_added(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_added_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.auto_added_.IsDefault()) {
    _impl_.auto_added_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Filter.auto_added)
}

// repeated string saved_filters = 6 [json_name = "savedFilters"];
inline int Filter::_internal_saved_filters_size() const {
  return _internal_saved_filters().size();
}
inline int Filter::saved_filters_size() const {
  return _internal_saved_filters_size();
}
inline void Filter::clear_saved_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saved_filters_.Clear();
}
inline std::string* Filter::add_saved_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_saved_filters()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.mkp.v202102alpha1.Filter.saved_filters)
  return _s;
}
inline const std::string& Filter::saved_filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.saved_filters)
  return _internal_saved_filters().Get(index);
}
inline std::string* Filter::mutable_saved_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.saved_filters)
  return _internal_mutable_saved_filters()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Filter::set_saved_filters(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_saved_filters()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.saved_filters)
}
template <typename Arg_, typename... Args_>
inline void Filter::add_saved_filters(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_saved_filters(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Filter.saved_filters)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Filter::saved_filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Filter.saved_filters)
  return _internal_saved_filters();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Filter::mutable_saved_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Filter.saved_filters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_saved_filters();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Filter::_internal_saved_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saved_filters_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Filter::_internal_mutable_saved_filters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.saved_filters_;
}

// repeated .kentik.mkp.v202102alpha1.FilterField filters = 7 [json_name = "filters"];
inline int Filter::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int Filter::filters_size() const {
  return _internal_filters_size();
}
inline void Filter::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filters_.Clear();
}
inline ::kentik::mkp::v202102alpha1::FilterField* Filter::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.filters)
  return _internal_mutable_filters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>* Filter::mutable_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Filter.filters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_filters();
}
inline const ::kentik::mkp::v202102alpha1::FilterField& Filter::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.filters)
  return _internal_filters().Get(index);
}
inline ::kentik::mkp::v202102alpha1::FilterField* Filter::add_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::FilterField* _add = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Filter.filters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>& Filter::filters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Filter.filters)
  return _internal_filters();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>&
Filter::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::FilterField>*
Filter::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.filters_;
}

// repeated .kentik.mkp.v202102alpha1.Filter filter_groups = 8 [json_name = "filterGroups"];
inline int Filter::_internal_filter_groups_size() const {
  return _internal_filter_groups().size();
}
inline int Filter::filter_groups_size() const {
  return _internal_filter_groups_size();
}
inline void Filter::clear_filter_groups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_groups_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Filter* Filter::mutable_filter_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.filter_groups)
  return _internal_mutable_filter_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>* Filter::mutable_filter_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Filter.filter_groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_filter_groups();
}
inline const ::kentik::mkp::v202102alpha1::Filter& Filter::filter_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.filter_groups)
  return _internal_filter_groups().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Filter* Filter::add_filter_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Filter* _add = _internal_mutable_filter_groups()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Filter.filter_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>& Filter::filter_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Filter.filter_groups)
  return _internal_filter_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>&
Filter::_internal_filter_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Filter>*
Filter::_internal_mutable_filter_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.filter_groups_;
}

// repeated string metric = 9 [json_name = "metric"];
inline int Filter::_internal_metric_size() const {
  return _internal_metric().size();
}
inline int Filter::metric_size() const {
  return _internal_metric_size();
}
inline void Filter::clear_metric() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metric_.Clear();
}
inline std::string* Filter::add_metric() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_metric()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.mkp.v202102alpha1.Filter.metric)
  return _s;
}
inline const std::string& Filter::metric(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Filter.metric)
  return _internal_metric().Get(index);
}
inline std::string* Filter::mutable_metric(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Filter.metric)
  return _internal_mutable_metric()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Filter::set_metric(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_metric()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Filter.metric)
}
template <typename Arg_, typename... Args_>
inline void Filter::add_metric(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_metric(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Filter.metric)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Filter::metric() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Filter.metric)
  return _internal_metric();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Filter::mutable_metric() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Filter.metric)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_metric();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Filter::_internal_metric() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metric_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Filter::_internal_mutable_metric() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.metric_;
}

// -------------------------------------------------------------------

// Tenant

// uint64 id = 1 [json_name = "id"];
inline void Tenant::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Tenant::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.id)
  return _internal_id();
}
inline void Tenant::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.id)
}
inline ::uint64_t Tenant::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Tenant::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// uint64 company_id = 2 [json_name = "companyId"];
inline void Tenant::clear_company_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = ::uint64_t{0u};
}
inline ::uint64_t Tenant::company_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.company_id)
  return _internal_company_id();
}
inline void Tenant::set_company_id(::uint64_t value) {
  _internal_set_company_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.company_id)
}
inline ::uint64_t Tenant::_internal_company_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.company_id_;
}
inline void Tenant::_internal_set_company_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_id_ = value;
}

// string name = 3 [json_name = "name"];
inline void Tenant::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Tenant::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.name)
}
inline std::string* Tenant::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.name)
  return _s;
}
inline const std::string& Tenant::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Tenant::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Tenant::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.name)
  return _impl_.name_.Release();
}
inline void Tenant::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.name)
}

// string description = 4 [json_name = "description"];
inline void Tenant::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Tenant::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.description)
}
inline std::string* Tenant::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.description)
  return _s;
}
inline const std::string& Tenant::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Tenant::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Tenant::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.description)
  return _impl_.description_.Release();
}
inline void Tenant::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.description)
}

// string type = 5 [json_name = "type"];
inline void Tenant::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Tenant::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.type)
}
inline std::string* Tenant::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.type)
  return _s;
}
inline const std::string& Tenant::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Tenant::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Tenant::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.type)
  return _impl_.type_.Release();
}
inline void Tenant::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.type)
}

// bool enabled = 6 [json_name = "enabled"];
inline void Tenant::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
}
inline bool Tenant::enabled() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.enabled)
  return _internal_enabled();
}
inline void Tenant::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.enabled)
}
inline bool Tenant::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void Tenant::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// repeated .kentik.mkp.v202102alpha1.Alert alerts = 7 [json_name = "alerts"];
inline int Tenant::_internal_alerts_size() const {
  return _internal_alerts().size();
}
inline int Tenant::alerts_size() const {
  return _internal_alerts_size();
}
inline void Tenant::clear_alerts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alerts_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Alert* Tenant::mutable_alerts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.alerts)
  return _internal_mutable_alerts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>* Tenant::mutable_alerts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Tenant.alerts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_alerts();
}
inline const ::kentik::mkp::v202102alpha1::Alert& Tenant::alerts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.alerts)
  return _internal_alerts().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Alert* Tenant::add_alerts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Alert* _add = _internal_mutable_alerts()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Tenant.alerts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>& Tenant::alerts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Tenant.alerts)
  return _internal_alerts();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>&
Tenant::_internal_alerts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alerts_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Alert>*
Tenant::_internal_mutable_alerts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.alerts_;
}

// .kentik.mkp.v202102alpha1.Asset assets = 15 [json_name = "assets"];
inline bool Tenant::has_assets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.assets_ != nullptr);
  return value;
}
inline void Tenant::clear_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assets_ != nullptr) _impl_.assets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::mkp::v202102alpha1::Asset& Tenant::_internal_assets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Asset* p = _impl_.assets_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Asset&>(::kentik::mkp::v202102alpha1::_Asset_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Asset& Tenant::assets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.assets)
  return _internal_assets();
}
inline void Tenant::unsafe_arena_set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.assets_);
  }
  _impl_.assets_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.Tenant.assets)
}
inline ::kentik::mkp::v202102alpha1::Asset* Tenant::release_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::mkp::v202102alpha1::Asset* released = _impl_.assets_;
  _impl_.assets_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Asset* Tenant::unsafe_arena_release_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.assets)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::mkp::v202102alpha1::Asset* temp = _impl_.assets_;
  _impl_.assets_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Asset* Tenant::_internal_mutable_assets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assets_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Asset>(GetArena());
    _impl_.assets_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset*>(p);
  }
  return _impl_.assets_;
}
inline ::kentik::mkp::v202102alpha1::Asset* Tenant::mutable_assets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::mkp::v202102alpha1::Asset* _msg = _internal_mutable_assets();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.assets)
  return _msg;
}
inline void Tenant::set_allocated_assets(::kentik::mkp::v202102alpha1::Asset* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.assets_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.assets_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Asset*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.assets)
}

// string asn = 8 [json_name = "asn"];
inline void Tenant::clear_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_.ClearToEmpty();
}
inline const std::string& Tenant::asn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.asn)
  return _internal_asn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_asn(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.asn)
}
inline std::string* Tenant::mutable_asn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_asn();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.asn)
  return _s;
}
inline const std::string& Tenant::_internal_asn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn_.Get();
}
inline void Tenant::_internal_set_asn(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.asn_.Mutable( GetArena());
}
inline std::string* Tenant::release_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.asn)
  return _impl_.asn_.Release();
}
inline void Tenant::set_allocated_asn(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.asn_.IsDefault()) {
    _impl_.asn_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.asn)
}

// string cidr = 9 [json_name = "cidr"];
inline void Tenant::clear_cidr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cidr_.ClearToEmpty();
}
inline const std::string& Tenant::cidr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.cidr)
  return _internal_cidr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_cidr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cidr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.cidr)
}
inline std::string* Tenant::mutable_cidr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cidr();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.cidr)
  return _s;
}
inline const std::string& Tenant::_internal_cidr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cidr_.Get();
}
inline void Tenant::_internal_set_cidr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cidr_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_cidr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cidr_.Mutable( GetArena());
}
inline std::string* Tenant::release_cidr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.cidr)
  return _impl_.cidr_.Release();
}
inline void Tenant::set_allocated_cidr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cidr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cidr_.IsDefault()) {
    _impl_.cidr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.cidr)
}

// repeated .kentik.mkp.v202102alpha1.CustomDimension custom_dimensions = 10 [json_name = "customDimensions"];
inline int Tenant::_internal_custom_dimensions_size() const {
  return _internal_custom_dimensions().size();
}
inline int Tenant::custom_dimensions_size() const {
  return _internal_custom_dimensions_size();
}
inline void Tenant::clear_custom_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custom_dimensions_.Clear();
}
inline ::kentik::mkp::v202102alpha1::CustomDimension* Tenant::mutable_custom_dimensions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.custom_dimensions)
  return _internal_mutable_custom_dimensions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>* Tenant::mutable_custom_dimensions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Tenant.custom_dimensions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_custom_dimensions();
}
inline const ::kentik::mkp::v202102alpha1::CustomDimension& Tenant::custom_dimensions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.custom_dimensions)
  return _internal_custom_dimensions().Get(index);
}
inline ::kentik::mkp::v202102alpha1::CustomDimension* Tenant::add_custom_dimensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::CustomDimension* _add = _internal_mutable_custom_dimensions()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Tenant.custom_dimensions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>& Tenant::custom_dimensions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Tenant.custom_dimensions)
  return _internal_custom_dimensions();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>&
Tenant::_internal_custom_dimensions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.custom_dimensions_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::CustomDimension>*
Tenant::_internal_mutable_custom_dimensions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.custom_dimensions_;
}

// .kentik.mkp.v202102alpha1.Device devices = 11 [json_name = "devices"];
inline bool Tenant::has_devices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.devices_ != nullptr);
  return value;
}
inline void Tenant::clear_devices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.devices_ != nullptr) _impl_.devices_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Device& Tenant::_internal_devices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Device* p = _impl_.devices_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Device&>(::kentik::mkp::v202102alpha1::_Device_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Device& Tenant::devices() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.devices)
  return _internal_devices();
}
inline void Tenant::unsafe_arena_set_allocated_devices(::kentik::mkp::v202102alpha1::Device* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.devices_);
  }
  _impl_.devices_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Device*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.Tenant.devices)
}
inline ::kentik::mkp::v202102alpha1::Device* Tenant::release_devices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Device* released = _impl_.devices_;
  _impl_.devices_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Device* Tenant::unsafe_arena_release_devices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.devices)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Device* temp = _impl_.devices_;
  _impl_.devices_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Device* Tenant::_internal_mutable_devices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.devices_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Device>(GetArena());
    _impl_.devices_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Device*>(p);
  }
  return _impl_.devices_;
}
inline ::kentik::mkp::v202102alpha1::Device* Tenant::mutable_devices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Device* _msg = _internal_mutable_devices();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.devices)
  return _msg;
}
inline void Tenant::set_allocated_devices(::kentik::mkp::v202102alpha1::Device* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.devices_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.devices_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Device*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.devices)
}

// .kentik.mkp.v202102alpha1.Filter filters = 12 [json_name = "filters"];
inline bool Tenant::has_filters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filters_ != nullptr);
  return value;
}
inline void Tenant::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filters_ != nullptr) _impl_.filters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::mkp::v202102alpha1::Filter& Tenant::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Filter* p = _impl_.filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Filter&>(::kentik::mkp::v202102alpha1::_Filter_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Filter& Tenant::filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.filters)
  return _internal_filters();
}
inline void Tenant::unsafe_arena_set_allocated_filters(::kentik::mkp::v202102alpha1::Filter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filters_);
  }
  _impl_.filters_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Filter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.Tenant.filters)
}
inline ::kentik::mkp::v202102alpha1::Filter* Tenant::release_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::mkp::v202102alpha1::Filter* released = _impl_.filters_;
  _impl_.filters_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Filter* Tenant::unsafe_arena_release_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.filters)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::mkp::v202102alpha1::Filter* temp = _impl_.filters_;
  _impl_.filters_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Filter* Tenant::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Filter>(GetArena());
    _impl_.filters_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Filter*>(p);
  }
  return _impl_.filters_;
}
inline ::kentik::mkp::v202102alpha1::Filter* Tenant::mutable_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::mkp::v202102alpha1::Filter* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.filters)
  return _msg;
}
inline void Tenant::set_allocated_filters(::kentik::mkp::v202102alpha1::Filter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.filters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.filters_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.filters)
}

// string interface_name = 13 [json_name = "interfaceName"];
inline void Tenant::clear_interface_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interface_name_.ClearToEmpty();
}
inline const std::string& Tenant::interface_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.interface_name)
  return _internal_interface_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_interface_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interface_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.interface_name)
}
inline std::string* Tenant::mutable_interface_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interface_name();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.interface_name)
  return _s;
}
inline const std::string& Tenant::_internal_interface_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.interface_name_.Get();
}
inline void Tenant::_internal_set_interface_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interface_name_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_interface_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.interface_name_.Mutable( GetArena());
}
inline std::string* Tenant::release_interface_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.interface_name)
  return _impl_.interface_name_.Release();
}
inline void Tenant::set_allocated_interface_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.interface_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.interface_name_.IsDefault()) {
    _impl_.interface_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.interface_name)
}

// string snmp_alias = 14 [json_name = "snmpAlias"];
inline void Tenant::clear_snmp_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snmp_alias_.ClearToEmpty();
}
inline const std::string& Tenant::snmp_alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.snmp_alias)
  return _internal_snmp_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tenant::set_snmp_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snmp_alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.snmp_alias)
}
inline std::string* Tenant::mutable_snmp_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_snmp_alias();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.snmp_alias)
  return _s;
}
inline const std::string& Tenant::_internal_snmp_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snmp_alias_.Get();
}
inline void Tenant::_internal_set_snmp_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snmp_alias_.Set(value, GetArena());
}
inline std::string* Tenant::_internal_mutable_snmp_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.snmp_alias_.Mutable( GetArena());
}
inline std::string* Tenant::release_snmp_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.Tenant.snmp_alias)
  return _impl_.snmp_alias_.Release();
}
inline void Tenant::set_allocated_snmp_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snmp_alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.snmp_alias_.IsDefault()) {
    _impl_.snmp_alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.Tenant.snmp_alias)
}

// repeated .kentik.mkp.v202102alpha1.Package packages = 16 [json_name = "packages"];
inline int Tenant::_internal_packages_size() const {
  return _internal_packages().size();
}
inline int Tenant::packages_size() const {
  return _internal_packages_size();
}
inline void Tenant::clear_packages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packages_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Package* Tenant::mutable_packages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.packages)
  return _internal_mutable_packages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>* Tenant::mutable_packages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Tenant.packages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_packages();
}
inline const ::kentik::mkp::v202102alpha1::Package& Tenant::packages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.packages)
  return _internal_packages().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Package* Tenant::add_packages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Package* _add = _internal_mutable_packages()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Tenant.packages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>& Tenant::packages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Tenant.packages)
  return _internal_packages();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>&
Tenant::_internal_packages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packages_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>*
Tenant::_internal_mutable_packages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.packages_;
}

// repeated .kentik.mkp.v202102alpha1.User users = 17 [json_name = "users"];
inline int Tenant::_internal_users_size() const {
  return _internal_users().size();
}
inline int Tenant::users_size() const {
  return _internal_users_size();
}
inline void Tenant::clear_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.users_.Clear();
}
inline ::kentik::mkp::v202102alpha1::User* Tenant::mutable_users(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.Tenant.users)
  return _internal_mutable_users()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>* Tenant::mutable_users()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.Tenant.users)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_users();
}
inline const ::kentik::mkp::v202102alpha1::User& Tenant::users(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.users)
  return _internal_users().Get(index);
}
inline ::kentik::mkp::v202102alpha1::User* Tenant::add_users() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::User* _add = _internal_mutable_users()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.Tenant.users)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>& Tenant::users() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.Tenant.users)
  return _internal_users();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>&
Tenant::_internal_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.users_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::User>*
Tenant::_internal_mutable_users() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.users_;
}

// uint32 template_id = 18 [json_name = "templateId"];
inline void Tenant::clear_template_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.template_id_ = 0u;
}
inline ::uint32_t Tenant::template_id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.Tenant.template_id)
  return _internal_template_id();
}
inline void Tenant::set_template_id(::uint32_t value) {
  _internal_set_template_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.Tenant.template_id)
}
inline ::uint32_t Tenant::_internal_template_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.template_id_;
}
inline void Tenant::_internal_set_template_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.template_id_ = value;
}

// -------------------------------------------------------------------

// ListPackageRequest

// -------------------------------------------------------------------

// ListPackageResponse

// repeated .kentik.mkp.v202102alpha1.Package packages = 1 [json_name = "packages"];
inline int ListPackageResponse::_internal_packages_size() const {
  return _internal_packages().size();
}
inline int ListPackageResponse::packages_size() const {
  return _internal_packages_size();
}
inline void ListPackageResponse::clear_packages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packages_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Package* ListPackageResponse::mutable_packages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.ListPackageResponse.packages)
  return _internal_mutable_packages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>* ListPackageResponse::mutable_packages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.ListPackageResponse.packages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_packages();
}
inline const ::kentik::mkp::v202102alpha1::Package& ListPackageResponse::packages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.ListPackageResponse.packages)
  return _internal_packages().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Package* ListPackageResponse::add_packages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Package* _add = _internal_mutable_packages()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.ListPackageResponse.packages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>& ListPackageResponse::packages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.ListPackageResponse.packages)
  return _internal_packages();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>&
ListPackageResponse::_internal_packages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packages_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Package>*
ListPackageResponse::_internal_mutable_packages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.packages_;
}

// uint32 invalid_count = 2 [json_name = "invalidCount"];
inline void ListPackageResponse::clear_invalid_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_count_ = 0u;
}
inline ::uint32_t ListPackageResponse::invalid_count() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.ListPackageResponse.invalid_count)
  return _internal_invalid_count();
}
inline void ListPackageResponse::set_invalid_count(::uint32_t value) {
  _internal_set_invalid_count(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.ListPackageResponse.invalid_count)
}
inline ::uint32_t ListPackageResponse::_internal_invalid_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invalid_count_;
}
inline void ListPackageResponse::_internal_set_invalid_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_count_ = value;
}

// -------------------------------------------------------------------

// GetPackageRequest

// uint64 id = 1 [json_name = "id"];
inline void GetPackageRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t GetPackageRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.GetPackageRequest.id)
  return _internal_id();
}
inline void GetPackageRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.GetPackageRequest.id)
}
inline ::uint64_t GetPackageRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void GetPackageRequest::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// GetPackageResponse

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool GetPackageResponse::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void GetPackageResponse::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& GetPackageResponse::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& GetPackageResponse::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.GetPackageResponse.package)
  return _internal_package();
}
inline void GetPackageResponse::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.GetPackageResponse.package)
}
inline ::kentik::mkp::v202102alpha1::Package* GetPackageResponse::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* GetPackageResponse::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.GetPackageResponse.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* GetPackageResponse::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* GetPackageResponse::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.GetPackageResponse.package)
  return _msg;
}
inline void GetPackageResponse::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.GetPackageResponse.package)
}

// -------------------------------------------------------------------

// CreatePackageRequest

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool CreatePackageRequest::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void CreatePackageRequest::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& CreatePackageRequest::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& CreatePackageRequest::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.CreatePackageRequest.package)
  return _internal_package();
}
inline void CreatePackageRequest::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.CreatePackageRequest.package)
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageRequest::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageRequest::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.CreatePackageRequest.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageRequest::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageRequest::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.CreatePackageRequest.package)
  return _msg;
}
inline void CreatePackageRequest::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.CreatePackageRequest.package)
}

// -------------------------------------------------------------------

// CreatePackageResponse

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool CreatePackageResponse::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void CreatePackageResponse::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& CreatePackageResponse::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& CreatePackageResponse::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.CreatePackageResponse.package)
  return _internal_package();
}
inline void CreatePackageResponse::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.CreatePackageResponse.package)
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageResponse::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageResponse::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.CreatePackageResponse.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageResponse::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* CreatePackageResponse::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.CreatePackageResponse.package)
  return _msg;
}
inline void CreatePackageResponse::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.CreatePackageResponse.package)
}

// -------------------------------------------------------------------

// UpdatePackageRequest

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool UpdatePackageRequest::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void UpdatePackageRequest::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& UpdatePackageRequest::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& UpdatePackageRequest::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.UpdatePackageRequest.package)
  return _internal_package();
}
inline void UpdatePackageRequest::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.UpdatePackageRequest.package)
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageRequest::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageRequest::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.UpdatePackageRequest.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageRequest::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageRequest::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.UpdatePackageRequest.package)
  return _msg;
}
inline void UpdatePackageRequest::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.UpdatePackageRequest.package)
}

// -------------------------------------------------------------------

// UpdatePackageResponse

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool UpdatePackageResponse::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void UpdatePackageResponse::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& UpdatePackageResponse::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& UpdatePackageResponse::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.UpdatePackageResponse.package)
  return _internal_package();
}
inline void UpdatePackageResponse::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.UpdatePackageResponse.package)
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageResponse::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageResponse::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.UpdatePackageResponse.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageResponse::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* UpdatePackageResponse::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.UpdatePackageResponse.package)
  return _msg;
}
inline void UpdatePackageResponse::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.UpdatePackageResponse.package)
}

// -------------------------------------------------------------------

// PatchPackageRequest

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool PatchPackageRequest::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void PatchPackageRequest::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& PatchPackageRequest::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& PatchPackageRequest::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.PatchPackageRequest.package)
  return _internal_package();
}
inline void PatchPackageRequest::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.PatchPackageRequest.package)
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageRequest::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageRequest::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.PatchPackageRequest.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageRequest::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageRequest::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.PatchPackageRequest.package)
  return _msg;
}
inline void PatchPackageRequest::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.PatchPackageRequest.package)
}

// .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
inline bool PatchPackageRequest::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& PatchPackageRequest::_internal_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FieldMask* p = _impl_.mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& PatchPackageRequest::mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.PatchPackageRequest.mask)
  return _internal_mask();
}
inline void PatchPackageRequest::unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }
  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.PatchPackageRequest.mask)
}
inline ::google::protobuf::FieldMask* PatchPackageRequest::release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.mask_;
  _impl_.mask_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::FieldMask* PatchPackageRequest::unsafe_arena_release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.PatchPackageRequest.mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* PatchPackageRequest::_internal_mutable_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FieldMask>(GetArena());
    _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.mask_;
}
inline ::google::protobuf::FieldMask* PatchPackageRequest::mutable_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FieldMask* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.PatchPackageRequest.mask)
  return _msg;
}
inline void PatchPackageRequest::set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.PatchPackageRequest.mask)
}

// -------------------------------------------------------------------

// PatchPackageResponse

// .kentik.mkp.v202102alpha1.Package package = 1 [json_name = "package"];
inline bool PatchPackageResponse::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void PatchPackageResponse::clear_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Package& PatchPackageResponse::_internal_package() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Package&>(::kentik::mkp::v202102alpha1::_Package_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Package& PatchPackageResponse::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.PatchPackageResponse.package)
  return _internal_package();
}
inline void PatchPackageResponse::unsafe_arena_set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.PatchPackageResponse.package)
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageResponse::release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageResponse::unsafe_arena_release_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.PatchPackageResponse.package)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageResponse::_internal_mutable_package() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.package_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(p);
  }
  return _impl_.package_;
}
inline ::kentik::mkp::v202102alpha1::Package* PatchPackageResponse::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.PatchPackageResponse.package)
  return _msg;
}
inline void PatchPackageResponse::set_allocated_package(::kentik::mkp::v202102alpha1::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.package_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.PatchPackageResponse.package)
}

// -------------------------------------------------------------------

// DeletePackageRequest

// uint64 id = 1 [json_name = "id"];
inline void DeletePackageRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t DeletePackageRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.DeletePackageRequest.id)
  return _internal_id();
}
inline void DeletePackageRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.DeletePackageRequest.id)
}
inline ::uint64_t DeletePackageRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void DeletePackageRequest::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// DeletePackageResponse

// -------------------------------------------------------------------

// ListTenantRequest

// -------------------------------------------------------------------

// ListTenantResponse

// repeated .kentik.mkp.v202102alpha1.Tenant tenants = 1 [json_name = "tenants"];
inline int ListTenantResponse::_internal_tenants_size() const {
  return _internal_tenants().size();
}
inline int ListTenantResponse::tenants_size() const {
  return _internal_tenants_size();
}
inline void ListTenantResponse::clear_tenants() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tenants_.Clear();
}
inline ::kentik::mkp::v202102alpha1::Tenant* ListTenantResponse::mutable_tenants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.ListTenantResponse.tenants)
  return _internal_mutable_tenants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>* ListTenantResponse::mutable_tenants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.mkp.v202102alpha1.ListTenantResponse.tenants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tenants();
}
inline const ::kentik::mkp::v202102alpha1::Tenant& ListTenantResponse::tenants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.ListTenantResponse.tenants)
  return _internal_tenants().Get(index);
}
inline ::kentik::mkp::v202102alpha1::Tenant* ListTenantResponse::add_tenants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::mkp::v202102alpha1::Tenant* _add = _internal_mutable_tenants()->Add();
  // @@protoc_insertion_point(field_add:kentik.mkp.v202102alpha1.ListTenantResponse.tenants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>& ListTenantResponse::tenants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.mkp.v202102alpha1.ListTenantResponse.tenants)
  return _internal_tenants();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>&
ListTenantResponse::_internal_tenants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tenants_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::mkp::v202102alpha1::Tenant>*
ListTenantResponse::_internal_mutable_tenants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tenants_;
}

// uint32 invalid_count = 2 [json_name = "invalidCount"];
inline void ListTenantResponse::clear_invalid_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_count_ = 0u;
}
inline ::uint32_t ListTenantResponse::invalid_count() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.ListTenantResponse.invalid_count)
  return _internal_invalid_count();
}
inline void ListTenantResponse::set_invalid_count(::uint32_t value) {
  _internal_set_invalid_count(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.ListTenantResponse.invalid_count)
}
inline ::uint32_t ListTenantResponse::_internal_invalid_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invalid_count_;
}
inline void ListTenantResponse::_internal_set_invalid_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_count_ = value;
}

// -------------------------------------------------------------------

// GetTenantRequest

// uint64 id = 1 [json_name = "id"];
inline void GetTenantRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t GetTenantRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.GetTenantRequest.id)
  return _internal_id();
}
inline void GetTenantRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.GetTenantRequest.id)
}
inline ::uint64_t GetTenantRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void GetTenantRequest::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// GetTenantResponse

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool GetTenantResponse::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void GetTenantResponse::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& GetTenantResponse::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& GetTenantResponse::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.GetTenantResponse.tenant)
  return _internal_tenant();
}
inline void GetTenantResponse::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.GetTenantResponse.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* GetTenantResponse::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* GetTenantResponse::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.GetTenantResponse.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* GetTenantResponse::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* GetTenantResponse::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.GetTenantResponse.tenant)
  return _msg;
}
inline void GetTenantResponse::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.GetTenantResponse.tenant)
}

// -------------------------------------------------------------------

// CreateTenantRequest

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool CreateTenantRequest::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void CreateTenantRequest::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& CreateTenantRequest::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& CreateTenantRequest::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.CreateTenantRequest.tenant)
  return _internal_tenant();
}
inline void CreateTenantRequest::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.CreateTenantRequest.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantRequest::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantRequest::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.CreateTenantRequest.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantRequest::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantRequest::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.CreateTenantRequest.tenant)
  return _msg;
}
inline void CreateTenantRequest::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.CreateTenantRequest.tenant)
}

// -------------------------------------------------------------------

// CreateTenantResponse

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool CreateTenantResponse::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void CreateTenantResponse::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& CreateTenantResponse::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& CreateTenantResponse::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.CreateTenantResponse.tenant)
  return _internal_tenant();
}
inline void CreateTenantResponse::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.CreateTenantResponse.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantResponse::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantResponse::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.CreateTenantResponse.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantResponse::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* CreateTenantResponse::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.CreateTenantResponse.tenant)
  return _msg;
}
inline void CreateTenantResponse::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.CreateTenantResponse.tenant)
}

// -------------------------------------------------------------------

// UpdateTenantRequest

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool UpdateTenantRequest::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void UpdateTenantRequest::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& UpdateTenantRequest::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& UpdateTenantRequest::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.UpdateTenantRequest.tenant)
  return _internal_tenant();
}
inline void UpdateTenantRequest::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.UpdateTenantRequest.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantRequest::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantRequest::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.UpdateTenantRequest.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantRequest::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantRequest::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.UpdateTenantRequest.tenant)
  return _msg;
}
inline void UpdateTenantRequest::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.UpdateTenantRequest.tenant)
}

// -------------------------------------------------------------------

// UpdateTenantResponse

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool UpdateTenantResponse::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void UpdateTenantResponse::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& UpdateTenantResponse::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& UpdateTenantResponse::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.UpdateTenantResponse.tenant)
  return _internal_tenant();
}
inline void UpdateTenantResponse::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.UpdateTenantResponse.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantResponse::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantResponse::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.UpdateTenantResponse.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantResponse::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* UpdateTenantResponse::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.UpdateTenantResponse.tenant)
  return _msg;
}
inline void UpdateTenantResponse::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.UpdateTenantResponse.tenant)
}

// -------------------------------------------------------------------

// PatchTenantRequest

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool PatchTenantRequest::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void PatchTenantRequest::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& PatchTenantRequest::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& PatchTenantRequest::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.PatchTenantRequest.tenant)
  return _internal_tenant();
}
inline void PatchTenantRequest::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.PatchTenantRequest.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantRequest::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantRequest::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.PatchTenantRequest.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantRequest::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantRequest::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.PatchTenantRequest.tenant)
  return _msg;
}
inline void PatchTenantRequest::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.PatchTenantRequest.tenant)
}

// .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
inline bool PatchTenantRequest::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& PatchTenantRequest::_internal_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FieldMask* p = _impl_.mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& PatchTenantRequest::mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.PatchTenantRequest.mask)
  return _internal_mask();
}
inline void PatchTenantRequest::unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }
  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.PatchTenantRequest.mask)
}
inline ::google::protobuf::FieldMask* PatchTenantRequest::release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.mask_;
  _impl_.mask_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::FieldMask* PatchTenantRequest::unsafe_arena_release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.PatchTenantRequest.mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* PatchTenantRequest::_internal_mutable_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FieldMask>(GetArena());
    _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.mask_;
}
inline ::google::protobuf::FieldMask* PatchTenantRequest::mutable_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FieldMask* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.PatchTenantRequest.mask)
  return _msg;
}
inline void PatchTenantRequest::set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.PatchTenantRequest.mask)
}

// -------------------------------------------------------------------

// PatchTenantResponse

// .kentik.mkp.v202102alpha1.Tenant tenant = 1 [json_name = "tenant"];
inline bool PatchTenantResponse::has_tenant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tenant_ != nullptr);
  return value;
}
inline void PatchTenantResponse::clear_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ != nullptr) _impl_.tenant_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::mkp::v202102alpha1::Tenant& PatchTenantResponse::_internal_tenant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::mkp::v202102alpha1::Tenant* p = _impl_.tenant_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::mkp::v202102alpha1::Tenant&>(::kentik::mkp::v202102alpha1::_Tenant_default_instance_);
}
inline const ::kentik::mkp::v202102alpha1::Tenant& PatchTenantResponse::tenant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.PatchTenantResponse.tenant)
  return _internal_tenant();
}
inline void PatchTenantResponse::unsafe_arena_set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tenant_);
  }
  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.mkp.v202102alpha1.PatchTenantResponse.tenant)
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantResponse::release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* released = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantResponse::unsafe_arena_release_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.mkp.v202102alpha1.PatchTenantResponse.tenant)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* temp = _impl_.tenant_;
  _impl_.tenant_ = nullptr;
  return temp;
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantResponse::_internal_mutable_tenant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tenant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::mkp::v202102alpha1::Tenant>(GetArena());
    _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(p);
  }
  return _impl_.tenant_;
}
inline ::kentik::mkp::v202102alpha1::Tenant* PatchTenantResponse::mutable_tenant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::mkp::v202102alpha1::Tenant* _msg = _internal_mutable_tenant();
  // @@protoc_insertion_point(field_mutable:kentik.mkp.v202102alpha1.PatchTenantResponse.tenant)
  return _msg;
}
inline void PatchTenantResponse::set_allocated_tenant(::kentik::mkp::v202102alpha1::Tenant* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tenant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tenant_ = reinterpret_cast<::kentik::mkp::v202102alpha1::Tenant*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.mkp.v202102alpha1.PatchTenantResponse.tenant)
}

// -------------------------------------------------------------------

// DeleteTenantRequest

// uint64 id = 1 [json_name = "id"];
inline void DeleteTenantRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t DeleteTenantRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.mkp.v202102alpha1.DeleteTenantRequest.id)
  return _internal_id();
}
inline void DeleteTenantRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.mkp.v202102alpha1.DeleteTenantRequest.id)
}
inline ::uint64_t DeleteTenantRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void DeleteTenantRequest::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// DeleteTenantResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v202102alpha1
}  // namespace mkp
}  // namespace kentik


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // kentik_2fmkp_2fv202102alpha1_2fmkp_2eproto_2epb_2eh
