// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: kentik/synthetics/v202101beta1/synthetics.proto
// Protobuf C++ Version: 5.29.3

#ifndef kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto_2epb_2eh
#define kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/protobuf/field_mask.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "kentik/core/v202303/annotations.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
namespace kentik {
namespace synthetics {
namespace v202101beta1 {
class ASN;
struct ASNDefaultTypeInternal;
extern ASNDefaultTypeInternal _ASN_default_instance_;
class Agent;
struct AgentDefaultTypeInternal;
extern AgentDefaultTypeInternal _Agent_default_instance_;
class AgentHealth;
struct AgentHealthDefaultTypeInternal;
extern AgentHealthDefaultTypeInternal _AgentHealth_default_instance_;
class AgentTaskConfig;
struct AgentTaskConfigDefaultTypeInternal;
extern AgentTaskConfigDefaultTypeInternal _AgentTaskConfig_default_instance_;
class AgentTest;
struct AgentTestDefaultTypeInternal;
extern AgentTestDefaultTypeInternal _AgentTest_default_instance_;
class ApplicationMeshTest;
struct ApplicationMeshTestDefaultTypeInternal;
extern ApplicationMeshTestDefaultTypeInternal _ApplicationMeshTest_default_instance_;
class City;
struct CityDefaultTypeInternal;
extern CityDefaultTypeInternal _City_default_instance_;
class Country;
struct CountryDefaultTypeInternal;
extern CountryDefaultTypeInternal _Country_default_instance_;
class CreateTestRequest;
struct CreateTestRequestDefaultTypeInternal;
extern CreateTestRequestDefaultTypeInternal _CreateTestRequest_default_instance_;
class CreateTestResponse;
struct CreateTestResponseDefaultTypeInternal;
extern CreateTestResponseDefaultTypeInternal _CreateTestResponse_default_instance_;
class DNS;
struct DNSDefaultTypeInternal;
extern DNSDefaultTypeInternal _DNS_default_instance_;
class DNSTaskDefinition;
struct DNSTaskDefinitionDefaultTypeInternal;
extern DNSTaskDefinitionDefaultTypeInternal _DNSTaskDefinition_default_instance_;
class DeleteAgentRequest;
struct DeleteAgentRequestDefaultTypeInternal;
extern DeleteAgentRequestDefaultTypeInternal _DeleteAgentRequest_default_instance_;
class DeleteAgentResponse;
struct DeleteAgentResponseDefaultTypeInternal;
extern DeleteAgentResponseDefaultTypeInternal _DeleteAgentResponse_default_instance_;
class DeleteTestRequest;
struct DeleteTestRequestDefaultTypeInternal;
extern DeleteTestRequestDefaultTypeInternal _DeleteTestRequest_default_instance_;
class DeleteTestResponse;
struct DeleteTestResponseDefaultTypeInternal;
extern DeleteTestResponseDefaultTypeInternal _DeleteTestResponse_default_instance_;
class DnsGridTest;
struct DnsGridTestDefaultTypeInternal;
extern DnsGridTestDefaultTypeInternal _DnsGridTest_default_instance_;
class DnsTest;
struct DnsTestDefaultTypeInternal;
extern DnsTestDefaultTypeInternal _DnsTest_default_instance_;
class FlowTest;
struct FlowTestDefaultTypeInternal;
extern FlowTestDefaultTypeInternal _FlowTest_default_instance_;
class Geo;
struct GeoDefaultTypeInternal;
extern GeoDefaultTypeInternal _Geo_default_instance_;
class GetAgentRequest;
struct GetAgentRequestDefaultTypeInternal;
extern GetAgentRequestDefaultTypeInternal _GetAgentRequest_default_instance_;
class GetAgentResponse;
struct GetAgentResponseDefaultTypeInternal;
extern GetAgentResponseDefaultTypeInternal _GetAgentResponse_default_instance_;
class GetHealthForTestsRequest;
struct GetHealthForTestsRequestDefaultTypeInternal;
extern GetHealthForTestsRequestDefaultTypeInternal _GetHealthForTestsRequest_default_instance_;
class GetHealthForTestsResponse;
struct GetHealthForTestsResponseDefaultTypeInternal;
extern GetHealthForTestsResponseDefaultTypeInternal _GetHealthForTestsResponse_default_instance_;
class GetTestRequest;
struct GetTestRequestDefaultTypeInternal;
extern GetTestRequestDefaultTypeInternal _GetTestRequest_default_instance_;
class GetTestResponse;
struct GetTestResponseDefaultTypeInternal;
extern GetTestResponseDefaultTypeInternal _GetTestResponse_default_instance_;
class GetTraceForTestRequest;
struct GetTraceForTestRequestDefaultTypeInternal;
extern GetTraceForTestRequestDefaultTypeInternal _GetTraceForTestRequest_default_instance_;
class GetTraceForTestResponse;
struct GetTraceForTestResponseDefaultTypeInternal;
extern GetTraceForTestResponseDefaultTypeInternal _GetTraceForTestResponse_default_instance_;
class GridTest;
struct GridTestDefaultTypeInternal;
extern GridTestDefaultTypeInternal _GridTest_default_instance_;
class HTTPConfig;
struct HTTPConfigDefaultTypeInternal;
extern HTTPConfigDefaultTypeInternal _HTTPConfig_default_instance_;
class HTTPConfig_CssSelectorsEntry_DoNotUse;
struct HTTPConfig_CssSelectorsEntry_DoNotUseDefaultTypeInternal;
extern HTTPConfig_CssSelectorsEntry_DoNotUseDefaultTypeInternal _HTTPConfig_CssSelectorsEntry_DoNotUse_default_instance_;
class HTTPConfig_HeadersEntry_DoNotUse;
struct HTTPConfig_HeadersEntry_DoNotUseDefaultTypeInternal;
extern HTTPConfig_HeadersEntry_DoNotUseDefaultTypeInternal _HTTPConfig_HeadersEntry_DoNotUse_default_instance_;
class HTTPTaskDefinition;
struct HTTPTaskDefinitionDefaultTypeInternal;
extern HTTPTaskDefinitionDefaultTypeInternal _HTTPTaskDefinition_default_instance_;
class Health;
struct HealthDefaultTypeInternal;
extern HealthDefaultTypeInternal _Health_default_instance_;
class HealthMoment;
struct HealthMomentDefaultTypeInternal;
extern HealthMomentDefaultTypeInternal _HealthMoment_default_instance_;
class HealthMoment_OtherHealthsEntry_DoNotUse;
struct HealthMoment_OtherHealthsEntry_DoNotUseDefaultTypeInternal;
extern HealthMoment_OtherHealthsEntry_DoNotUseDefaultTypeInternal _HealthMoment_OtherHealthsEntry_DoNotUse_default_instance_;
class HealthSettings;
struct HealthSettingsDefaultTypeInternal;
extern HealthSettingsDefaultTypeInternal _HealthSettings_default_instance_;
class HostnameTest;
struct HostnameTestDefaultTypeInternal;
extern HostnameTestDefaultTypeInternal _HostnameTest_default_instance_;
class IDByIP;
struct IDByIPDefaultTypeInternal;
extern IDByIPDefaultTypeInternal _IDByIP_default_instance_;
class IPInfo;
struct IPInfoDefaultTypeInternal;
extern IPInfoDefaultTypeInternal _IPInfo_default_instance_;
class IpTest;
struct IpTestDefaultTypeInternal;
extern IpTestDefaultTypeInternal _IpTest_default_instance_;
class KnockTaskDefinition;
struct KnockTaskDefinitionDefaultTypeInternal;
extern KnockTaskDefinitionDefaultTypeInternal _KnockTaskDefinition_default_instance_;
class ListAgentsRequest;
struct ListAgentsRequestDefaultTypeInternal;
extern ListAgentsRequestDefaultTypeInternal _ListAgentsRequest_default_instance_;
class ListAgentsResponse;
struct ListAgentsResponseDefaultTypeInternal;
extern ListAgentsResponseDefaultTypeInternal _ListAgentsResponse_default_instance_;
class ListTestsRequest;
struct ListTestsRequestDefaultTypeInternal;
extern ListTestsRequestDefaultTypeInternal _ListTestsRequest_default_instance_;
class ListTestsResponse;
struct ListTestsResponseDefaultTypeInternal;
extern ListTestsResponseDefaultTypeInternal _ListTestsResponse_default_instance_;
class MeshColumn;
struct MeshColumnDefaultTypeInternal;
extern MeshColumnDefaultTypeInternal _MeshColumn_default_instance_;
class MeshMetric;
struct MeshMetricDefaultTypeInternal;
extern MeshMetricDefaultTypeInternal _MeshMetric_default_instance_;
class MeshMetrics;
struct MeshMetricsDefaultTypeInternal;
extern MeshMetricsDefaultTypeInternal _MeshMetrics_default_instance_;
class MeshResponse;
struct MeshResponseDefaultTypeInternal;
extern MeshResponseDefaultTypeInternal _MeshResponse_default_instance_;
class PatchAgentRequest;
struct PatchAgentRequestDefaultTypeInternal;
extern PatchAgentRequestDefaultTypeInternal _PatchAgentRequest_default_instance_;
class PatchAgentResponse;
struct PatchAgentResponseDefaultTypeInternal;
extern PatchAgentResponseDefaultTypeInternal _PatchAgentResponse_default_instance_;
class PatchTestRequest;
struct PatchTestRequestDefaultTypeInternal;
extern PatchTestRequestDefaultTypeInternal _PatchTestRequest_default_instance_;
class PatchTestResponse;
struct PatchTestResponseDefaultTypeInternal;
extern PatchTestResponseDefaultTypeInternal _PatchTestResponse_default_instance_;
class PingTaskDefinition;
struct PingTaskDefinitionDefaultTypeInternal;
extern PingTaskDefinitionDefaultTypeInternal _PingTaskDefinition_default_instance_;
class Region;
struct RegionDefaultTypeInternal;
extern RegionDefaultTypeInternal _Region_default_instance_;
class SetTestStatusRequest;
struct SetTestStatusRequestDefaultTypeInternal;
extern SetTestStatusRequestDefaultTypeInternal _SetTestStatusRequest_default_instance_;
class SetTestStatusResponse;
struct SetTestStatusResponseDefaultTypeInternal;
extern SetTestStatusResponseDefaultTypeInternal _SetTestStatusResponse_default_instance_;
class ShakeTaskDefinition;
struct ShakeTaskDefinitionDefaultTypeInternal;
extern ShakeTaskDefinitionDefaultTypeInternal _ShakeTaskDefinition_default_instance_;
class SiteTest;
struct SiteTestDefaultTypeInternal;
extern SiteTestDefaultTypeInternal _SiteTest_default_instance_;
class Stats;
struct StatsDefaultTypeInternal;
extern StatsDefaultTypeInternal _Stats_default_instance_;
class TagTest;
struct TagTestDefaultTypeInternal;
extern TagTestDefaultTypeInternal _TagTest_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskHealth;
struct TaskHealthDefaultTypeInternal;
extern TaskHealthDefaultTypeInternal _TaskHealth_default_instance_;
class Test;
struct TestDefaultTypeInternal;
extern TestDefaultTypeInternal _Test_default_instance_;
class TestHealth;
struct TestHealthDefaultTypeInternal;
extern TestHealthDefaultTypeInternal _TestHealth_default_instance_;
class TestMonitoringSettings;
struct TestMonitoringSettingsDefaultTypeInternal;
extern TestMonitoringSettingsDefaultTypeInternal _TestMonitoringSettings_default_instance_;
class TestPingSettings;
struct TestPingSettingsDefaultTypeInternal;
extern TestPingSettingsDefaultTypeInternal _TestPingSettings_default_instance_;
class TestSettings;
struct TestSettingsDefaultTypeInternal;
extern TestSettingsDefaultTypeInternal _TestSettings_default_instance_;
class TestTraceSettings;
struct TestTraceSettingsDefaultTypeInternal;
extern TestTraceSettingsDefaultTypeInternal _TestTraceSettings_default_instance_;
class Trace;
struct TraceDefaultTypeInternal;
extern TraceDefaultTypeInternal _Trace_default_instance_;
class TraceHop;
struct TraceHopDefaultTypeInternal;
extern TraceHopDefaultTypeInternal _TraceHop_default_instance_;
class TraceProbe;
struct TraceProbeDefaultTypeInternal;
extern TraceProbeDefaultTypeInternal _TraceProbe_default_instance_;
class TraceTaskDefinition;
struct TraceTaskDefinitionDefaultTypeInternal;
extern TraceTaskDefinitionDefaultTypeInternal _TraceTaskDefinition_default_instance_;
class TracerouteInfo;
struct TracerouteInfoDefaultTypeInternal;
extern TracerouteInfoDefaultTypeInternal _TracerouteInfo_default_instance_;
class TracerouteLookup;
struct TracerouteLookupDefaultTypeInternal;
extern TracerouteLookupDefaultTypeInternal _TracerouteLookup_default_instance_;
class TracerouteResult;
struct TracerouteResultDefaultTypeInternal;
extern TracerouteResultDefaultTypeInternal _TracerouteResult_default_instance_;
class UrlTest;
struct UrlTestDefaultTypeInternal;
extern UrlTestDefaultTypeInternal _UrlTest_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace v202101beta1
}  // namespace synthetics
}  // namespace kentik
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kentik {
namespace synthetics {
namespace v202101beta1 {
enum ImplementType : int {
  IMPLEMENT_TYPE_UNSPECIFIED = 0,
  IMPLEMENT_TYPE_RUST = 1,
  IMPLEMENT_TYPE_NODE = 2,
  ImplementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ImplementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ImplementType_IsValid(int value);
extern const uint32_t ImplementType_internal_data_[];
constexpr ImplementType ImplementType_MIN = static_cast<ImplementType>(0);
constexpr ImplementType ImplementType_MAX = static_cast<ImplementType>(2);
constexpr int ImplementType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ImplementType_descriptor();
template <typename T>
const std::string& ImplementType_Name(T value) {
  static_assert(std::is_same<T, ImplementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImplementType_Name().");
  return ImplementType_Name(static_cast<ImplementType>(value));
}
template <>
inline const std::string& ImplementType_Name(ImplementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImplementType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ImplementType_Parse(absl::string_view name, ImplementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImplementType>(
      ImplementType_descriptor(), name, value);
}
enum IPFamily : int {
  IP_FAMILY_UNSPECIFIED = 0,
  IP_FAMILY_V4 = 1,
  IP_FAMILY_V6 = 2,
  IP_FAMILY_DUAL = 3,
  IPFamily_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IPFamily_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool IPFamily_IsValid(int value);
extern const uint32_t IPFamily_internal_data_[];
constexpr IPFamily IPFamily_MIN = static_cast<IPFamily>(0);
constexpr IPFamily IPFamily_MAX = static_cast<IPFamily>(3);
constexpr int IPFamily_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
IPFamily_descriptor();
template <typename T>
const std::string& IPFamily_Name(T value) {
  static_assert(std::is_same<T, IPFamily>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IPFamily_Name().");
  return IPFamily_Name(static_cast<IPFamily>(value));
}
template <>
inline const std::string& IPFamily_Name(IPFamily value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IPFamily_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool IPFamily_Parse(absl::string_view name, IPFamily* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IPFamily>(
      IPFamily_descriptor(), name, value);
}
enum TestStatus : int {
  TEST_STATUS_UNSPECIFIED = 0,
  TEST_STATUS_ACTIVE = 1,
  TEST_STATUS_PAUSED = 2,
  TEST_STATUS_DELETED = 3,
  TestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TestStatus_IsValid(int value);
extern const uint32_t TestStatus_internal_data_[];
constexpr TestStatus TestStatus_MIN = static_cast<TestStatus>(0);
constexpr TestStatus TestStatus_MAX = static_cast<TestStatus>(3);
constexpr int TestStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TestStatus_descriptor();
template <typename T>
const std::string& TestStatus_Name(T value) {
  static_assert(std::is_same<T, TestStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TestStatus_Name().");
  return TestStatus_Name(static_cast<TestStatus>(value));
}
template <>
inline const std::string& TestStatus_Name(TestStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TestStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TestStatus_Parse(absl::string_view name, TestStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestStatus>(
      TestStatus_descriptor(), name, value);
}
enum AgentStatus : int {
  AGENT_STATUS_UNSPECIFIED = 0,
  AGENT_STATUS_OK = 1,
  AGENT_STATUS_WAIT = 2,
  AGENT_STATUS_DELETED = 3,
  AgentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AgentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AgentStatus_IsValid(int value);
extern const uint32_t AgentStatus_internal_data_[];
constexpr AgentStatus AgentStatus_MIN = static_cast<AgentStatus>(0);
constexpr AgentStatus AgentStatus_MAX = static_cast<AgentStatus>(3);
constexpr int AgentStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AgentStatus_descriptor();
template <typename T>
const std::string& AgentStatus_Name(T value) {
  static_assert(std::is_same<T, AgentStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AgentStatus_Name().");
  return AgentStatus_Name(static_cast<AgentStatus>(value));
}
template <>
inline const std::string& AgentStatus_Name(AgentStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AgentStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AgentStatus_Parse(absl::string_view name, AgentStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AgentStatus>(
      AgentStatus_descriptor(), name, value);
}
enum TaskState : int {
  TASK_STATE_UNSPECIFIED = 0,
  TASK_STATE_CREATED = 1,
  TASK_STATE_UPDATED = 2,
  TASK_STATE_DELETED = 3,
  TaskState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskState_IsValid(int value);
extern const uint32_t TaskState_internal_data_[];
constexpr TaskState TaskState_MIN = static_cast<TaskState>(0);
constexpr TaskState TaskState_MAX = static_cast<TaskState>(3);
constexpr int TaskState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TaskState_descriptor();
template <typename T>
const std::string& TaskState_Name(T value) {
  static_assert(std::is_same<T, TaskState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskState_Name().");
  return TaskState_Name(static_cast<TaskState>(value));
}
template <>
inline const std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TaskState_Parse(absl::string_view name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
      TaskState_descriptor(), name, value);
}
enum DNSRecord : int {
  DNS_RECORD_UNSPECIFIED = 0,
  DNS_RECORD_A = 1,
  DNS_RECORD_AAAA = 2,
  DNS_RECORD_CNAME = 3,
  DNS_RECORD_DNAME = 4,
  DNS_RECORD_NS = 5,
  DNS_RECORD_MX = 6,
  DNS_RECORD_PTR = 7,
  DNS_RECORD_SOA = 8,
  DNSRecord_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DNSRecord_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DNSRecord_IsValid(int value);
extern const uint32_t DNSRecord_internal_data_[];
constexpr DNSRecord DNSRecord_MIN = static_cast<DNSRecord>(0);
constexpr DNSRecord DNSRecord_MAX = static_cast<DNSRecord>(8);
constexpr int DNSRecord_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
DNSRecord_descriptor();
template <typename T>
const std::string& DNSRecord_Name(T value) {
  static_assert(std::is_same<T, DNSRecord>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DNSRecord_Name().");
  return DNSRecord_Name(static_cast<DNSRecord>(value));
}
template <>
inline const std::string& DNSRecord_Name(DNSRecord value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DNSRecord_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool DNSRecord_Parse(absl::string_view name, DNSRecord* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DNSRecord>(
      DNSRecord_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserInfo(const UserInfo& from) : UserInfo(nullptr, from) {}
  inline UserInfo(UserInfo&& from) noexcept
      : UserInfo(nullptr, std::move(from)) {}
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
        &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(UserInfo& a, UserInfo& b) { a.Swap(&b); }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserInfo& from) { UserInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.UserInfo"; }

 protected:
  explicit UserInfo(::google::protobuf::Arena* arena);
  UserInfo(::google::protobuf::Arena* arena, const UserInfo& from);
  UserInfo(::google::protobuf::Arena* arena, UserInfo&& from) noexcept
      : UserInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kFullNameFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string email = 2 [json_name = "email"];
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string full_name = 3 [json_name = "fullName"];
  void clear_full_name() ;
  const std::string& full_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_full_name(Arg_&& arg, Args_... args);
  std::string* mutable_full_name();
  PROTOBUF_NODISCARD std::string* release_full_name();
  void set_allocated_full_name(std::string* value);

  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(
      const std::string& value);
  std::string* _internal_mutable_full_name();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.UserInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr full_name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class UrlTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.UrlTest) */ {
 public:
  inline UrlTest() : UrlTest(nullptr) {}
  ~UrlTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UrlTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UrlTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UrlTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UrlTest(const UrlTest& from) : UrlTest(nullptr, from) {}
  inline UrlTest(UrlTest&& from) noexcept
      : UrlTest(nullptr, std::move(from)) {}
  inline UrlTest& operator=(const UrlTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UrlTest& operator=(UrlTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UrlTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UrlTest* internal_default_instance() {
    return reinterpret_cast<const UrlTest*>(
        &_UrlTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(UrlTest& a, UrlTest& b) { a.Swap(&b); }
  inline void Swap(UrlTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UrlTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UrlTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UrlTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UrlTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UrlTest& from) { UrlTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UrlTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.UrlTest"; }

 protected:
  explicit UrlTest(::google::protobuf::Arena* arena);
  UrlTest(::google::protobuf::Arena* arena, const UrlTest& from);
  UrlTest(::google::protobuf::Arena* arena, UrlTest&& from) noexcept
      : UrlTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.UrlTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UrlTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TracerouteInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TracerouteInfo) */ {
 public:
  inline TracerouteInfo() : TracerouteInfo(nullptr) {}
  ~TracerouteInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TracerouteInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TracerouteInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TracerouteInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline TracerouteInfo(const TracerouteInfo& from) : TracerouteInfo(nullptr, from) {}
  inline TracerouteInfo(TracerouteInfo&& from) noexcept
      : TracerouteInfo(nullptr, std::move(from)) {}
  inline TracerouteInfo& operator=(const TracerouteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TracerouteInfo& operator=(TracerouteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TracerouteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TracerouteInfo* internal_default_instance() {
    return reinterpret_cast<const TracerouteInfo*>(
        &_TracerouteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(TracerouteInfo& a, TracerouteInfo& b) { a.Swap(&b); }
  inline void Swap(TracerouteInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TracerouteInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TracerouteInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TracerouteInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TracerouteInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TracerouteInfo& from) { TracerouteInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TracerouteInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TracerouteInfo"; }

 protected:
  explicit TracerouteInfo(::google::protobuf::Arena* arena);
  TracerouteInfo(::google::protobuf::Arena* arena, const TracerouteInfo& from);
  TracerouteInfo(::google::protobuf::Arena* arena, TracerouteInfo&& from) noexcept
      : TracerouteInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsTraceRoutesTruncatedFieldNumber = 1,
    kMaxAsnPathCountFieldNumber = 2,
    kMaxSitePathCountFieldNumber = 3,
    kMaxRegionPathCountFieldNumber = 4,
  };
  // bool is_trace_routes_truncated = 1 [json_name = "isTraceRoutesTruncated"];
  void clear_is_trace_routes_truncated() ;
  bool is_trace_routes_truncated() const;
  void set_is_trace_routes_truncated(bool value);

  private:
  bool _internal_is_trace_routes_truncated() const;
  void _internal_set_is_trace_routes_truncated(bool value);

  public:
  // int32 max_asn_path_count = 2 [json_name = "maxAsnPathCount"];
  void clear_max_asn_path_count() ;
  ::int32_t max_asn_path_count() const;
  void set_max_asn_path_count(::int32_t value);

  private:
  ::int32_t _internal_max_asn_path_count() const;
  void _internal_set_max_asn_path_count(::int32_t value);

  public:
  // int32 max_site_path_count = 3 [json_name = "maxSitePathCount"];
  void clear_max_site_path_count() ;
  ::int32_t max_site_path_count() const;
  void set_max_site_path_count(::int32_t value);

  private:
  ::int32_t _internal_max_site_path_count() const;
  void _internal_set_max_site_path_count(::int32_t value);

  public:
  // int32 max_region_path_count = 4 [json_name = "maxRegionPathCount"];
  void clear_max_region_path_count() ;
  ::int32_t max_region_path_count() const;
  void set_max_region_path_count(::int32_t value);

  private:
  ::int32_t _internal_max_region_path_count() const;
  void _internal_set_max_region_path_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TracerouteInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TracerouteInfo& from_msg);
    bool is_trace_routes_truncated_;
    ::int32_t max_asn_path_count_;
    ::int32_t max_site_path_count_;
    ::int32_t max_region_path_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TraceTaskDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TraceTaskDefinition) */ {
 public:
  inline TraceTaskDefinition() : TraceTaskDefinition(nullptr) {}
  ~TraceTaskDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TraceTaskDefinition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TraceTaskDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TraceTaskDefinition(
      ::google::protobuf::internal::ConstantInitialized);

  inline TraceTaskDefinition(const TraceTaskDefinition& from) : TraceTaskDefinition(nullptr, from) {}
  inline TraceTaskDefinition(TraceTaskDefinition&& from) noexcept
      : TraceTaskDefinition(nullptr, std::move(from)) {}
  inline TraceTaskDefinition& operator=(const TraceTaskDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceTaskDefinition& operator=(TraceTaskDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceTaskDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceTaskDefinition* internal_default_instance() {
    return reinterpret_cast<const TraceTaskDefinition*>(
        &_TraceTaskDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TraceTaskDefinition& a, TraceTaskDefinition& b) { a.Swap(&b); }
  inline void Swap(TraceTaskDefinition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceTaskDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceTaskDefinition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TraceTaskDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TraceTaskDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TraceTaskDefinition& from) { TraceTaskDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TraceTaskDefinition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TraceTaskDefinition"; }

 protected:
  explicit TraceTaskDefinition(::google::protobuf::Arena* arena);
  TraceTaskDefinition(::google::protobuf::Arena* arena, const TraceTaskDefinition& from);
  TraceTaskDefinition(::google::protobuf::Arena* arena, TraceTaskDefinition&& from) noexcept
      : TraceTaskDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kPeriodFieldNumber = 2,
    kExpiryFieldNumber = 3,
    kLimitFieldNumber = 4,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // uint32 period = 2 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 3 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // uint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::uint32_t limit() const;
  void set_limit(::uint32_t value);

  private:
  ::uint32_t _internal_limit() const;
  void _internal_set_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TraceTaskDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TraceTaskDefinition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    ::uint32_t limit_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TraceHop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TraceHop) */ {
 public:
  inline TraceHop() : TraceHop(nullptr) {}
  ~TraceHop() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TraceHop* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TraceHop));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TraceHop(
      ::google::protobuf::internal::ConstantInitialized);

  inline TraceHop(const TraceHop& from) : TraceHop(nullptr, from) {}
  inline TraceHop(TraceHop&& from) noexcept
      : TraceHop(nullptr, std::move(from)) {}
  inline TraceHop& operator=(const TraceHop& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceHop& operator=(TraceHop&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceHop& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceHop* internal_default_instance() {
    return reinterpret_cast<const TraceHop*>(
        &_TraceHop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(TraceHop& a, TraceHop& b) { a.Swap(&b); }
  inline void Swap(TraceHop* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceHop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceHop* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TraceHop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TraceHop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TraceHop& from) { TraceHop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TraceHop* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TraceHop"; }

 protected:
  explicit TraceHop(::google::protobuf::Arena* arena);
  TraceHop(::google::protobuf::Arena* arena, const TraceHop& from);
  TraceHop(::google::protobuf::Arena* arena, TraceHop&& from) noexcept
      : TraceHop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpFieldNumber = 2,
    kTtlFieldNumber = 1,
    kLatencyFieldNumber = 4,
    kMinExpectedLatencyFieldNumber = 5,
    kAsnFieldNumber = 6,
    kSiteFieldNumber = 7,
    kTimeoutFieldNumber = 3,
    kTargetFieldNumber = 9,
    kTraceEndFieldNumber = 10,
    kRegionFieldNumber = 8,
  };
  // string ip = 2 [json_name = "ip"];
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // int32 ttl = 1 [json_name = "ttl"];
  void clear_ttl() ;
  ::int32_t ttl() const;
  void set_ttl(::int32_t value);

  private:
  ::int32_t _internal_ttl() const;
  void _internal_set_ttl(::int32_t value);

  public:
  // int32 latency = 4 [json_name = "latency"];
  void clear_latency() ;
  ::int32_t latency() const;
  void set_latency(::int32_t value);

  private:
  ::int32_t _internal_latency() const;
  void _internal_set_latency(::int32_t value);

  public:
  // int32 min_expected_latency = 5 [json_name = "minExpectedLatency"];
  void clear_min_expected_latency() ;
  ::int32_t min_expected_latency() const;
  void set_min_expected_latency(::int32_t value);

  private:
  ::int32_t _internal_min_expected_latency() const;
  void _internal_set_min_expected_latency(::int32_t value);

  public:
  // int32 asn = 6 [json_name = "asn"];
  void clear_asn() ;
  ::int32_t asn() const;
  void set_asn(::int32_t value);

  private:
  ::int32_t _internal_asn() const;
  void _internal_set_asn(::int32_t value);

  public:
  // int32 site = 7 [json_name = "site"];
  void clear_site() ;
  ::int32_t site() const;
  void set_site(::int32_t value);

  private:
  ::int32_t _internal_site() const;
  void _internal_set_site(::int32_t value);

  public:
  // bool timeout = 3 [json_name = "timeout"];
  void clear_timeout() ;
  bool timeout() const;
  void set_timeout(bool value);

  private:
  bool _internal_timeout() const;
  void _internal_set_timeout(bool value);

  public:
  // bool target = 9 [json_name = "target"];
  void clear_target() ;
  bool target() const;
  void set_target(bool value);

  private:
  bool _internal_target() const;
  void _internal_set_target(bool value);

  public:
  // bool trace_end = 10 [json_name = "traceEnd"];
  void clear_trace_end() ;
  bool trace_end() const;
  void set_trace_end(bool value);

  private:
  bool _internal_trace_end() const;
  void _internal_set_trace_end(bool value);

  public:
  // int32 region = 8 [json_name = "region"];
  void clear_region() ;
  ::int32_t region() const;
  void set_region(::int32_t value);

  private:
  ::int32_t _internal_region() const;
  void _internal_set_region(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TraceHop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TraceHop& from_msg);
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::int32_t ttl_;
    ::int32_t latency_;
    ::int32_t min_expected_latency_;
    ::int32_t asn_;
    ::int32_t site_;
    bool timeout_;
    bool target_;
    bool trace_end_;
    ::int32_t region_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TestTraceSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TestTraceSettings) */ {
 public:
  inline TestTraceSettings() : TestTraceSettings(nullptr) {}
  ~TestTraceSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestTraceSettings* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestTraceSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestTraceSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestTraceSettings(const TestTraceSettings& from) : TestTraceSettings(nullptr, from) {}
  inline TestTraceSettings(TestTraceSettings&& from) noexcept
      : TestTraceSettings(nullptr, std::move(from)) {}
  inline TestTraceSettings& operator=(const TestTraceSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTraceSettings& operator=(TestTraceSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTraceSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTraceSettings* internal_default_instance() {
    return reinterpret_cast<const TestTraceSettings*>(
        &_TestTraceSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(TestTraceSettings& a, TestTraceSettings& b) { a.Swap(&b); }
  inline void Swap(TestTraceSettings* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTraceSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTraceSettings* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestTraceSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestTraceSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestTraceSettings& from) { TestTraceSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestTraceSettings* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TestTraceSettings"; }

 protected:
  explicit TestTraceSettings(::google::protobuf::Arena* arena);
  TestTraceSettings(::google::protobuf::Arena* arena, const TestTraceSettings& from);
  TestTraceSettings(::google::protobuf::Arena* arena, TestTraceSettings&& from) noexcept
      : TestTraceSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProtocolFieldNumber = 3,
    kPeriodFieldNumber = 1,
    kCountFieldNumber = 2,
    kPortFieldNumber = 4,
    kExpiryFieldNumber = 5,
    kLimitFieldNumber = 6,
    kDelayFieldNumber = 7,
  };
  // string protocol = 3 [json_name = "protocol"];
  void clear_protocol() ;
  const std::string& protocol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol(Arg_&& arg, Args_... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* value);

  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(
      const std::string& value);
  std::string* _internal_mutable_protocol();

  public:
  // float period = 1 [json_name = "period"];
  void clear_period() ;
  float period() const;
  void set_period(float value);

  private:
  float _internal_period() const;
  void _internal_set_period(float value);

  public:
  // float count = 2 [json_name = "count"];
  void clear_count() ;
  float count() const;
  void set_count(float value);

  private:
  float _internal_count() const;
  void _internal_set_count(float value);

  public:
  // float port = 4 [json_name = "port"];
  void clear_port() ;
  float port() const;
  void set_port(float value);

  private:
  float _internal_port() const;
  void _internal_set_port(float value);

  public:
  // float expiry = 5 [json_name = "expiry"];
  void clear_expiry() ;
  float expiry() const;
  void set_expiry(float value);

  private:
  float _internal_expiry() const;
  void _internal_set_expiry(float value);

  public:
  // float limit = 6 [json_name = "limit"];
  void clear_limit() ;
  float limit() const;
  void set_limit(float value);

  private:
  float _internal_limit() const;
  void _internal_set_limit(float value);

  public:
  // float delay = 7 [json_name = "delay"];
  void clear_delay() ;
  float delay() const;
  void set_delay(float value);

  private:
  float _internal_delay() const;
  void _internal_set_delay(float value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TestTraceSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestTraceSettings& from_msg);
    ::google::protobuf::internal::ArenaStringPtr protocol_;
    float period_;
    float count_;
    float port_;
    float expiry_;
    float limit_;
    float delay_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TestPingSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TestPingSettings) */ {
 public:
  inline TestPingSettings() : TestPingSettings(nullptr) {}
  ~TestPingSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestPingSettings* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestPingSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestPingSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestPingSettings(const TestPingSettings& from) : TestPingSettings(nullptr, from) {}
  inline TestPingSettings(TestPingSettings&& from) noexcept
      : TestPingSettings(nullptr, std::move(from)) {}
  inline TestPingSettings& operator=(const TestPingSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestPingSettings& operator=(TestPingSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestPingSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestPingSettings* internal_default_instance() {
    return reinterpret_cast<const TestPingSettings*>(
        &_TestPingSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(TestPingSettings& a, TestPingSettings& b) { a.Swap(&b); }
  inline void Swap(TestPingSettings* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestPingSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestPingSettings* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestPingSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestPingSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestPingSettings& from) { TestPingSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestPingSettings* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TestPingSettings"; }

 protected:
  explicit TestPingSettings(::google::protobuf::Arena* arena);
  TestPingSettings(::google::protobuf::Arena* arena, const TestPingSettings& from);
  TestPingSettings(::google::protobuf::Arena* arena, TestPingSettings&& from) noexcept
      : TestPingSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPeriodFieldNumber = 1,
    kCountFieldNumber = 2,
    kExpiryFieldNumber = 3,
    kDelayFieldNumber = 4,
  };
  // float period = 1 [json_name = "period"];
  void clear_period() ;
  float period() const;
  void set_period(float value);

  private:
  float _internal_period() const;
  void _internal_set_period(float value);

  public:
  // float count = 2 [json_name = "count"];
  void clear_count() ;
  float count() const;
  void set_count(float value);

  private:
  float _internal_count() const;
  void _internal_set_count(float value);

  public:
  // float expiry = 3 [json_name = "expiry"];
  void clear_expiry() ;
  float expiry() const;
  void set_expiry(float value);

  private:
  float _internal_expiry() const;
  void _internal_set_expiry(float value);

  public:
  // float delay = 4 [json_name = "delay"];
  void clear_delay() ;
  float delay() const;
  void set_delay(float value);

  private:
  float _internal_delay() const;
  void _internal_set_delay(float value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TestPingSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestPingSettings& from_msg);
    float period_;
    float count_;
    float expiry_;
    float delay_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TestMonitoringSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TestMonitoringSettings) */ {
 public:
  inline TestMonitoringSettings() : TestMonitoringSettings(nullptr) {}
  ~TestMonitoringSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestMonitoringSettings* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestMonitoringSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestMonitoringSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestMonitoringSettings(const TestMonitoringSettings& from) : TestMonitoringSettings(nullptr, from) {}
  inline TestMonitoringSettings(TestMonitoringSettings&& from) noexcept
      : TestMonitoringSettings(nullptr, std::move(from)) {}
  inline TestMonitoringSettings& operator=(const TestMonitoringSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMonitoringSettings& operator=(TestMonitoringSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMonitoringSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMonitoringSettings* internal_default_instance() {
    return reinterpret_cast<const TestMonitoringSettings*>(
        &_TestMonitoringSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(TestMonitoringSettings& a, TestMonitoringSettings& b) { a.Swap(&b); }
  inline void Swap(TestMonitoringSettings* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMonitoringSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMonitoringSettings* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestMonitoringSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestMonitoringSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestMonitoringSettings& from) { TestMonitoringSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestMonitoringSettings* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TestMonitoringSettings"; }

 protected:
  explicit TestMonitoringSettings(::google::protobuf::Arena* arena);
  TestMonitoringSettings(::google::protobuf::Arena* arena, const TestMonitoringSettings& from);
  TestMonitoringSettings(::google::protobuf::Arena* arena, TestMonitoringSettings&& from) noexcept
      : TestMonitoringSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNotificationChannelsFieldNumber = 5,
    kActivationGracePeriodFieldNumber = 1,
    kActivationTimeUnitFieldNumber = 2,
    kActivationTimeWindowFieldNumber = 3,
    kActivationTimesFieldNumber = 4,
  };
  // repeated string notification_channels = 5 [json_name = "notificationChannels"];
  int notification_channels_size() const;
  private:
  int _internal_notification_channels_size() const;

  public:
  void clear_notification_channels() ;
  const std::string& notification_channels(int index) const;
  std::string* mutable_notification_channels(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_notification_channels(int index, Arg_&& value, Args_... args);
  std::string* add_notification_channels();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_notification_channels(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& notification_channels() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_notification_channels();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_notification_channels() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_notification_channels();

  public:
  // string activation_grace_period = 1 [json_name = "activationGracePeriod"];
  void clear_activation_grace_period() ;
  const std::string& activation_grace_period() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_activation_grace_period(Arg_&& arg, Args_... args);
  std::string* mutable_activation_grace_period();
  PROTOBUF_NODISCARD std::string* release_activation_grace_period();
  void set_allocated_activation_grace_period(std::string* value);

  private:
  const std::string& _internal_activation_grace_period() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activation_grace_period(
      const std::string& value);
  std::string* _internal_mutable_activation_grace_period();

  public:
  // string activation_time_unit = 2 [json_name = "activationTimeUnit"];
  void clear_activation_time_unit() ;
  const std::string& activation_time_unit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_activation_time_unit(Arg_&& arg, Args_... args);
  std::string* mutable_activation_time_unit();
  PROTOBUF_NODISCARD std::string* release_activation_time_unit();
  void set_allocated_activation_time_unit(std::string* value);

  private:
  const std::string& _internal_activation_time_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activation_time_unit(
      const std::string& value);
  std::string* _internal_mutable_activation_time_unit();

  public:
  // string activation_time_window = 3 [json_name = "activationTimeWindow"];
  void clear_activation_time_window() ;
  const std::string& activation_time_window() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_activation_time_window(Arg_&& arg, Args_... args);
  std::string* mutable_activation_time_window();
  PROTOBUF_NODISCARD std::string* release_activation_time_window();
  void set_allocated_activation_time_window(std::string* value);

  private:
  const std::string& _internal_activation_time_window() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activation_time_window(
      const std::string& value);
  std::string* _internal_mutable_activation_time_window();

  public:
  // string activation_times = 4 [json_name = "activationTimes"];
  void clear_activation_times() ;
  const std::string& activation_times() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_activation_times(Arg_&& arg, Args_... args);
  std::string* mutable_activation_times();
  PROTOBUF_NODISCARD std::string* release_activation_times();
  void set_allocated_activation_times(std::string* value);

  private:
  const std::string& _internal_activation_times() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_activation_times(
      const std::string& value);
  std::string* _internal_mutable_activation_times();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TestMonitoringSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      164, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestMonitoringSettings& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> notification_channels_;
    ::google::protobuf::internal::ArenaStringPtr activation_grace_period_;
    ::google::protobuf::internal::ArenaStringPtr activation_time_unit_;
    ::google::protobuf::internal::ArenaStringPtr activation_time_window_;
    ::google::protobuf::internal::ArenaStringPtr activation_times_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TagTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TagTest) */ {
 public:
  inline TagTest() : TagTest(nullptr) {}
  ~TagTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TagTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TagTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TagTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TagTest(const TagTest& from) : TagTest(nullptr, from) {}
  inline TagTest(TagTest&& from) noexcept
      : TagTest(nullptr, std::move(from)) {}
  inline TagTest& operator=(const TagTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTest& operator=(TagTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTest* internal_default_instance() {
    return reinterpret_cast<const TagTest*>(
        &_TagTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(TagTest& a, TagTest& b) { a.Swap(&b); }
  inline void Swap(TagTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TagTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TagTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TagTest& from) { TagTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TagTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TagTest"; }

 protected:
  explicit TagTest(::google::protobuf::Arena* arena);
  TagTest(::google::protobuf::Arena* arena, const TagTest& from);
  TagTest(::google::protobuf::Arena* arena, TagTest&& from) noexcept
      : TagTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TagTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TagTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Stats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Stats) */ {
 public:
  inline Stats() : Stats(nullptr) {}
  ~Stats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Stats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Stats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Stats(
      ::google::protobuf::internal::ConstantInitialized);

  inline Stats(const Stats& from) : Stats(nullptr, from) {}
  inline Stats(Stats&& from) noexcept
      : Stats(nullptr, std::move(from)) {}
  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stats& operator=(Stats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stats& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stats* internal_default_instance() {
    return reinterpret_cast<const Stats*>(
        &_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(Stats& a, Stats& b) { a.Swap(&b); }
  inline void Swap(Stats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Stats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Stats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Stats& from) { Stats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Stats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Stats"; }

 protected:
  explicit Stats(::google::protobuf::Arena* arena);
  Stats(::google::protobuf::Arena* arena, const Stats& from);
  Stats(::google::protobuf::Arena* arena, Stats&& from) noexcept
      : Stats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAverageFieldNumber = 1,
    kMaxFieldNumber = 2,
    kTotalFieldNumber = 3,
  };
  // int32 average = 1 [json_name = "average"];
  void clear_average() ;
  ::int32_t average() const;
  void set_average(::int32_t value);

  private:
  ::int32_t _internal_average() const;
  void _internal_set_average(::int32_t value);

  public:
  // int32 max = 2 [json_name = "max"];
  void clear_max() ;
  ::int32_t max() const;
  void set_max(::int32_t value);

  private:
  ::int32_t _internal_max() const;
  void _internal_set_max(::int32_t value);

  public:
  // int32 total = 3 [json_name = "total"];
  void clear_total() ;
  ::int32_t total() const;
  void set_total(::int32_t value);

  private:
  ::int32_t _internal_total() const;
  void _internal_set_total(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Stats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Stats& from_msg);
    ::int32_t average_;
    ::int32_t max_;
    ::int32_t total_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class SiteTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.SiteTest) */ {
 public:
  inline SiteTest() : SiteTest(nullptr) {}
  ~SiteTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SiteTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SiteTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SiteTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SiteTest(const SiteTest& from) : SiteTest(nullptr, from) {}
  inline SiteTest(SiteTest&& from) noexcept
      : SiteTest(nullptr, std::move(from)) {}
  inline SiteTest& operator=(const SiteTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiteTest& operator=(SiteTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SiteTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SiteTest* internal_default_instance() {
    return reinterpret_cast<const SiteTest*>(
        &_SiteTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(SiteTest& a, SiteTest& b) { a.Swap(&b); }
  inline void Swap(SiteTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiteTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SiteTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SiteTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SiteTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SiteTest& from) { SiteTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SiteTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.SiteTest"; }

 protected:
  explicit SiteTest(::google::protobuf::Arena* arena);
  SiteTest(::google::protobuf::Arena* arena, const SiteTest& from);
  SiteTest(::google::protobuf::Arena* arena, SiteTest&& from) noexcept
      : SiteTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.SiteTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      54, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SiteTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ShakeTaskDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ShakeTaskDefinition) */ {
 public:
  inline ShakeTaskDefinition() : ShakeTaskDefinition(nullptr) {}
  ~ShakeTaskDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ShakeTaskDefinition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ShakeTaskDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShakeTaskDefinition(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShakeTaskDefinition(const ShakeTaskDefinition& from) : ShakeTaskDefinition(nullptr, from) {}
  inline ShakeTaskDefinition(ShakeTaskDefinition&& from) noexcept
      : ShakeTaskDefinition(nullptr, std::move(from)) {}
  inline ShakeTaskDefinition& operator=(const ShakeTaskDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShakeTaskDefinition& operator=(ShakeTaskDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShakeTaskDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShakeTaskDefinition* internal_default_instance() {
    return reinterpret_cast<const ShakeTaskDefinition*>(
        &_ShakeTaskDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ShakeTaskDefinition& a, ShakeTaskDefinition& b) { a.Swap(&b); }
  inline void Swap(ShakeTaskDefinition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShakeTaskDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShakeTaskDefinition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ShakeTaskDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShakeTaskDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShakeTaskDefinition& from) { ShakeTaskDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ShakeTaskDefinition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ShakeTaskDefinition"; }

 protected:
  explicit ShakeTaskDefinition(::google::protobuf::Arena* arena);
  ShakeTaskDefinition(::google::protobuf::Arena* arena, const ShakeTaskDefinition& from);
  ShakeTaskDefinition(::google::protobuf::Arena* arena, ShakeTaskDefinition&& from) noexcept
      : ShakeTaskDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kPortFieldNumber = 2,
    kPeriodFieldNumber = 3,
    kExpiryFieldNumber = 4,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // uint32 port = 2 [json_name = "port"];
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // uint32 period = 3 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 4 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ShakeTaskDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ShakeTaskDefinition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::uint32_t port_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class SetTestStatusResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.SetTestStatusResponse) */ {
 public:
  inline SetTestStatusResponse() : SetTestStatusResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetTestStatusResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetTestStatusResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetTestStatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetTestStatusResponse(const SetTestStatusResponse& from) : SetTestStatusResponse(nullptr, from) {}
  inline SetTestStatusResponse(SetTestStatusResponse&& from) noexcept
      : SetTestStatusResponse(nullptr, std::move(from)) {}
  inline SetTestStatusResponse& operator=(const SetTestStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTestStatusResponse& operator=(SetTestStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTestStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTestStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SetTestStatusResponse*>(
        &_SetTestStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 74;
  friend void swap(SetTestStatusResponse& a, SetTestStatusResponse& b) { a.Swap(&b); }
  inline void Swap(SetTestStatusResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTestStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTestStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetTestStatusResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTestStatusResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTestStatusResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.SetTestStatusResponse"; }

 protected:
  explicit SetTestStatusResponse(::google::protobuf::Arena* arena);
  SetTestStatusResponse(::google::protobuf::Arena* arena, const SetTestStatusResponse& from);
  SetTestStatusResponse(::google::protobuf::Arena* arena, SetTestStatusResponse&& from) noexcept
      : SetTestStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.SetTestStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetTestStatusResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class SetTestStatusRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.SetTestStatusRequest) */ {
 public:
  inline SetTestStatusRequest() : SetTestStatusRequest(nullptr) {}
  ~SetTestStatusRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetTestStatusRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetTestStatusRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetTestStatusRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetTestStatusRequest(const SetTestStatusRequest& from) : SetTestStatusRequest(nullptr, from) {}
  inline SetTestStatusRequest(SetTestStatusRequest&& from) noexcept
      : SetTestStatusRequest(nullptr, std::move(from)) {}
  inline SetTestStatusRequest& operator=(const SetTestStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTestStatusRequest& operator=(SetTestStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTestStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTestStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SetTestStatusRequest*>(
        &_SetTestStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 73;
  friend void swap(SetTestStatusRequest& a, SetTestStatusRequest& b) { a.Swap(&b); }
  inline void Swap(SetTestStatusRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTestStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTestStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetTestStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetTestStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetTestStatusRequest& from) { SetTestStatusRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetTestStatusRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.SetTestStatusRequest"; }

 protected:
  explicit SetTestStatusRequest(::google::protobuf::Arena* arena);
  SetTestStatusRequest(::google::protobuf::Arena* arena, const SetTestStatusRequest& from);
  SetTestStatusRequest(::google::protobuf::Arena* arena, SetTestStatusRequest&& from) noexcept
      : SetTestStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .kentik.synthetics.v202101beta1.TestStatus status = 2 [json_name = "status"];
  void clear_status() ;
  ::kentik::synthetics::v202101beta1::TestStatus status() const;
  void set_status(::kentik::synthetics::v202101beta1::TestStatus value);

  private:
  ::kentik::synthetics::v202101beta1::TestStatus _internal_status() const;
  void _internal_set_status(::kentik::synthetics::v202101beta1::TestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.SetTestStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetTestStatusRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Region final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Region) */ {
 public:
  inline Region() : Region(nullptr) {}
  ~Region() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Region* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Region));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Region(
      ::google::protobuf::internal::ConstantInitialized);

  inline Region(const Region& from) : Region(nullptr, from) {}
  inline Region(Region&& from) noexcept
      : Region(nullptr, std::move(from)) {}
  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline Region& operator=(Region&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const Region* internal_default_instance() {
    return reinterpret_cast<const Region*>(
        &_Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(Region& a, Region& b) { a.Swap(&b); }
  inline void Swap(Region* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Region* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Region* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Region>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Region& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Region& from) { Region::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Region* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Region"; }

 protected:
  explicit Region(::google::protobuf::Arena* arena);
  Region(::google::protobuf::Arena* arena, const Region& from);
  Region(::google::protobuf::Arena* arena, Region&& from) noexcept
      : Region(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Region)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Region& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class PingTaskDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.PingTaskDefinition) */ {
 public:
  inline PingTaskDefinition() : PingTaskDefinition(nullptr) {}
  ~PingTaskDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PingTaskDefinition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PingTaskDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PingTaskDefinition(
      ::google::protobuf::internal::ConstantInitialized);

  inline PingTaskDefinition(const PingTaskDefinition& from) : PingTaskDefinition(nullptr, from) {}
  inline PingTaskDefinition(PingTaskDefinition&& from) noexcept
      : PingTaskDefinition(nullptr, std::move(from)) {}
  inline PingTaskDefinition& operator=(const PingTaskDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingTaskDefinition& operator=(PingTaskDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingTaskDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingTaskDefinition* internal_default_instance() {
    return reinterpret_cast<const PingTaskDefinition*>(
        &_PingTaskDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PingTaskDefinition& a, PingTaskDefinition& b) { a.Swap(&b); }
  inline void Swap(PingTaskDefinition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingTaskDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingTaskDefinition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PingTaskDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PingTaskDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PingTaskDefinition& from) { PingTaskDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PingTaskDefinition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.PingTaskDefinition"; }

 protected:
  explicit PingTaskDefinition(::google::protobuf::Arena* arena);
  PingTaskDefinition(::google::protobuf::Arena* arena, const PingTaskDefinition& from);
  PingTaskDefinition(::google::protobuf::Arena* arena, PingTaskDefinition&& from) noexcept
      : PingTaskDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kPeriodFieldNumber = 2,
    kExpiryFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // uint32 period = 2 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 3 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // uint32 count = 4 [json_name = "count"];
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.PingTaskDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PingTaskDefinition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    ::uint32_t count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class MeshMetric final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.MeshMetric) */ {
 public:
  inline MeshMetric() : MeshMetric(nullptr) {}
  ~MeshMetric() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshMetric* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshMetric));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshMetric(
      ::google::protobuf::internal::ConstantInitialized);

  inline MeshMetric(const MeshMetric& from) : MeshMetric(nullptr, from) {}
  inline MeshMetric(MeshMetric&& from) noexcept
      : MeshMetric(nullptr, std::move(from)) {}
  inline MeshMetric& operator=(const MeshMetric& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshMetric& operator=(MeshMetric&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshMetric& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshMetric* internal_default_instance() {
    return reinterpret_cast<const MeshMetric*>(
        &_MeshMetric_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(MeshMetric& a, MeshMetric& b) { a.Swap(&b); }
  inline void Swap(MeshMetric* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshMetric* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshMetric* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshMetric>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshMetric& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshMetric& from) { MeshMetric::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshMetric* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.MeshMetric"; }

 protected:
  explicit MeshMetric(::google::protobuf::Arena* arena);
  MeshMetric(::google::protobuf::Arena* arena, const MeshMetric& from);
  MeshMetric(::google::protobuf::Arena* arena, MeshMetric&& from) noexcept
      : MeshMetric(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kHealthFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string health = 2 [json_name = "health"];
  void clear_health() ;
  const std::string& health() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_health(Arg_&& arg, Args_... args);
  std::string* mutable_health();
  PROTOBUF_NODISCARD std::string* release_health();
  void set_allocated_health(std::string* value);

  private:
  const std::string& _internal_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_health(
      const std::string& value);
  std::string* _internal_mutable_health();

  public:
  // int64 value = 3 [json_name = "value"];
  void clear_value() ;
  ::int64_t value() const;
  void set_value(::int64_t value);

  private:
  ::int64_t _internal_value() const;
  void _internal_set_value(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.MeshMetric)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MeshMetric& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr health_;
    ::int64_t value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ListTestsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ListTestsRequest) */ {
 public:
  inline ListTestsRequest() : ListTestsRequest(nullptr) {}
  ~ListTestsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListTestsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListTestsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListTestsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListTestsRequest(const ListTestsRequest& from) : ListTestsRequest(nullptr, from) {}
  inline ListTestsRequest(ListTestsRequest&& from) noexcept
      : ListTestsRequest(nullptr, std::move(from)) {}
  inline ListTestsRequest& operator=(const ListTestsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTestsRequest& operator=(ListTestsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTestsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTestsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTestsRequest*>(
        &_ListTestsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(ListTestsRequest& a, ListTestsRequest& b) { a.Swap(&b); }
  inline void Swap(ListTestsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTestsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTestsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListTestsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListTestsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListTestsRequest& from) { ListTestsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListTestsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ListTestsRequest"; }

 protected:
  explicit ListTestsRequest(::google::protobuf::Arena* arena);
  ListTestsRequest(::google::protobuf::Arena* arena, const ListTestsRequest& from);
  ListTestsRequest(::google::protobuf::Arena* arena, ListTestsRequest&& from) noexcept
      : ListTestsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPresetFieldNumber = 1,
  };
  // bool preset = 1 [json_name = "preset"];
  void clear_preset() ;
  bool preset() const;
  void set_preset(bool value);

  private:
  bool _internal_preset() const;
  void _internal_set_preset(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ListTestsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListTestsRequest& from_msg);
    bool preset_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ListAgentsRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ListAgentsRequest) */ {
 public:
  inline ListAgentsRequest() : ListAgentsRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListAgentsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListAgentsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListAgentsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListAgentsRequest(const ListAgentsRequest& from) : ListAgentsRequest(nullptr, from) {}
  inline ListAgentsRequest(ListAgentsRequest&& from) noexcept
      : ListAgentsRequest(nullptr, std::move(from)) {}
  inline ListAgentsRequest& operator=(const ListAgentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAgentsRequest& operator=(ListAgentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAgentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAgentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAgentsRequest*>(
        &_ListAgentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(ListAgentsRequest& a, ListAgentsRequest& b) { a.Swap(&b); }
  inline void Swap(ListAgentsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAgentsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAgentsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ListAgentsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListAgentsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListAgentsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ListAgentsRequest"; }

 protected:
  explicit ListAgentsRequest(::google::protobuf::Arena* arena);
  ListAgentsRequest(::google::protobuf::Arena* arena, const ListAgentsRequest& from);
  ListAgentsRequest(::google::protobuf::Arena* arena, ListAgentsRequest&& from) noexcept
      : ListAgentsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ListAgentsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListAgentsRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class KnockTaskDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.KnockTaskDefinition) */ {
 public:
  inline KnockTaskDefinition() : KnockTaskDefinition(nullptr) {}
  ~KnockTaskDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KnockTaskDefinition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KnockTaskDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KnockTaskDefinition(
      ::google::protobuf::internal::ConstantInitialized);

  inline KnockTaskDefinition(const KnockTaskDefinition& from) : KnockTaskDefinition(nullptr, from) {}
  inline KnockTaskDefinition(KnockTaskDefinition&& from) noexcept
      : KnockTaskDefinition(nullptr, std::move(from)) {}
  inline KnockTaskDefinition& operator=(const KnockTaskDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline KnockTaskDefinition& operator=(KnockTaskDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KnockTaskDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const KnockTaskDefinition* internal_default_instance() {
    return reinterpret_cast<const KnockTaskDefinition*>(
        &_KnockTaskDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(KnockTaskDefinition& a, KnockTaskDefinition& b) { a.Swap(&b); }
  inline void Swap(KnockTaskDefinition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KnockTaskDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KnockTaskDefinition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KnockTaskDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KnockTaskDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KnockTaskDefinition& from) { KnockTaskDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KnockTaskDefinition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.KnockTaskDefinition"; }

 protected:
  explicit KnockTaskDefinition(::google::protobuf::Arena* arena);
  KnockTaskDefinition(::google::protobuf::Arena* arena, const KnockTaskDefinition& from);
  KnockTaskDefinition(::google::protobuf::Arena* arena, KnockTaskDefinition&& from) noexcept
      : KnockTaskDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kPeriodFieldNumber = 2,
    kExpiryFieldNumber = 3,
    kCountFieldNumber = 4,
    kPortFieldNumber = 5,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // uint32 period = 2 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 3 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // uint32 count = 4 [json_name = "count"];
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // uint32 port = 5 [json_name = "port"];
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.KnockTaskDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KnockTaskDefinition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    ::uint32_t count_;
    ::uint32_t port_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class IpTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.IpTest) */ {
 public:
  inline IpTest() : IpTest(nullptr) {}
  ~IpTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IpTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IpTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IpTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline IpTest(const IpTest& from) : IpTest(nullptr, from) {}
  inline IpTest(IpTest&& from) noexcept
      : IpTest(nullptr, std::move(from)) {}
  inline IpTest& operator=(const IpTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpTest& operator=(IpTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpTest* internal_default_instance() {
    return reinterpret_cast<const IpTest*>(
        &_IpTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(IpTest& a, IpTest& b) { a.Swap(&b); }
  inline void Swap(IpTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IpTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IpTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IpTest& from) { IpTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IpTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.IpTest"; }

 protected:
  explicit IpTest(::google::protobuf::Arena* arena);
  IpTest(::google::protobuf::Arena* arena, const IpTest& from);
  IpTest(::google::protobuf::Arena* arena, IpTest&& from) noexcept
      : IpTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated string targets = 1 [json_name = "targets"];
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  const std::string& targets(int index) const;
  std::string* mutable_targets(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targets(int index, Arg_&& value, Args_... args);
  std::string* add_targets();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_targets(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_targets();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.IpTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IpTest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> targets_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class IDByIP final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.IDByIP) */ {
 public:
  inline IDByIP() : IDByIP(nullptr) {}
  ~IDByIP() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IDByIP* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IDByIP));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IDByIP(
      ::google::protobuf::internal::ConstantInitialized);

  inline IDByIP(const IDByIP& from) : IDByIP(nullptr, from) {}
  inline IDByIP(IDByIP&& from) noexcept
      : IDByIP(nullptr, std::move(from)) {}
  inline IDByIP& operator=(const IDByIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline IDByIP& operator=(IDByIP&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IDByIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const IDByIP* internal_default_instance() {
    return reinterpret_cast<const IDByIP*>(
        &_IDByIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(IDByIP& a, IDByIP& b) { a.Swap(&b); }
  inline void Swap(IDByIP* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IDByIP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IDByIP* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IDByIP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IDByIP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IDByIP& from) { IDByIP::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IDByIP* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.IDByIP"; }

 protected:
  explicit IDByIP(::google::protobuf::Arena* arena);
  IDByIP(::google::protobuf::Arena* arena, const IDByIP& from);
  IDByIP(::google::protobuf::Arena* arena, IDByIP&& from) noexcept
      : IDByIP(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kIpFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string ip = 2 [json_name = "ip"];
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.IDByIP)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IDByIP& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class HostnameTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.HostnameTest) */ {
 public:
  inline HostnameTest() : HostnameTest(nullptr) {}
  ~HostnameTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HostnameTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HostnameTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HostnameTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline HostnameTest(const HostnameTest& from) : HostnameTest(nullptr, from) {}
  inline HostnameTest(HostnameTest&& from) noexcept
      : HostnameTest(nullptr, std::move(from)) {}
  inline HostnameTest& operator=(const HostnameTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostnameTest& operator=(HostnameTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostnameTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostnameTest* internal_default_instance() {
    return reinterpret_cast<const HostnameTest*>(
        &_HostnameTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(HostnameTest& a, HostnameTest& b) { a.Swap(&b); }
  inline void Swap(HostnameTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostnameTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostnameTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HostnameTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HostnameTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HostnameTest& from) { HostnameTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HostnameTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.HostnameTest"; }

 protected:
  explicit HostnameTest(::google::protobuf::Arena* arena);
  HostnameTest(::google::protobuf::Arena* arena, const HostnameTest& from);
  HostnameTest(::google::protobuf::Arena* arena, HostnameTest&& from) noexcept
      : HostnameTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.HostnameTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HostnameTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class HealthSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.HealthSettings) */ {
 public:
  inline HealthSettings() : HealthSettings(nullptr) {}
  ~HealthSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthSettings* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthSettings(const HealthSettings& from) : HealthSettings(nullptr, from) {}
  inline HealthSettings(HealthSettings&& from) noexcept
      : HealthSettings(nullptr, std::move(from)) {}
  inline HealthSettings& operator=(const HealthSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthSettings& operator=(HealthSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthSettings* internal_default_instance() {
    return reinterpret_cast<const HealthSettings*>(
        &_HealthSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(HealthSettings& a, HealthSettings& b) { a.Swap(&b); }
  inline void Swap(HealthSettings* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthSettings* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthSettings& from) { HealthSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthSettings* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.HealthSettings"; }

 protected:
  explicit HealthSettings(::google::protobuf::Arena* arena);
  HealthSettings(::google::protobuf::Arena* arena, const HealthSettings& from);
  HealthSettings(::google::protobuf::Arena* arena, HealthSettings&& from) noexcept
      : HealthSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHttpValidCodesFieldNumber = 9,
    kDnsValidCodesFieldNumber = 10,
    kLatencyCriticalFieldNumber = 1,
    kLatencyWarningFieldNumber = 2,
    kPacketLossCriticalFieldNumber = 3,
    kPacketLossWarningFieldNumber = 4,
    kJitterCriticalFieldNumber = 5,
    kJitterWarningFieldNumber = 6,
    kHttpLatencyCriticalFieldNumber = 7,
    kHttpLatencyWarningFieldNumber = 8,
    kLatencyCriticalStddevFieldNumber = 11,
    kLatencyWarningStddevFieldNumber = 12,
    kJitterCriticalStddevFieldNumber = 13,
    kJitterWarningStddevFieldNumber = 14,
    kHttpLatencyCriticalStddevFieldNumber = 15,
    kHttpLatencyWarningStddevFieldNumber = 16,
  };
  // repeated uint32 http_valid_codes = 9 [json_name = "httpValidCodes"];
  int http_valid_codes_size() const;
  private:
  int _internal_http_valid_codes_size() const;

  public:
  void clear_http_valid_codes() ;
  ::uint32_t http_valid_codes(int index) const;
  void set_http_valid_codes(int index, ::uint32_t value);
  void add_http_valid_codes(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& http_valid_codes() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_http_valid_codes();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_http_valid_codes() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_http_valid_codes();

  public:
  // repeated uint32 dns_valid_codes = 10 [json_name = "dnsValidCodes"];
  int dns_valid_codes_size() const;
  private:
  int _internal_dns_valid_codes_size() const;

  public:
  void clear_dns_valid_codes() ;
  ::uint32_t dns_valid_codes(int index) const;
  void set_dns_valid_codes(int index, ::uint32_t value);
  void add_dns_valid_codes(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& dns_valid_codes() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_dns_valid_codes();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_dns_valid_codes() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_dns_valid_codes();

  public:
  // float latency_critical = 1 [json_name = "latencyCritical"];
  void clear_latency_critical() ;
  float latency_critical() const;
  void set_latency_critical(float value);

  private:
  float _internal_latency_critical() const;
  void _internal_set_latency_critical(float value);

  public:
  // float latency_warning = 2 [json_name = "latencyWarning"];
  void clear_latency_warning() ;
  float latency_warning() const;
  void set_latency_warning(float value);

  private:
  float _internal_latency_warning() const;
  void _internal_set_latency_warning(float value);

  public:
  // float packet_loss_critical = 3 [json_name = "packetLossCritical"];
  void clear_packet_loss_critical() ;
  float packet_loss_critical() const;
  void set_packet_loss_critical(float value);

  private:
  float _internal_packet_loss_critical() const;
  void _internal_set_packet_loss_critical(float value);

  public:
  // float packet_loss_warning = 4 [json_name = "packetLossWarning"];
  void clear_packet_loss_warning() ;
  float packet_loss_warning() const;
  void set_packet_loss_warning(float value);

  private:
  float _internal_packet_loss_warning() const;
  void _internal_set_packet_loss_warning(float value);

  public:
  // float jitter_critical = 5 [json_name = "jitterCritical"];
  void clear_jitter_critical() ;
  float jitter_critical() const;
  void set_jitter_critical(float value);

  private:
  float _internal_jitter_critical() const;
  void _internal_set_jitter_critical(float value);

  public:
  // float jitter_warning = 6 [json_name = "jitterWarning"];
  void clear_jitter_warning() ;
  float jitter_warning() const;
  void set_jitter_warning(float value);

  private:
  float _internal_jitter_warning() const;
  void _internal_set_jitter_warning(float value);

  public:
  // float http_latency_critical = 7 [json_name = "httpLatencyCritical"];
  void clear_http_latency_critical() ;
  float http_latency_critical() const;
  void set_http_latency_critical(float value);

  private:
  float _internal_http_latency_critical() const;
  void _internal_set_http_latency_critical(float value);

  public:
  // float http_latency_warning = 8 [json_name = "httpLatencyWarning"];
  void clear_http_latency_warning() ;
  float http_latency_warning() const;
  void set_http_latency_warning(float value);

  private:
  float _internal_http_latency_warning() const;
  void _internal_set_http_latency_warning(float value);

  public:
  // float latency_critical_stddev = 11 [json_name = "latencyCriticalStddev"];
  void clear_latency_critical_stddev() ;
  float latency_critical_stddev() const;
  void set_latency_critical_stddev(float value);

  private:
  float _internal_latency_critical_stddev() const;
  void _internal_set_latency_critical_stddev(float value);

  public:
  // float latency_warning_stddev = 12 [json_name = "latencyWarningStddev"];
  void clear_latency_warning_stddev() ;
  float latency_warning_stddev() const;
  void set_latency_warning_stddev(float value);

  private:
  float _internal_latency_warning_stddev() const;
  void _internal_set_latency_warning_stddev(float value);

  public:
  // float jitter_critical_stddev = 13 [json_name = "jitterCriticalStddev"];
  void clear_jitter_critical_stddev() ;
  float jitter_critical_stddev() const;
  void set_jitter_critical_stddev(float value);

  private:
  float _internal_jitter_critical_stddev() const;
  void _internal_set_jitter_critical_stddev(float value);

  public:
  // float jitter_warning_stddev = 14 [json_name = "jitterWarningStddev"];
  void clear_jitter_warning_stddev() ;
  float jitter_warning_stddev() const;
  void set_jitter_warning_stddev(float value);

  private:
  float _internal_jitter_warning_stddev() const;
  void _internal_set_jitter_warning_stddev(float value);

  public:
  // float http_latency_critical_stddev = 15 [json_name = "httpLatencyCriticalStddev"];
  void clear_http_latency_critical_stddev() ;
  float http_latency_critical_stddev() const;
  void set_http_latency_critical_stddev(float value);

  private:
  float _internal_http_latency_critical_stddev() const;
  void _internal_set_http_latency_critical_stddev(float value);

  public:
  // float http_latency_warning_stddev = 16 [json_name = "httpLatencyWarningStddev"];
  void clear_http_latency_warning_stddev() ;
  float http_latency_warning_stddev() const;
  void set_http_latency_warning_stddev(float value);

  private:
  float _internal_http_latency_warning_stddev() const;
  void _internal_set_http_latency_warning_stddev(float value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.HealthSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 16, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthSettings& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> http_valid_codes_;
    ::google::protobuf::internal::CachedSize _http_valid_codes_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> dns_valid_codes_;
    ::google::protobuf::internal::CachedSize _dns_valid_codes_cached_byte_size_;
    float latency_critical_;
    float latency_warning_;
    float packet_loss_critical_;
    float packet_loss_warning_;
    float jitter_critical_;
    float jitter_warning_;
    float http_latency_critical_;
    float http_latency_warning_;
    float latency_critical_stddev_;
    float latency_warning_stddev_;
    float jitter_critical_stddev_;
    float jitter_warning_stddev_;
    float http_latency_critical_stddev_;
    float http_latency_warning_stddev_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class HealthMoment_OtherHealthsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HealthMoment_OtherHealthsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthMoment_OtherHealthsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HealthMoment_OtherHealthsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HealthMoment_OtherHealthsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HealthMoment_OtherHealthsEntry_DoNotUse*>(
        &_HealthMoment_OtherHealthsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      78, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HTTPTaskDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.HTTPTaskDefinition) */ {
 public:
  inline HTTPTaskDefinition() : HTTPTaskDefinition(nullptr) {}
  ~HTTPTaskDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HTTPTaskDefinition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HTTPTaskDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HTTPTaskDefinition(
      ::google::protobuf::internal::ConstantInitialized);

  inline HTTPTaskDefinition(const HTTPTaskDefinition& from) : HTTPTaskDefinition(nullptr, from) {}
  inline HTTPTaskDefinition(HTTPTaskDefinition&& from) noexcept
      : HTTPTaskDefinition(nullptr, std::move(from)) {}
  inline HTTPTaskDefinition& operator=(const HTTPTaskDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline HTTPTaskDefinition& operator=(HTTPTaskDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HTTPTaskDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const HTTPTaskDefinition* internal_default_instance() {
    return reinterpret_cast<const HTTPTaskDefinition*>(
        &_HTTPTaskDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(HTTPTaskDefinition& a, HTTPTaskDefinition& b) { a.Swap(&b); }
  inline void Swap(HTTPTaskDefinition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HTTPTaskDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HTTPTaskDefinition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HTTPTaskDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HTTPTaskDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HTTPTaskDefinition& from) { HTTPTaskDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HTTPTaskDefinition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.HTTPTaskDefinition"; }

 protected:
  explicit HTTPTaskDefinition(::google::protobuf::Arena* arena);
  HTTPTaskDefinition(::google::protobuf::Arena* arena, const HTTPTaskDefinition& from);
  HTTPTaskDefinition(::google::protobuf::Arena* arena, HTTPTaskDefinition&& from) noexcept
      : HTTPTaskDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kPeriodFieldNumber = 2,
    kExpiryFieldNumber = 3,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // uint32 period = 2 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 3 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.HTTPTaskDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HTTPTaskDefinition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class HTTPConfig_HeadersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HTTPConfig_HeadersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HTTPConfig_HeadersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HTTPConfig_HeadersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HTTPConfig_HeadersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HTTPConfig_HeadersEntry_DoNotUse*>(
        &_HTTPConfig_HeadersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HTTPConfig_CssSelectorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HTTPConfig_CssSelectorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HTTPConfig_CssSelectorsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HTTPConfig_CssSelectorsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HTTPConfig_CssSelectorsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HTTPConfig_CssSelectorsEntry_DoNotUse*>(
        &_HTTPConfig_CssSelectorsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      76, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class GridTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GridTest) */ {
 public:
  inline GridTest() : GridTest(nullptr) {}
  ~GridTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GridTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GridTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GridTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GridTest(const GridTest& from) : GridTest(nullptr, from) {}
  inline GridTest(GridTest&& from) noexcept
      : GridTest(nullptr, std::move(from)) {}
  inline GridTest& operator=(const GridTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GridTest& operator=(GridTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GridTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GridTest* internal_default_instance() {
    return reinterpret_cast<const GridTest*>(
        &_GridTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(GridTest& a, GridTest& b) { a.Swap(&b); }
  inline void Swap(GridTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GridTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GridTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GridTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GridTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GridTest& from) { GridTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GridTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GridTest"; }

 protected:
  explicit GridTest(::google::protobuf::Arena* arena);
  GridTest(::google::protobuf::Arena* arena, const GridTest& from);
  GridTest(::google::protobuf::Arena* arena, GridTest&& from) noexcept
      : GridTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated string targets = 1 [json_name = "targets"];
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  const std::string& targets(int index) const;
  std::string* mutable_targets(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targets(int index, Arg_&& value, Args_... args);
  std::string* add_targets();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_targets(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_targets();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GridTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GridTest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> targets_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetTestRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetTestRequest) */ {
 public:
  inline GetTestRequest() : GetTestRequest(nullptr) {}
  ~GetTestRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTestRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTestRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTestRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTestRequest(const GetTestRequest& from) : GetTestRequest(nullptr, from) {}
  inline GetTestRequest(GetTestRequest&& from) noexcept
      : GetTestRequest(nullptr, std::move(from)) {}
  inline GetTestRequest& operator=(const GetTestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTestRequest& operator=(GetTestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTestRequest* internal_default_instance() {
    return reinterpret_cast<const GetTestRequest*>(
        &_GetTestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 71;
  friend void swap(GetTestRequest& a, GetTestRequest& b) { a.Swap(&b); }
  inline void Swap(GetTestRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTestRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTestRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTestRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTestRequest& from) { GetTestRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTestRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetTestRequest"; }

 protected:
  explicit GetTestRequest(::google::protobuf::Arena* arena);
  GetTestRequest(::google::protobuf::Arena* arena, const GetTestRequest& from);
  GetTestRequest(::google::protobuf::Arena* arena, GetTestRequest&& from) noexcept
      : GetTestRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetTestRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTestRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetAgentRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetAgentRequest) */ {
 public:
  inline GetAgentRequest() : GetAgentRequest(nullptr) {}
  ~GetAgentRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetAgentRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetAgentRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAgentRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAgentRequest(const GetAgentRequest& from) : GetAgentRequest(nullptr, from) {}
  inline GetAgentRequest(GetAgentRequest&& from) noexcept
      : GetAgentRequest(nullptr, std::move(from)) {}
  inline GetAgentRequest& operator=(const GetAgentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAgentRequest& operator=(GetAgentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAgentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAgentRequest* internal_default_instance() {
    return reinterpret_cast<const GetAgentRequest*>(
        &_GetAgentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(GetAgentRequest& a, GetAgentRequest& b) { a.Swap(&b); }
  inline void Swap(GetAgentRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAgentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAgentRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetAgentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAgentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAgentRequest& from) { GetAgentRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetAgentRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetAgentRequest"; }

 protected:
  explicit GetAgentRequest(::google::protobuf::Arena* arena);
  GetAgentRequest(::google::protobuf::Arena* arena, const GetAgentRequest& from);
  GetAgentRequest(::google::protobuf::Arena* arena, GetAgentRequest&& from) noexcept
      : GetAgentRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetAgentRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAgentRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class FlowTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.FlowTest) */ {
 public:
  inline FlowTest() : FlowTest(nullptr) {}
  ~FlowTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowTest(const FlowTest& from) : FlowTest(nullptr, from) {}
  inline FlowTest(FlowTest&& from) noexcept
      : FlowTest(nullptr, std::move(from)) {}
  inline FlowTest& operator=(const FlowTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowTest& operator=(FlowTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowTest* internal_default_instance() {
    return reinterpret_cast<const FlowTest*>(
        &_FlowTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(FlowTest& a, FlowTest& b) { a.Swap(&b); }
  inline void Swap(FlowTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowTest& from) { FlowTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.FlowTest"; }

 protected:
  explicit FlowTest(::google::protobuf::Arena* arena);
  FlowTest(::google::protobuf::Arena* arena, const FlowTest& from);
  FlowTest(::google::protobuf::Arena* arena, FlowTest&& from) noexcept
      : FlowTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kTypeFieldNumber = 4,
    kInetDirectionFieldNumber = 5,
    kDirectionFieldNumber = 6,
    kTargetRefreshIntervalMillisFieldNumber = 2,
    kMaxTasksFieldNumber = 3,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // string type = 4 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string inet_direction = 5 [json_name = "inetDirection"];
  void clear_inet_direction() ;
  const std::string& inet_direction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_inet_direction(Arg_&& arg, Args_... args);
  std::string* mutable_inet_direction();
  PROTOBUF_NODISCARD std::string* release_inet_direction();
  void set_allocated_inet_direction(std::string* value);

  private:
  const std::string& _internal_inet_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inet_direction(
      const std::string& value);
  std::string* _internal_mutable_inet_direction();

  public:
  // string direction = 6 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* value);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // uint32 target_refresh_interval_millis = 2 [json_name = "targetRefreshIntervalMillis"];
  void clear_target_refresh_interval_millis() ;
  ::uint32_t target_refresh_interval_millis() const;
  void set_target_refresh_interval_millis(::uint32_t value);

  private:
  ::uint32_t _internal_target_refresh_interval_millis() const;
  void _internal_set_target_refresh_interval_millis(::uint32_t value);

  public:
  // uint32 max_tasks = 3 [json_name = "maxTasks"];
  void clear_max_tasks() ;
  ::uint32_t max_tasks() const;
  void set_max_tasks(::uint32_t value);

  private:
  ::uint32_t _internal_max_tasks() const;
  void _internal_set_max_tasks(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.FlowTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      81, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr inet_direction_;
    ::google::protobuf::internal::ArenaStringPtr direction_;
    ::uint32_t target_refresh_interval_millis_;
    ::uint32_t max_tasks_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DnsTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DnsTest) */ {
 public:
  inline DnsTest() : DnsTest(nullptr) {}
  ~DnsTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DnsTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DnsTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DnsTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DnsTest(const DnsTest& from) : DnsTest(nullptr, from) {}
  inline DnsTest(DnsTest&& from) noexcept
      : DnsTest(nullptr, std::move(from)) {}
  inline DnsTest& operator=(const DnsTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DnsTest& operator=(DnsTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DnsTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DnsTest* internal_default_instance() {
    return reinterpret_cast<const DnsTest*>(
        &_DnsTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(DnsTest& a, DnsTest& b) { a.Swap(&b); }
  inline void Swap(DnsTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DnsTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DnsTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DnsTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DnsTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DnsTest& from) { DnsTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DnsTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DnsTest"; }

 protected:
  explicit DnsTest(::google::protobuf::Arena* arena);
  DnsTest(::google::protobuf::Arena* arena, const DnsTest& from);
  DnsTest(::google::protobuf::Arena* arena, DnsTest&& from) noexcept
      : DnsTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // .kentik.synthetics.v202101beta1.DNSRecord type = 2 [json_name = "type"];
  void clear_type() ;
  ::kentik::synthetics::v202101beta1::DNSRecord type() const;
  void set_type(::kentik::synthetics::v202101beta1::DNSRecord value);

  private:
  ::kentik::synthetics::v202101beta1::DNSRecord _internal_type() const;
  void _internal_set_type(::kentik::synthetics::v202101beta1::DNSRecord value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DnsTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DnsTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    int type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DnsGridTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DnsGridTest) */ {
 public:
  inline DnsGridTest() : DnsGridTest(nullptr) {}
  ~DnsGridTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DnsGridTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DnsGridTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DnsGridTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DnsGridTest(const DnsGridTest& from) : DnsGridTest(nullptr, from) {}
  inline DnsGridTest(DnsGridTest&& from) noexcept
      : DnsGridTest(nullptr, std::move(from)) {}
  inline DnsGridTest& operator=(const DnsGridTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DnsGridTest& operator=(DnsGridTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DnsGridTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DnsGridTest* internal_default_instance() {
    return reinterpret_cast<const DnsGridTest*>(
        &_DnsGridTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(DnsGridTest& a, DnsGridTest& b) { a.Swap(&b); }
  inline void Swap(DnsGridTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DnsGridTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DnsGridTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DnsGridTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DnsGridTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DnsGridTest& from) { DnsGridTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DnsGridTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DnsGridTest"; }

 protected:
  explicit DnsGridTest(::google::protobuf::Arena* arena);
  DnsGridTest(::google::protobuf::Arena* arena, const DnsGridTest& from);
  DnsGridTest(::google::protobuf::Arena* arena, DnsGridTest&& from) noexcept
      : DnsGridTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated string targets = 1 [json_name = "targets"];
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  const std::string& targets(int index) const;
  std::string* mutable_targets(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targets(int index, Arg_&& value, Args_... args);
  std::string* add_targets();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_targets(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_targets();

  public:
  // .kentik.synthetics.v202101beta1.DNSRecord type = 2 [json_name = "type"];
  void clear_type() ;
  ::kentik::synthetics::v202101beta1::DNSRecord type() const;
  void set_type(::kentik::synthetics::v202101beta1::DNSRecord value);

  private:
  ::kentik::synthetics::v202101beta1::DNSRecord _internal_type() const;
  void _internal_set_type(::kentik::synthetics::v202101beta1::DNSRecord value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DnsGridTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DnsGridTest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> targets_;
    int type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DeleteTestResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DeleteTestResponse) */ {
 public:
  inline DeleteTestResponse() : DeleteTestResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteTestResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteTestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteTestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteTestResponse(const DeleteTestResponse& from) : DeleteTestResponse(nullptr, from) {}
  inline DeleteTestResponse(DeleteTestResponse&& from) noexcept
      : DeleteTestResponse(nullptr, std::move(from)) {}
  inline DeleteTestResponse& operator=(const DeleteTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTestResponse& operator=(DeleteTestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTestResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTestResponse*>(
        &_DeleteTestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 78;
  friend void swap(DeleteTestResponse& a, DeleteTestResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteTestResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTestResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteTestResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteTestResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteTestResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DeleteTestResponse"; }

 protected:
  explicit DeleteTestResponse(::google::protobuf::Arena* arena);
  DeleteTestResponse(::google::protobuf::Arena* arena, const DeleteTestResponse& from);
  DeleteTestResponse(::google::protobuf::Arena* arena, DeleteTestResponse&& from) noexcept
      : DeleteTestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DeleteTestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteTestResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DeleteTestRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DeleteTestRequest) */ {
 public:
  inline DeleteTestRequest() : DeleteTestRequest(nullptr) {}
  ~DeleteTestRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteTestRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteTestRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteTestRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteTestRequest(const DeleteTestRequest& from) : DeleteTestRequest(nullptr, from) {}
  inline DeleteTestRequest(DeleteTestRequest&& from) noexcept
      : DeleteTestRequest(nullptr, std::move(from)) {}
  inline DeleteTestRequest& operator=(const DeleteTestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTestRequest& operator=(DeleteTestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTestRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTestRequest*>(
        &_DeleteTestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 77;
  friend void swap(DeleteTestRequest& a, DeleteTestRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteTestRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTestRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteTestRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteTestRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteTestRequest& from) { DeleteTestRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteTestRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DeleteTestRequest"; }

 protected:
  explicit DeleteTestRequest(::google::protobuf::Arena* arena);
  DeleteTestRequest(::google::protobuf::Arena* arena, const DeleteTestRequest& from);
  DeleteTestRequest(::google::protobuf::Arena* arena, DeleteTestRequest&& from) noexcept
      : DeleteTestRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DeleteTestRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      59, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteTestRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DeleteAgentResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DeleteAgentResponse) */ {
 public:
  inline DeleteAgentResponse() : DeleteAgentResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteAgentResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteAgentResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAgentResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteAgentResponse(const DeleteAgentResponse& from) : DeleteAgentResponse(nullptr, from) {}
  inline DeleteAgentResponse(DeleteAgentResponse&& from) noexcept
      : DeleteAgentResponse(nullptr, std::move(from)) {}
  inline DeleteAgentResponse& operator=(const DeleteAgentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAgentResponse& operator=(DeleteAgentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAgentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAgentResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteAgentResponse*>(
        &_DeleteAgentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(DeleteAgentResponse& a, DeleteAgentResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteAgentResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAgentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAgentResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteAgentResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteAgentResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteAgentResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DeleteAgentResponse"; }

 protected:
  explicit DeleteAgentResponse(::google::protobuf::Arena* arena);
  DeleteAgentResponse(::google::protobuf::Arena* arena, const DeleteAgentResponse& from);
  DeleteAgentResponse(::google::protobuf::Arena* arena, DeleteAgentResponse&& from) noexcept
      : DeleteAgentResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DeleteAgentResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteAgentResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DeleteAgentRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DeleteAgentRequest) */ {
 public:
  inline DeleteAgentRequest() : DeleteAgentRequest(nullptr) {}
  ~DeleteAgentRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteAgentRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteAgentRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAgentRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteAgentRequest(const DeleteAgentRequest& from) : DeleteAgentRequest(nullptr, from) {}
  inline DeleteAgentRequest(DeleteAgentRequest&& from) noexcept
      : DeleteAgentRequest(nullptr, std::move(from)) {}
  inline DeleteAgentRequest& operator=(const DeleteAgentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAgentRequest& operator=(DeleteAgentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAgentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAgentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAgentRequest*>(
        &_DeleteAgentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(DeleteAgentRequest& a, DeleteAgentRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteAgentRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAgentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAgentRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteAgentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteAgentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteAgentRequest& from) { DeleteAgentRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteAgentRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DeleteAgentRequest"; }

 protected:
  explicit DeleteAgentRequest(::google::protobuf::Arena* arena);
  DeleteAgentRequest(::google::protobuf::Arena* arena, const DeleteAgentRequest& from);
  DeleteAgentRequest(::google::protobuf::Arena* arena, DeleteAgentRequest&& from) noexcept
      : DeleteAgentRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DeleteAgentRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteAgentRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DNSTaskDefinition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DNSTaskDefinition) */ {
 public:
  inline DNSTaskDefinition() : DNSTaskDefinition(nullptr) {}
  ~DNSTaskDefinition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DNSTaskDefinition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DNSTaskDefinition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DNSTaskDefinition(
      ::google::protobuf::internal::ConstantInitialized);

  inline DNSTaskDefinition(const DNSTaskDefinition& from) : DNSTaskDefinition(nullptr, from) {}
  inline DNSTaskDefinition(DNSTaskDefinition&& from) noexcept
      : DNSTaskDefinition(nullptr, std::move(from)) {}
  inline DNSTaskDefinition& operator=(const DNSTaskDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNSTaskDefinition& operator=(DNSTaskDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNSTaskDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNSTaskDefinition* internal_default_instance() {
    return reinterpret_cast<const DNSTaskDefinition*>(
        &_DNSTaskDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(DNSTaskDefinition& a, DNSTaskDefinition& b) { a.Swap(&b); }
  inline void Swap(DNSTaskDefinition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNSTaskDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DNSTaskDefinition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DNSTaskDefinition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DNSTaskDefinition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DNSTaskDefinition& from) { DNSTaskDefinition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DNSTaskDefinition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DNSTaskDefinition"; }

 protected:
  explicit DNSTaskDefinition(::google::protobuf::Arena* arena);
  DNSTaskDefinition(::google::protobuf::Arena* arena, const DNSTaskDefinition& from);
  DNSTaskDefinition(::google::protobuf::Arena* arena, DNSTaskDefinition&& from) noexcept
      : DNSTaskDefinition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
    kTypeFieldNumber = 6,
    kResolverFieldNumber = 7,
    kPeriodFieldNumber = 2,
    kExpiryFieldNumber = 3,
    kCountFieldNumber = 4,
    kPortFieldNumber = 5,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // string type = 6 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string resolver = 7 [json_name = "resolver"];
  void clear_resolver() ;
  const std::string& resolver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolver(Arg_&& arg, Args_... args);
  std::string* mutable_resolver();
  PROTOBUF_NODISCARD std::string* release_resolver();
  void set_allocated_resolver(std::string* value);

  private:
  const std::string& _internal_resolver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolver(
      const std::string& value);
  std::string* _internal_mutable_resolver();

  public:
  // uint32 period = 2 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 3 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // uint32 count = 4 [json_name = "count"];
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // uint32 port = 5 [json_name = "port"];
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DNSTaskDefinition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      75, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DNSTaskDefinition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr resolver_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    ::uint32_t count_;
    ::uint32_t port_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class DNS final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.DNS) */ {
 public:
  inline DNS() : DNS(nullptr) {}
  ~DNS() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DNS* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DNS));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DNS(
      ::google::protobuf::internal::ConstantInitialized);

  inline DNS(const DNS& from) : DNS(nullptr, from) {}
  inline DNS(DNS&& from) noexcept
      : DNS(nullptr, std::move(from)) {}
  inline DNS& operator=(const DNS& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNS& operator=(DNS&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DNS& default_instance() {
    return *internal_default_instance();
  }
  static inline const DNS* internal_default_instance() {
    return reinterpret_cast<const DNS*>(
        &_DNS_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(DNS& a, DNS& b) { a.Swap(&b); }
  inline void Swap(DNS* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DNS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DNS* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DNS>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DNS& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DNS& from) { DNS::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DNS* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.DNS"; }

 protected:
  explicit DNS(::google::protobuf::Arena* arena);
  DNS(::google::protobuf::Arena* arena, const DNS& from);
  DNS(::google::protobuf::Arena* arena, DNS&& from) noexcept
      : DNS(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.DNS)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DNS& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Country final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Country) */ {
 public:
  inline Country() : Country(nullptr) {}
  ~Country() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Country* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Country));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Country(
      ::google::protobuf::internal::ConstantInitialized);

  inline Country(const Country& from) : Country(nullptr, from) {}
  inline Country(Country&& from) noexcept
      : Country(nullptr, std::move(from)) {}
  inline Country& operator=(const Country& from) {
    CopyFrom(from);
    return *this;
  }
  inline Country& operator=(Country&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Country& default_instance() {
    return *internal_default_instance();
  }
  static inline const Country* internal_default_instance() {
    return reinterpret_cast<const Country*>(
        &_Country_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(Country& a, Country& b) { a.Swap(&b); }
  inline void Swap(Country* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Country* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Country* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Country>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Country& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Country& from) { Country::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Country* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Country"; }

 protected:
  explicit Country(::google::protobuf::Arena* arena);
  Country(::google::protobuf::Arena* arena, const Country& from);
  Country(::google::protobuf::Arena* arena, Country&& from) noexcept
      : Country(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCodeFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string code = 1 [json_name = "code"];
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Country)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Country& from_msg);
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class City final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.City) */ {
 public:
  inline City() : City(nullptr) {}
  ~City() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(City* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(City));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR City(
      ::google::protobuf::internal::ConstantInitialized);

  inline City(const City& from) : City(nullptr, from) {}
  inline City(City&& from) noexcept
      : City(nullptr, std::move(from)) {}
  inline City& operator=(const City& from) {
    CopyFrom(from);
    return *this;
  }
  inline City& operator=(City&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const City& default_instance() {
    return *internal_default_instance();
  }
  static inline const City* internal_default_instance() {
    return reinterpret_cast<const City*>(
        &_City_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(City& a, City& b) { a.Swap(&b); }
  inline void Swap(City* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(City* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  City* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<City>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const City& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const City& from) { City::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(City* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.City"; }

 protected:
  explicit City(::google::protobuf::Arena* arena);
  City(::google::protobuf::Arena* arena, const City& from);
  City(::google::protobuf::Arena* arena, City&& from) noexcept
      : City(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLatitudeFieldNumber = 8,
    kLongitudeFieldNumber = 9,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // double latitude = 8 [json_name = "latitude"];
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // double longitude = 9 [json_name = "longitude"];
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.City)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const City& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    double latitude_;
    double longitude_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ApplicationMeshTest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ApplicationMeshTest) */ {
 public:
  inline ApplicationMeshTest() : ApplicationMeshTest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApplicationMeshTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApplicationMeshTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApplicationMeshTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApplicationMeshTest(const ApplicationMeshTest& from) : ApplicationMeshTest(nullptr, from) {}
  inline ApplicationMeshTest(ApplicationMeshTest&& from) noexcept
      : ApplicationMeshTest(nullptr, std::move(from)) {}
  inline ApplicationMeshTest& operator=(const ApplicationMeshTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationMeshTest& operator=(ApplicationMeshTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationMeshTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationMeshTest* internal_default_instance() {
    return reinterpret_cast<const ApplicationMeshTest*>(
        &_ApplicationMeshTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(ApplicationMeshTest& a, ApplicationMeshTest& b) { a.Swap(&b); }
  inline void Swap(ApplicationMeshTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationMeshTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplicationMeshTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ApplicationMeshTest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ApplicationMeshTest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ApplicationMeshTest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ApplicationMeshTest"; }

 protected:
  explicit ApplicationMeshTest(::google::protobuf::Arena* arena);
  ApplicationMeshTest(::google::protobuf::Arena* arena, const ApplicationMeshTest& from);
  ApplicationMeshTest(::google::protobuf::Arena* arena, ApplicationMeshTest&& from) noexcept
      : ApplicationMeshTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ApplicationMeshTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApplicationMeshTest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class AgentTest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.AgentTest) */ {
 public:
  inline AgentTest() : AgentTest(nullptr) {}
  ~AgentTest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AgentTest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AgentTest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AgentTest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AgentTest(const AgentTest& from) : AgentTest(nullptr, from) {}
  inline AgentTest(AgentTest&& from) noexcept
      : AgentTest(nullptr, std::move(from)) {}
  inline AgentTest& operator=(const AgentTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentTest& operator=(AgentTest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentTest* internal_default_instance() {
    return reinterpret_cast<const AgentTest*>(
        &_AgentTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(AgentTest& a, AgentTest& b) { a.Swap(&b); }
  inline void Swap(AgentTest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentTest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentTest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AgentTest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AgentTest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AgentTest& from) { AgentTest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AgentTest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.AgentTest"; }

 protected:
  explicit AgentTest(::google::protobuf::Arena* arena);
  AgentTest(::google::protobuf::Arena* arena, const AgentTest& from);
  AgentTest(::google::protobuf::Arena* arena, AgentTest&& from) noexcept
      : AgentTest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // string target = 1 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.AgentTest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AgentTest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class AgentTaskConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.AgentTaskConfig) */ {
 public:
  inline AgentTaskConfig() : AgentTaskConfig(nullptr) {}
  ~AgentTaskConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AgentTaskConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AgentTaskConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AgentTaskConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline AgentTaskConfig(const AgentTaskConfig& from) : AgentTaskConfig(nullptr, from) {}
  inline AgentTaskConfig(AgentTaskConfig&& from) noexcept
      : AgentTaskConfig(nullptr, std::move(from)) {}
  inline AgentTaskConfig& operator=(const AgentTaskConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentTaskConfig& operator=(AgentTaskConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentTaskConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentTaskConfig* internal_default_instance() {
    return reinterpret_cast<const AgentTaskConfig*>(
        &_AgentTaskConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(AgentTaskConfig& a, AgentTaskConfig& b) { a.Swap(&b); }
  inline void Swap(AgentTaskConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentTaskConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentTaskConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AgentTaskConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AgentTaskConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AgentTaskConfig& from) { AgentTaskConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AgentTaskConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.AgentTaskConfig"; }

 protected:
  explicit AgentTaskConfig(::google::protobuf::Arena* arena);
  AgentTaskConfig(::google::protobuf::Arena* arena, const AgentTaskConfig& from);
  AgentTaskConfig(::google::protobuf::Arena* arena, AgentTaskConfig&& from) noexcept
      : AgentTaskConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated string targets = 2 [json_name = "targets"];
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  const std::string& targets(int index) const;
  std::string* mutable_targets(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targets(int index, Arg_&& value, Args_... args);
  std::string* add_targets();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_targets(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_targets();

  public:
  // uint64 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.AgentTaskConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AgentTaskConfig& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> targets_;
    ::uint64_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ASN final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ASN) */ {
 public:
  inline ASN() : ASN(nullptr) {}
  ~ASN() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ASN* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ASN));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ASN(
      ::google::protobuf::internal::ConstantInitialized);

  inline ASN(const ASN& from) : ASN(nullptr, from) {}
  inline ASN(ASN&& from) noexcept
      : ASN(nullptr, std::move(from)) {}
  inline ASN& operator=(const ASN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASN& operator=(ASN&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASN* internal_default_instance() {
    return reinterpret_cast<const ASN*>(
        &_ASN_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(ASN& a, ASN& b) { a.Swap(&b); }
  inline void Swap(ASN* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASN* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ASN>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ASN& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ASN& from) { ASN::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ASN* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ASN"; }

 protected:
  explicit ASN(::google::protobuf::Arena* arena);
  ASN(::google::protobuf::Arena* arena, const ASN& from);
  ASN(::google::protobuf::Arena* arena, ASN&& from) noexcept
      : ASN(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint32 id = 1 [json_name = "id"];
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ASN)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ASN& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TraceProbe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TraceProbe) */ {
 public:
  inline TraceProbe() : TraceProbe(nullptr) {}
  ~TraceProbe() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TraceProbe* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TraceProbe));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TraceProbe(
      ::google::protobuf::internal::ConstantInitialized);

  inline TraceProbe(const TraceProbe& from) : TraceProbe(nullptr, from) {}
  inline TraceProbe(TraceProbe&& from) noexcept
      : TraceProbe(nullptr, std::move(from)) {}
  inline TraceProbe& operator=(const TraceProbe& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceProbe& operator=(TraceProbe&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceProbe& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceProbe* internal_default_instance() {
    return reinterpret_cast<const TraceProbe*>(
        &_TraceProbe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(TraceProbe& a, TraceProbe& b) { a.Swap(&b); }
  inline void Swap(TraceProbe* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceProbe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceProbe* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TraceProbe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TraceProbe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TraceProbe& from) { TraceProbe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TraceProbe* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TraceProbe"; }

 protected:
  explicit TraceProbe(::google::protobuf::Arena* arena);
  TraceProbe(::google::protobuf::Arena* arena, const TraceProbe& from);
  TraceProbe(::google::protobuf::Arena* arena, TraceProbe&& from) noexcept
      : TraceProbe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAsPathFieldNumber = 1,
    kRegionPathFieldNumber = 4,
    kSitePathFieldNumber = 5,
    kHopsFieldNumber = 6,
    kCompletedFieldNumber = 2,
    kHopCountFieldNumber = 3,
  };
  // repeated int32 as_path = 1 [json_name = "asPath"];
  int as_path_size() const;
  private:
  int _internal_as_path_size() const;

  public:
  void clear_as_path() ;
  ::int32_t as_path(int index) const;
  void set_as_path(int index, ::int32_t value);
  void add_as_path(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& as_path() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_as_path();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_as_path() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_as_path();

  public:
  // repeated string region_path = 4 [json_name = "regionPath"];
  int region_path_size() const;
  private:
  int _internal_region_path_size() const;

  public:
  void clear_region_path() ;
  const std::string& region_path(int index) const;
  std::string* mutable_region_path(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region_path(int index, Arg_&& value, Args_... args);
  std::string* add_region_path();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_region_path(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& region_path() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_region_path();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_region_path() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_region_path();

  public:
  // repeated int32 site_path = 5 [json_name = "sitePath"];
  int site_path_size() const;
  private:
  int _internal_site_path_size() const;

  public:
  void clear_site_path() ;
  ::int32_t site_path(int index) const;
  void set_site_path(int index, ::int32_t value);
  void add_site_path(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& site_path() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_site_path();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_site_path() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_site_path();

  public:
  // repeated .kentik.synthetics.v202101beta1.TraceHop hops = 6 [json_name = "hops"];
  int hops_size() const;
  private:
  int _internal_hops_size() const;

  public:
  void clear_hops() ;
  ::kentik::synthetics::v202101beta1::TraceHop* mutable_hops(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>* mutable_hops();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>& _internal_hops() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>* _internal_mutable_hops();
  public:
  const ::kentik::synthetics::v202101beta1::TraceHop& hops(int index) const;
  ::kentik::synthetics::v202101beta1::TraceHop* add_hops();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>& hops() const;
  // bool completed = 2 [json_name = "completed"];
  void clear_completed() ;
  bool completed() const;
  void set_completed(bool value);

  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);

  public:
  // int32 hop_count = 3 [json_name = "hopCount"];
  void clear_hop_count() ;
  ::int32_t hop_count() const;
  void set_hop_count(::int32_t value);

  private:
  ::int32_t _internal_hop_count() const;
  void _internal_set_hop_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TraceProbe)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TraceProbe& from_msg);
    ::google::protobuf::RepeatedField<::int32_t> as_path_;
    ::google::protobuf::internal::CachedSize _as_path_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> region_path_;
    ::google::protobuf::RepeatedField<::int32_t> site_path_;
    ::google::protobuf::internal::CachedSize _site_path_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::TraceHop > hops_;
    bool completed_;
    ::int32_t hop_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Task final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Task* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Task));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task(
      ::google::protobuf::internal::ConstantInitialized);

  inline Task(const Task& from) : Task(nullptr, from) {}
  inline Task(Task&& from) noexcept
      : Task(nullptr, std::move(from)) {}
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  enum DefinitionCase {
    kPing = 9,
    kTraceroute = 10,
    kHttp = 11,
    kKnock = 12,
    kDns = 13,
    kShake = 14,
    DEFINITION_NOT_SET = 0,
  };
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
        &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Task& a, Task& b) { a.Swap(&b); }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Task& from) { Task::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Task* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Task"; }

 protected:
  explicit Task(::google::protobuf::Arena* arena);
  Task(::google::protobuf::Arena* arena, const Task& from);
  Task(::google::protobuf::Arena* arena, Task&& from) noexcept
      : Task(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kTestIdFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kStatusFieldNumber = 5,
    kStateFieldNumber = 4,
    kFamilyFieldNumber = 6,
    kPingFieldNumber = 9,
    kTracerouteFieldNumber = 10,
    kHttpFieldNumber = 11,
    kKnockFieldNumber = 12,
    kDnsFieldNumber = 13,
    kShakeFieldNumber = 14,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string test_id = 2 [json_name = "testId"];
  void clear_test_id() ;
  const std::string& test_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_test_id(Arg_&& arg, Args_... args);
  std::string* mutable_test_id();
  PROTOBUF_NODISCARD std::string* release_test_id();
  void set_allocated_test_id(std::string* value);

  private:
  const std::string& _internal_test_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test_id(
      const std::string& value);
  std::string* _internal_mutable_test_id();

  public:
  // string device_id = 3 [json_name = "deviceId"];
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // string status = 5 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // .kentik.synthetics.v202101beta1.TaskState state = 4 [json_name = "state"];
  void clear_state() ;
  ::kentik::synthetics::v202101beta1::TaskState state() const;
  void set_state(::kentik::synthetics::v202101beta1::TaskState value);

  private:
  ::kentik::synthetics::v202101beta1::TaskState _internal_state() const;
  void _internal_set_state(::kentik::synthetics::v202101beta1::TaskState value);

  public:
  // .kentik.synthetics.v202101beta1.IPFamily family = 6 [json_name = "family"];
  void clear_family() ;
  ::kentik::synthetics::v202101beta1::IPFamily family() const;
  void set_family(::kentik::synthetics::v202101beta1::IPFamily value);

  private:
  ::kentik::synthetics::v202101beta1::IPFamily _internal_family() const;
  void _internal_set_family(::kentik::synthetics::v202101beta1::IPFamily value);

  public:
  // .kentik.synthetics.v202101beta1.PingTaskDefinition ping = 9 [json_name = "ping"];
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;

  public:
  void clear_ping() ;
  const ::kentik::synthetics::v202101beta1::PingTaskDefinition& ping() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::PingTaskDefinition* release_ping();
  ::kentik::synthetics::v202101beta1::PingTaskDefinition* mutable_ping();
  void set_allocated_ping(::kentik::synthetics::v202101beta1::PingTaskDefinition* value);
  void unsafe_arena_set_allocated_ping(::kentik::synthetics::v202101beta1::PingTaskDefinition* value);
  ::kentik::synthetics::v202101beta1::PingTaskDefinition* unsafe_arena_release_ping();

  private:
  const ::kentik::synthetics::v202101beta1::PingTaskDefinition& _internal_ping() const;
  ::kentik::synthetics::v202101beta1::PingTaskDefinition* _internal_mutable_ping();

  public:
  // .kentik.synthetics.v202101beta1.TraceTaskDefinition traceroute = 10 [json_name = "traceroute"];
  bool has_traceroute() const;
  private:
  bool _internal_has_traceroute() const;

  public:
  void clear_traceroute() ;
  const ::kentik::synthetics::v202101beta1::TraceTaskDefinition& traceroute() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TraceTaskDefinition* release_traceroute();
  ::kentik::synthetics::v202101beta1::TraceTaskDefinition* mutable_traceroute();
  void set_allocated_traceroute(::kentik::synthetics::v202101beta1::TraceTaskDefinition* value);
  void unsafe_arena_set_allocated_traceroute(::kentik::synthetics::v202101beta1::TraceTaskDefinition* value);
  ::kentik::synthetics::v202101beta1::TraceTaskDefinition* unsafe_arena_release_traceroute();

  private:
  const ::kentik::synthetics::v202101beta1::TraceTaskDefinition& _internal_traceroute() const;
  ::kentik::synthetics::v202101beta1::TraceTaskDefinition* _internal_mutable_traceroute();

  public:
  // .kentik.synthetics.v202101beta1.HTTPTaskDefinition http = 11 [json_name = "http"];
  bool has_http() const;
  private:
  bool _internal_has_http() const;

  public:
  void clear_http() ;
  const ::kentik::synthetics::v202101beta1::HTTPTaskDefinition& http() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* release_http();
  ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* mutable_http();
  void set_allocated_http(::kentik::synthetics::v202101beta1::HTTPTaskDefinition* value);
  void unsafe_arena_set_allocated_http(::kentik::synthetics::v202101beta1::HTTPTaskDefinition* value);
  ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* unsafe_arena_release_http();

  private:
  const ::kentik::synthetics::v202101beta1::HTTPTaskDefinition& _internal_http() const;
  ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* _internal_mutable_http();

  public:
  // .kentik.synthetics.v202101beta1.KnockTaskDefinition knock = 12 [json_name = "knock"];
  bool has_knock() const;
  private:
  bool _internal_has_knock() const;

  public:
  void clear_knock() ;
  const ::kentik::synthetics::v202101beta1::KnockTaskDefinition& knock() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::KnockTaskDefinition* release_knock();
  ::kentik::synthetics::v202101beta1::KnockTaskDefinition* mutable_knock();
  void set_allocated_knock(::kentik::synthetics::v202101beta1::KnockTaskDefinition* value);
  void unsafe_arena_set_allocated_knock(::kentik::synthetics::v202101beta1::KnockTaskDefinition* value);
  ::kentik::synthetics::v202101beta1::KnockTaskDefinition* unsafe_arena_release_knock();

  private:
  const ::kentik::synthetics::v202101beta1::KnockTaskDefinition& _internal_knock() const;
  ::kentik::synthetics::v202101beta1::KnockTaskDefinition* _internal_mutable_knock();

  public:
  // .kentik.synthetics.v202101beta1.DNSTaskDefinition dns = 13 [json_name = "dns"];
  bool has_dns() const;
  private:
  bool _internal_has_dns() const;

  public:
  void clear_dns() ;
  const ::kentik::synthetics::v202101beta1::DNSTaskDefinition& dns() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::DNSTaskDefinition* release_dns();
  ::kentik::synthetics::v202101beta1::DNSTaskDefinition* mutable_dns();
  void set_allocated_dns(::kentik::synthetics::v202101beta1::DNSTaskDefinition* value);
  void unsafe_arena_set_allocated_dns(::kentik::synthetics::v202101beta1::DNSTaskDefinition* value);
  ::kentik::synthetics::v202101beta1::DNSTaskDefinition* unsafe_arena_release_dns();

  private:
  const ::kentik::synthetics::v202101beta1::DNSTaskDefinition& _internal_dns() const;
  ::kentik::synthetics::v202101beta1::DNSTaskDefinition* _internal_mutable_dns();

  public:
  // .kentik.synthetics.v202101beta1.ShakeTaskDefinition shake = 14 [json_name = "shake"];
  bool has_shake() const;
  private:
  bool _internal_has_shake() const;

  public:
  void clear_shake() ;
  const ::kentik::synthetics::v202101beta1::ShakeTaskDefinition& shake() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* release_shake();
  ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* mutable_shake();
  void set_allocated_shake(::kentik::synthetics::v202101beta1::ShakeTaskDefinition* value);
  void unsafe_arena_set_allocated_shake(::kentik::synthetics::v202101beta1::ShakeTaskDefinition* value);
  ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* unsafe_arena_release_shake();

  private:
  const ::kentik::synthetics::v202101beta1::ShakeTaskDefinition& _internal_shake() const;
  ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* _internal_mutable_shake();

  public:
  void clear_definition();
  DefinitionCase definition_case() const;
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Task)
 private:
  class _Internal;
  void set_has_ping();
  void set_has_traceroute();
  void set_has_http();
  void set_has_knock();
  void set_has_dns();
  void set_has_shake();
  inline bool has_definition() const;
  inline void clear_has_definition();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 12, 6,
      76, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Task& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr test_id_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    int state_;
    int family_;
    union DefinitionUnion {
      constexpr DefinitionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::kentik::synthetics::v202101beta1::PingTaskDefinition* ping_;
      ::kentik::synthetics::v202101beta1::TraceTaskDefinition* traceroute_;
      ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* http_;
      ::kentik::synthetics::v202101beta1::KnockTaskDefinition* knock_;
      ::kentik::synthetics::v202101beta1::DNSTaskDefinition* dns_;
      ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* shake_;
    } definition_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class MeshMetrics final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.MeshMetrics) */ {
 public:
  inline MeshMetrics() : MeshMetrics(nullptr) {}
  ~MeshMetrics() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshMetrics* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshMetrics));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshMetrics(
      ::google::protobuf::internal::ConstantInitialized);

  inline MeshMetrics(const MeshMetrics& from) : MeshMetrics(nullptr, from) {}
  inline MeshMetrics(MeshMetrics&& from) noexcept
      : MeshMetrics(nullptr, std::move(from)) {}
  inline MeshMetrics& operator=(const MeshMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshMetrics& operator=(MeshMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshMetrics* internal_default_instance() {
    return reinterpret_cast<const MeshMetrics*>(
        &_MeshMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(MeshMetrics& a, MeshMetrics& b) { a.Swap(&b); }
  inline void Swap(MeshMetrics* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshMetrics* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshMetrics& from) { MeshMetrics::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshMetrics* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.MeshMetrics"; }

 protected:
  explicit MeshMetrics(::google::protobuf::Arena* arena);
  MeshMetrics(::google::protobuf::Arena* arena, const MeshMetrics& from);
  MeshMetrics(::google::protobuf::Arena* arena, MeshMetrics&& from) noexcept
      : MeshMetrics(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 1,
    kLatencyFieldNumber = 2,
    kPacketLossFieldNumber = 3,
    kJitterFieldNumber = 4,
  };
  // .google.protobuf.Timestamp time = 1 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .kentik.synthetics.v202101beta1.MeshMetric latency = 2 [json_name = "latency"];
  bool has_latency() const;
  void clear_latency() ;
  const ::kentik::synthetics::v202101beta1::MeshMetric& latency() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::MeshMetric* release_latency();
  ::kentik::synthetics::v202101beta1::MeshMetric* mutable_latency();
  void set_allocated_latency(::kentik::synthetics::v202101beta1::MeshMetric* value);
  void unsafe_arena_set_allocated_latency(::kentik::synthetics::v202101beta1::MeshMetric* value);
  ::kentik::synthetics::v202101beta1::MeshMetric* unsafe_arena_release_latency();

  private:
  const ::kentik::synthetics::v202101beta1::MeshMetric& _internal_latency() const;
  ::kentik::synthetics::v202101beta1::MeshMetric* _internal_mutable_latency();

  public:
  // .kentik.synthetics.v202101beta1.MeshMetric packet_loss = 3 [json_name = "packetLoss"];
  bool has_packet_loss() const;
  void clear_packet_loss() ;
  const ::kentik::synthetics::v202101beta1::MeshMetric& packet_loss() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::MeshMetric* release_packet_loss();
  ::kentik::synthetics::v202101beta1::MeshMetric* mutable_packet_loss();
  void set_allocated_packet_loss(::kentik::synthetics::v202101beta1::MeshMetric* value);
  void unsafe_arena_set_allocated_packet_loss(::kentik::synthetics::v202101beta1::MeshMetric* value);
  ::kentik::synthetics::v202101beta1::MeshMetric* unsafe_arena_release_packet_loss();

  private:
  const ::kentik::synthetics::v202101beta1::MeshMetric& _internal_packet_loss() const;
  ::kentik::synthetics::v202101beta1::MeshMetric* _internal_mutable_packet_loss();

  public:
  // .kentik.synthetics.v202101beta1.MeshMetric jitter = 4 [json_name = "jitter"];
  bool has_jitter() const;
  void clear_jitter() ;
  const ::kentik::synthetics::v202101beta1::MeshMetric& jitter() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::MeshMetric* release_jitter();
  ::kentik::synthetics::v202101beta1::MeshMetric* mutable_jitter();
  void set_allocated_jitter(::kentik::synthetics::v202101beta1::MeshMetric* value);
  void unsafe_arena_set_allocated_jitter(::kentik::synthetics::v202101beta1::MeshMetric* value);
  ::kentik::synthetics::v202101beta1::MeshMetric* unsafe_arena_release_jitter();

  private:
  const ::kentik::synthetics::v202101beta1::MeshMetric& _internal_jitter() const;
  ::kentik::synthetics::v202101beta1::MeshMetric* _internal_mutable_jitter();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.MeshMetrics)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MeshMetrics& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* time_;
    ::kentik::synthetics::v202101beta1::MeshMetric* latency_;
    ::kentik::synthetics::v202101beta1::MeshMetric* packet_loss_;
    ::kentik::synthetics::v202101beta1::MeshMetric* jitter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Health final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Health) */ {
 public:
  inline Health() : Health(nullptr) {}
  ~Health() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Health* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Health));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Health(
      ::google::protobuf::internal::ConstantInitialized);

  inline Health(const Health& from) : Health(nullptr, from) {}
  inline Health(Health&& from) noexcept
      : Health(nullptr, std::move(from)) {}
  inline Health& operator=(const Health& from) {
    CopyFrom(from);
    return *this;
  }
  inline Health& operator=(Health&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Health& default_instance() {
    return *internal_default_instance();
  }
  static inline const Health* internal_default_instance() {
    return reinterpret_cast<const Health*>(
        &_Health_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Health& a, Health& b) { a.Swap(&b); }
  inline void Swap(Health* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Health* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Health* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Health>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Health& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Health& from) { Health::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Health* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Health"; }

 protected:
  explicit Health(::google::protobuf::Arena* arena);
  Health(::google::protobuf::Arena* arena, const Health& from);
  Health(::google::protobuf::Arena* arena, Health&& from) noexcept
      : Health(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHealthFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string health = 1 [json_name = "health"];
  void clear_health() ;
  const std::string& health() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_health(Arg_&& arg, Args_... args);
  std::string* mutable_health();
  PROTOBUF_NODISCARD std::string* release_health();
  void set_allocated_health(std::string* value);

  private:
  const std::string& _internal_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_health(
      const std::string& value);
  std::string* _internal_mutable_health();

  public:
  // .google.protobuf.Timestamp time = 2 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Health)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Health& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr health_;
    ::google::protobuf::Timestamp* time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class HTTPConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.HTTPConfig) */ {
 public:
  inline HTTPConfig() : HTTPConfig(nullptr) {}
  ~HTTPConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HTTPConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HTTPConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HTTPConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline HTTPConfig(const HTTPConfig& from) : HTTPConfig(nullptr, from) {}
  inline HTTPConfig(HTTPConfig&& from) noexcept
      : HTTPConfig(nullptr, std::move(from)) {}
  inline HTTPConfig& operator=(const HTTPConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HTTPConfig& operator=(HTTPConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HTTPConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HTTPConfig* internal_default_instance() {
    return reinterpret_cast<const HTTPConfig*>(
        &_HTTPConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(HTTPConfig& a, HTTPConfig& b) { a.Swap(&b); }
  inline void Swap(HTTPConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HTTPConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HTTPConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HTTPConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HTTPConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HTTPConfig& from) { HTTPConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HTTPConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.HTTPConfig"; }

 protected:
  explicit HTTPConfig(::google::protobuf::Arena* arena);
  HTTPConfig(::google::protobuf::Arena* arena, const HTTPConfig& from);
  HTTPConfig(::google::protobuf::Arena* arena, HTTPConfig&& from) noexcept
      : HTTPConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeadersFieldNumber = 4,
    kCssSelectorsFieldNumber = 7,
    kMethodFieldNumber = 3,
    kBodyFieldNumber = 5,
    kPeriodFieldNumber = 1,
    kExpiryFieldNumber = 2,
    kIgnoreTlsErrorsFieldNumber = 6,
  };
  // map<string, string> headers = 4 [json_name = "headers"];
  int headers_size() const;
  private:
  int _internal_headers_size() const;

  public:
  void clear_headers() ;
  const ::google::protobuf::Map<std::string, std::string>& headers() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_headers();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_headers() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_headers();

  public:
  // map<string, string> css_selectors = 7 [json_name = "cssSelectors"];
  int css_selectors_size() const;
  private:
  int _internal_css_selectors_size() const;

  public:
  void clear_css_selectors() ;
  const ::google::protobuf::Map<std::string, std::string>& css_selectors() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_css_selectors();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_css_selectors() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_css_selectors();

  public:
  // string method = 3 [json_name = "method"];
  void clear_method() ;
  const std::string& method() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_method(Arg_&& arg, Args_... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* value);

  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(
      const std::string& value);
  std::string* _internal_mutable_method();

  public:
  // string body = 5 [json_name = "body"];
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // uint32 period = 1 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 expiry = 2 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // bool ignore_tls_errors = 6 [json_name = "ignoreTlsErrors"];
  void clear_ignore_tls_errors() ;
  bool ignore_tls_errors() const;
  void set_ignore_tls_errors(bool value);

  private:
  bool _internal_ignore_tls_errors() const;
  void _internal_set_ignore_tls_errors(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.HTTPConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      80, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HTTPConfig& from_msg);
    ::google::protobuf::internal::MapField<HTTPConfig_HeadersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        headers_;
    ::google::protobuf::internal::MapField<HTTPConfig_CssSelectorsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        css_selectors_;
    ::google::protobuf::internal::ArenaStringPtr method_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::uint32_t period_;
    ::uint32_t expiry_;
    bool ignore_tls_errors_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetTraceForTestRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetTraceForTestRequest) */ {
 public:
  inline GetTraceForTestRequest() : GetTraceForTestRequest(nullptr) {}
  ~GetTraceForTestRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTraceForTestRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTraceForTestRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTraceForTestRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTraceForTestRequest(const GetTraceForTestRequest& from) : GetTraceForTestRequest(nullptr, from) {}
  inline GetTraceForTestRequest(GetTraceForTestRequest&& from) noexcept
      : GetTraceForTestRequest(nullptr, std::move(from)) {}
  inline GetTraceForTestRequest& operator=(const GetTraceForTestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTraceForTestRequest& operator=(GetTraceForTestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTraceForTestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTraceForTestRequest* internal_default_instance() {
    return reinterpret_cast<const GetTraceForTestRequest*>(
        &_GetTraceForTestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(GetTraceForTestRequest& a, GetTraceForTestRequest& b) { a.Swap(&b); }
  inline void Swap(GetTraceForTestRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTraceForTestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTraceForTestRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTraceForTestRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTraceForTestRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTraceForTestRequest& from) { GetTraceForTestRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTraceForTestRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetTraceForTestRequest"; }

 protected:
  explicit GetTraceForTestRequest(::google::protobuf::Arena* arena);
  GetTraceForTestRequest(::google::protobuf::Arena* arena, const GetTraceForTestRequest& from);
  GetTraceForTestRequest(::google::protobuf::Arena* arena, GetTraceForTestRequest&& from) noexcept
      : GetTraceForTestRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdsFieldNumber = 4,
    kTargetIpsFieldNumber = 5,
    kIdFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
  };
  // repeated string agent_ids = 4 [json_name = "agentIds"];
  int agent_ids_size() const;
  private:
  int _internal_agent_ids_size() const;

  public:
  void clear_agent_ids() ;
  const std::string& agent_ids(int index) const;
  std::string* mutable_agent_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_ids(int index, Arg_&& value, Args_... args);
  std::string* add_agent_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_agent_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& agent_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_agent_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_agent_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_agent_ids();

  public:
  // repeated string target_ips = 5 [json_name = "targetIps"];
  int target_ips_size() const;
  private:
  int _internal_target_ips_size() const;

  public:
  void clear_target_ips() ;
  const std::string& target_ips(int index) const;
  std::string* mutable_target_ips(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_ips(int index, Arg_&& value, Args_... args);
  std::string* add_target_ips();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_target_ips(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& target_ips() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_target_ips();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_target_ips() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_target_ips();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .google.protobuf.Timestamp start_time = 2 [json_name = "startTime"];
  bool has_start_time() const;
  void clear_start_time() ;
  const ::google::protobuf::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_start_time();

  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_start_time();

  public:
  // .google.protobuf.Timestamp end_time = 3 [json_name = "endTime"];
  bool has_end_time() const;
  void clear_end_time() ;
  const ::google::protobuf::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_end_time();
  ::google::protobuf::Timestamp* mutable_end_time();
  void set_allocated_end_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_end_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_end_time();

  private:
  const ::google::protobuf::Timestamp& _internal_end_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_end_time();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetTraceForTestRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      83, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTraceForTestRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> agent_ids_;
    ::google::protobuf::RepeatedPtrField<std::string> target_ips_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::Timestamp* start_time_;
    ::google::protobuf::Timestamp* end_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetHealthForTestsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetHealthForTestsRequest) */ {
 public:
  inline GetHealthForTestsRequest() : GetHealthForTestsRequest(nullptr) {}
  ~GetHealthForTestsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetHealthForTestsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetHealthForTestsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHealthForTestsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHealthForTestsRequest(const GetHealthForTestsRequest& from) : GetHealthForTestsRequest(nullptr, from) {}
  inline GetHealthForTestsRequest(GetHealthForTestsRequest&& from) noexcept
      : GetHealthForTestsRequest(nullptr, std::move(from)) {}
  inline GetHealthForTestsRequest& operator=(const GetHealthForTestsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHealthForTestsRequest& operator=(GetHealthForTestsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHealthForTestsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHealthForTestsRequest* internal_default_instance() {
    return reinterpret_cast<const GetHealthForTestsRequest*>(
        &_GetHealthForTestsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(GetHealthForTestsRequest& a, GetHealthForTestsRequest& b) { a.Swap(&b); }
  inline void Swap(GetHealthForTestsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHealthForTestsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHealthForTestsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetHealthForTestsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetHealthForTestsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetHealthForTestsRequest& from) { GetHealthForTestsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetHealthForTestsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetHealthForTestsRequest"; }

 protected:
  explicit GetHealthForTestsRequest(::google::protobuf::Arena* arena);
  GetHealthForTestsRequest(::google::protobuf::Arena* arena, const GetHealthForTestsRequest& from);
  GetHealthForTestsRequest(::google::protobuf::Arena* arena, GetHealthForTestsRequest&& from) noexcept
      : GetHealthForTestsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdsFieldNumber = 1,
    kAgentIdsFieldNumber = 4,
    kTaskIdsFieldNumber = 5,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kAugmentFieldNumber = 6,
  };
  // repeated string ids = 1 [json_name = "ids"];
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ids(int index, Arg_&& value, Args_... args);
  std::string* add_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ids();

  public:
  // repeated string agent_ids = 4 [json_name = "agentIds"];
  int agent_ids_size() const;
  private:
  int _internal_agent_ids_size() const;

  public:
  void clear_agent_ids() ;
  const std::string& agent_ids(int index) const;
  std::string* mutable_agent_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_ids(int index, Arg_&& value, Args_... args);
  std::string* add_agent_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_agent_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& agent_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_agent_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_agent_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_agent_ids();

  public:
  // repeated string task_ids = 5 [json_name = "taskIds"];
  int task_ids_size() const;
  private:
  int _internal_task_ids_size() const;

  public:
  void clear_task_ids() ;
  const std::string& task_ids(int index) const;
  std::string* mutable_task_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_ids(int index, Arg_&& value, Args_... args);
  std::string* add_task_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_task_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& task_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_task_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_task_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_task_ids();

  public:
  // .google.protobuf.Timestamp start_time = 2 [json_name = "startTime"];
  bool has_start_time() const;
  void clear_start_time() ;
  const ::google::protobuf::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_start_time();

  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_start_time();

  public:
  // .google.protobuf.Timestamp end_time = 3 [json_name = "endTime"];
  bool has_end_time() const;
  void clear_end_time() ;
  const ::google::protobuf::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_end_time();
  ::google::protobuf::Timestamp* mutable_end_time();
  void set_allocated_end_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_end_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_end_time();

  private:
  const ::google::protobuf::Timestamp& _internal_end_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_end_time();

  public:
  // bool augment = 6 [json_name = "augment"];
  void clear_augment() ;
  bool augment() const;
  void set_augment(bool value);

  private:
  bool _internal_augment() const;
  void _internal_set_augment(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetHealthForTestsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      84, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHealthForTestsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> ids_;
    ::google::protobuf::RepeatedPtrField<std::string> agent_ids_;
    ::google::protobuf::RepeatedPtrField<std::string> task_ids_;
    ::google::protobuf::Timestamp* start_time_;
    ::google::protobuf::Timestamp* end_time_;
    bool augment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Geo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Geo) */ {
 public:
  inline Geo() : Geo(nullptr) {}
  ~Geo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Geo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Geo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Geo(
      ::google::protobuf::internal::ConstantInitialized);

  inline Geo(const Geo& from) : Geo(nullptr, from) {}
  inline Geo(Geo&& from) noexcept
      : Geo(nullptr, std::move(from)) {}
  inline Geo& operator=(const Geo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geo& operator=(Geo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Geo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Geo* internal_default_instance() {
    return reinterpret_cast<const Geo*>(
        &_Geo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(Geo& a, Geo& b) { a.Swap(&b); }
  inline void Swap(Geo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Geo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Geo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Geo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Geo& from) { Geo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Geo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Geo"; }

 protected:
  explicit Geo(::google::protobuf::Arena* arena);
  Geo(::google::protobuf::Arena* arena, const Geo& from);
  Geo(::google::protobuf::Arena* arena, Geo&& from) noexcept
      : Geo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCountryFieldNumber = 1,
    kRegionFieldNumber = 2,
    kCityFieldNumber = 3,
  };
  // .kentik.synthetics.v202101beta1.Country country = 1 [json_name = "country"];
  bool has_country() const;
  void clear_country() ;
  const ::kentik::synthetics::v202101beta1::Country& country() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Country* release_country();
  ::kentik::synthetics::v202101beta1::Country* mutable_country();
  void set_allocated_country(::kentik::synthetics::v202101beta1::Country* value);
  void unsafe_arena_set_allocated_country(::kentik::synthetics::v202101beta1::Country* value);
  ::kentik::synthetics::v202101beta1::Country* unsafe_arena_release_country();

  private:
  const ::kentik::synthetics::v202101beta1::Country& _internal_country() const;
  ::kentik::synthetics::v202101beta1::Country* _internal_mutable_country();

  public:
  // .kentik.synthetics.v202101beta1.Region region = 2 [json_name = "region"];
  bool has_region() const;
  void clear_region() ;
  const ::kentik::synthetics::v202101beta1::Region& region() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Region* release_region();
  ::kentik::synthetics::v202101beta1::Region* mutable_region();
  void set_allocated_region(::kentik::synthetics::v202101beta1::Region* value);
  void unsafe_arena_set_allocated_region(::kentik::synthetics::v202101beta1::Region* value);
  ::kentik::synthetics::v202101beta1::Region* unsafe_arena_release_region();

  private:
  const ::kentik::synthetics::v202101beta1::Region& _internal_region() const;
  ::kentik::synthetics::v202101beta1::Region* _internal_mutable_region();

  public:
  // .kentik.synthetics.v202101beta1.City city = 3 [json_name = "city"];
  bool has_city() const;
  void clear_city() ;
  const ::kentik::synthetics::v202101beta1::City& city() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::City* release_city();
  ::kentik::synthetics::v202101beta1::City* mutable_city();
  void set_allocated_city(::kentik::synthetics::v202101beta1::City* value);
  void unsafe_arena_set_allocated_city(::kentik::synthetics::v202101beta1::City* value);
  ::kentik::synthetics::v202101beta1::City* unsafe_arena_release_city();

  private:
  const ::kentik::synthetics::v202101beta1::City& _internal_city() const;
  ::kentik::synthetics::v202101beta1::City* _internal_mutable_city();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Geo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Geo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Country* country_;
    ::kentik::synthetics::v202101beta1::Region* region_;
    ::kentik::synthetics::v202101beta1::City* city_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Agent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Agent) */ {
 public:
  inline Agent() : Agent(nullptr) {}
  ~Agent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Agent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Agent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Agent(
      ::google::protobuf::internal::ConstantInitialized);

  inline Agent(const Agent& from) : Agent(nullptr, from) {}
  inline Agent(Agent&& from) noexcept
      : Agent(nullptr, std::move(from)) {}
  inline Agent& operator=(const Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agent& operator=(Agent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const Agent* internal_default_instance() {
    return reinterpret_cast<const Agent*>(
        &_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Agent& a, Agent& b) { a.Swap(&b); }
  inline void Swap(Agent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Agent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Agent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Agent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Agent& from) { Agent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Agent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Agent"; }

 protected:
  explicit Agent(::google::protobuf::Arena* arena);
  Agent(::google::protobuf::Arena* arena, const Agent& from);
  Agent(::google::protobuf::Arena* arena, Agent&& from) noexcept
      : Agent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestIdsFieldNumber = 19,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kAliasFieldNumber = 4,
    kTypeFieldNumber = 5,
    kOsFieldNumber = 6,
    kIpFieldNumber = 7,
    kSiteIdFieldNumber = 13,
    kVersionFieldNumber = 14,
    kChallengeFieldNumber = 15,
    kCityFieldNumber = 16,
    kRegionFieldNumber = 17,
    kCountryFieldNumber = 18,
    kLocalIpFieldNumber = 20,
    kCloudVpcFieldNumber = 21,
    kLastAuthedFieldNumber = 10,
    kStatusFieldNumber = 3,
    kFamilyFieldNumber = 11,
    kLatFieldNumber = 8,
    kLongFieldNumber = 9,
    kAsnFieldNumber = 12,
    kAgentImplFieldNumber = 22,
  };
  // repeated string test_ids = 19 [json_name = "testIds"];
  int test_ids_size() const;
  private:
  int _internal_test_ids_size() const;

  public:
  void clear_test_ids() ;
  const std::string& test_ids(int index) const;
  std::string* mutable_test_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_test_ids(int index, Arg_&& value, Args_... args);
  std::string* add_test_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_test_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& test_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_test_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_test_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_test_ids();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string alias = 4 [json_name = "alias"];
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // string type = 5 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string os = 6 [json_name = "os"];
  void clear_os() ;
  const std::string& os() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_os(Arg_&& arg, Args_... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* value);

  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(
      const std::string& value);
  std::string* _internal_mutable_os();

  public:
  // string ip = 7 [json_name = "ip"];
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string site_id = 13 [json_name = "siteId"];
  void clear_site_id() ;
  const std::string& site_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_site_id(Arg_&& arg, Args_... args);
  std::string* mutable_site_id();
  PROTOBUF_NODISCARD std::string* release_site_id();
  void set_allocated_site_id(std::string* value);

  private:
  const std::string& _internal_site_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_site_id(
      const std::string& value);
  std::string* _internal_mutable_site_id();

  public:
  // string version = 14 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string challenge = 15 [json_name = "challenge"];
  void clear_challenge() ;
  const std::string& challenge() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_challenge(Arg_&& arg, Args_... args);
  std::string* mutable_challenge();
  PROTOBUF_NODISCARD std::string* release_challenge();
  void set_allocated_challenge(std::string* value);

  private:
  const std::string& _internal_challenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_challenge(
      const std::string& value);
  std::string* _internal_mutable_challenge();

  public:
  // string city = 16 [json_name = "city"];
  void clear_city() ;
  const std::string& city() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_city(Arg_&& arg, Args_... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* value);

  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(
      const std::string& value);
  std::string* _internal_mutable_city();

  public:
  // string region = 17 [json_name = "region"];
  void clear_region() ;
  const std::string& region() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region(Arg_&& arg, Args_... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* value);

  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(
      const std::string& value);
  std::string* _internal_mutable_region();

  public:
  // string country = 18 [json_name = "country"];
  void clear_country() ;
  const std::string& country() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country(Arg_&& arg, Args_... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* value);

  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(
      const std::string& value);
  std::string* _internal_mutable_country();

  public:
  // string local_ip = 20 [json_name = "localIp"];
  void clear_local_ip() ;
  const std::string& local_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_ip(Arg_&& arg, Args_... args);
  std::string* mutable_local_ip();
  PROTOBUF_NODISCARD std::string* release_local_ip();
  void set_allocated_local_ip(std::string* value);

  private:
  const std::string& _internal_local_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_ip(
      const std::string& value);
  std::string* _internal_mutable_local_ip();

  public:
  // string cloud_vpc = 21 [json_name = "cloudVpc"];
  void clear_cloud_vpc() ;
  const std::string& cloud_vpc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cloud_vpc(Arg_&& arg, Args_... args);
  std::string* mutable_cloud_vpc();
  PROTOBUF_NODISCARD std::string* release_cloud_vpc();
  void set_allocated_cloud_vpc(std::string* value);

  private:
  const std::string& _internal_cloud_vpc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloud_vpc(
      const std::string& value);
  std::string* _internal_mutable_cloud_vpc();

  public:
  // .google.protobuf.Timestamp last_authed = 10 [json_name = "lastAuthed"];
  bool has_last_authed() const;
  void clear_last_authed() ;
  const ::google::protobuf::Timestamp& last_authed() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_authed();
  ::google::protobuf::Timestamp* mutable_last_authed();
  void set_allocated_last_authed(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_authed(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_authed();

  private:
  const ::google::protobuf::Timestamp& _internal_last_authed() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_authed();

  public:
  // .kentik.synthetics.v202101beta1.AgentStatus status = 3 [json_name = "status"];
  void clear_status() ;
  ::kentik::synthetics::v202101beta1::AgentStatus status() const;
  void set_status(::kentik::synthetics::v202101beta1::AgentStatus value);

  private:
  ::kentik::synthetics::v202101beta1::AgentStatus _internal_status() const;
  void _internal_set_status(::kentik::synthetics::v202101beta1::AgentStatus value);

  public:
  // .kentik.synthetics.v202101beta1.IPFamily family = 11 [json_name = "family"];
  void clear_family() ;
  ::kentik::synthetics::v202101beta1::IPFamily family() const;
  void set_family(::kentik::synthetics::v202101beta1::IPFamily value);

  private:
  ::kentik::synthetics::v202101beta1::IPFamily _internal_family() const;
  void _internal_set_family(::kentik::synthetics::v202101beta1::IPFamily value);

  public:
  // double lat = 8 [json_name = "lat"];
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // double long = 9 [json_name = "long"];
  void clear_long_() ;
  double long_() const;
  void set_long_(double value);

  private:
  double _internal_long_() const;
  void _internal_set_long_(double value);

  public:
  // uint32 asn = 12 [json_name = "asn"];
  void clear_asn() ;
  ::uint32_t asn() const;
  void set_asn(::uint32_t value);

  private:
  ::uint32_t _internal_asn() const;
  void _internal_set_asn(::uint32_t value);

  public:
  // .kentik.synthetics.v202101beta1.ImplementType agent_impl = 22 [json_name = "agentImpl"];
  void clear_agent_impl() ;
  ::kentik::synthetics::v202101beta1::ImplementType agent_impl() const;
  void set_agent_impl(::kentik::synthetics::v202101beta1::ImplementType value);

  private:
  ::kentik::synthetics::v202101beta1::ImplementType _internal_agent_impl() const;
  void _internal_set_agent_impl(::kentik::synthetics::v202101beta1::ImplementType value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Agent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 22, 1,
      145, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Agent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> test_ids_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr os_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr site_id_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr challenge_;
    ::google::protobuf::internal::ArenaStringPtr city_;
    ::google::protobuf::internal::ArenaStringPtr region_;
    ::google::protobuf::internal::ArenaStringPtr country_;
    ::google::protobuf::internal::ArenaStringPtr local_ip_;
    ::google::protobuf::internal::ArenaStringPtr cloud_vpc_;
    ::google::protobuf::Timestamp* last_authed_;
    int status_;
    int family_;
    double lat_;
    double long__;
    ::uint32_t asn_;
    int agent_impl_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Trace final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Trace) */ {
 public:
  inline Trace() : Trace(nullptr) {}
  ~Trace() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Trace* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Trace));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Trace(
      ::google::protobuf::internal::ConstantInitialized);

  inline Trace(const Trace& from) : Trace(nullptr, from) {}
  inline Trace(Trace&& from) noexcept
      : Trace(nullptr, std::move(from)) {}
  inline Trace& operator=(const Trace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trace& operator=(Trace&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trace& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trace* internal_default_instance() {
    return reinterpret_cast<const Trace*>(
        &_Trace_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(Trace& a, Trace& b) { a.Swap(&b); }
  inline void Swap(Trace* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trace* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trace* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Trace>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Trace& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Trace& from) { Trace::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Trace* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Trace"; }

 protected:
  explicit Trace(::google::protobuf::Arena* arena);
  Trace(::google::protobuf::Arena* arena, const Trace& from);
  Trace(::google::protobuf::Arena* arena, Trace&& from) noexcept
      : Trace(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProbesFieldNumber = 5,
    kAgentIdFieldNumber = 1,
    kAgentIpFieldNumber = 2,
    kTargetIpFieldNumber = 3,
    kHopCountFieldNumber = 4,
  };
  // repeated .kentik.synthetics.v202101beta1.TraceProbe probes = 5 [json_name = "probes"];
  int probes_size() const;
  private:
  int _internal_probes_size() const;

  public:
  void clear_probes() ;
  ::kentik::synthetics::v202101beta1::TraceProbe* mutable_probes(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>* mutable_probes();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>& _internal_probes() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>* _internal_mutable_probes();
  public:
  const ::kentik::synthetics::v202101beta1::TraceProbe& probes(int index) const;
  ::kentik::synthetics::v202101beta1::TraceProbe* add_probes();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>& probes() const;
  // string agent_id = 1 [json_name = "agentId"];
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // string agent_ip = 2 [json_name = "agentIp"];
  void clear_agent_ip() ;
  const std::string& agent_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_ip(Arg_&& arg, Args_... args);
  std::string* mutable_agent_ip();
  PROTOBUF_NODISCARD std::string* release_agent_ip();
  void set_allocated_agent_ip(std::string* value);

  private:
  const std::string& _internal_agent_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_ip(
      const std::string& value);
  std::string* _internal_mutable_agent_ip();

  public:
  // string target_ip = 3 [json_name = "targetIp"];
  void clear_target_ip() ;
  const std::string& target_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_ip(Arg_&& arg, Args_... args);
  std::string* mutable_target_ip();
  PROTOBUF_NODISCARD std::string* release_target_ip();
  void set_allocated_target_ip(std::string* value);

  private:
  const std::string& _internal_target_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_ip(
      const std::string& value);
  std::string* _internal_mutable_target_ip();

  public:
  // int32 hop_count = 4 [json_name = "hopCount"];
  void clear_hop_count() ;
  ::int32_t hop_count() const;
  void set_hop_count(::int32_t value);

  private:
  ::int32_t _internal_hop_count() const;
  void _internal_set_hop_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Trace)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      70, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Trace& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::TraceProbe > probes_;
    ::google::protobuf::internal::ArenaStringPtr agent_id_;
    ::google::protobuf::internal::ArenaStringPtr agent_ip_;
    ::google::protobuf::internal::ArenaStringPtr target_ip_;
    ::int32_t hop_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TestSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TestSettings) */ {
 public:
  inline TestSettings() : TestSettings(nullptr) {}
  ~TestSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestSettings* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestSettings(const TestSettings& from) : TestSettings(nullptr, from) {}
  inline TestSettings(TestSettings&& from) noexcept
      : TestSettings(nullptr, std::move(from)) {}
  inline TestSettings& operator=(const TestSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestSettings& operator=(TestSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestSettings& default_instance() {
    return *internal_default_instance();
  }
  enum DefinitionCase {
    kHostname = 4,
    kIp = 5,
    kAgent = 6,
    kFlow = 7,
    kSite = 8,
    kTag = 9,
    kDns = 10,
    kUrl = 11,
    kNetworkGrid = 35,
    kPageLoad = 36,
    kDnsGrid = 37,
    kApplicationMesh = 38,
    DEFINITION_NOT_SET = 0,
  };
  static inline const TestSettings* internal_default_instance() {
    return reinterpret_cast<const TestSettings*>(
        &_TestSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(TestSettings& a, TestSettings& b) { a.Swap(&b); }
  inline void Swap(TestSettings* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestSettings* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestSettings& from) { TestSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestSettings* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TestSettings"; }

 protected:
  explicit TestSettings(::google::protobuf::Arena* arena);
  TestSettings(::google::protobuf::Arena* arena, const TestSettings& from);
  TestSettings(::google::protobuf::Arena* arena, TestSettings&& from) noexcept
      : TestSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdsFieldNumber = 14,
    kTasksFieldNumber = 19,
    kServersFieldNumber = 30,
    kProtocolFieldNumber = 26,
    kHealthSettingsFieldNumber = 22,
    kMonitoringSettingsFieldNumber = 24,
    kPingFieldNumber = 28,
    kTraceFieldNumber = 29,
    kHttpFieldNumber = 34,
    kPeriodFieldNumber = 15,
    kCountFieldNumber = 16,
    kExpiryFieldNumber = 17,
    kLimitFieldNumber = 18,
    kPortFieldNumber = 23,
    kFamilyFieldNumber = 27,
    kUseLocalIpFieldNumber = 31,
    kReciprocalFieldNumber = 32,
    kRollupLevelFieldNumber = 33,
    kHostnameFieldNumber = 4,
    kIpFieldNumber = 5,
    kAgentFieldNumber = 6,
    kFlowFieldNumber = 7,
    kSiteFieldNumber = 8,
    kTagFieldNumber = 9,
    kDnsFieldNumber = 10,
    kUrlFieldNumber = 11,
    kNetworkGridFieldNumber = 35,
    kPageLoadFieldNumber = 36,
    kDnsGridFieldNumber = 37,
    kApplicationMeshFieldNumber = 38,
  };
  // repeated string agent_ids = 14 [json_name = "agentIds"];
  int agent_ids_size() const;
  private:
  int _internal_agent_ids_size() const;

  public:
  void clear_agent_ids() ;
  const std::string& agent_ids(int index) const;
  std::string* mutable_agent_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_ids(int index, Arg_&& value, Args_... args);
  std::string* add_agent_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_agent_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& agent_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_agent_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_agent_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_agent_ids();

  public:
  // repeated string tasks = 19 [json_name = "tasks"];
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  const std::string& tasks(int index) const;
  std::string* mutable_tasks(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tasks(int index, Arg_&& value, Args_... args);
  std::string* add_tasks();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_tasks(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& tasks() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tasks();

  public:
  // repeated string servers = 30 [json_name = "servers"];
  int servers_size() const;
  private:
  int _internal_servers_size() const;

  public:
  void clear_servers() ;
  const std::string& servers(int index) const;
  std::string* mutable_servers(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_servers(int index, Arg_&& value, Args_... args);
  std::string* add_servers();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_servers(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& servers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_servers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_servers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_servers();

  public:
  // string protocol = 26 [json_name = "protocol"];
  void clear_protocol() ;
  const std::string& protocol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol(Arg_&& arg, Args_... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* value);

  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(
      const std::string& value);
  std::string* _internal_mutable_protocol();

  public:
  // .kentik.synthetics.v202101beta1.HealthSettings health_settings = 22 [json_name = "healthSettings"];
  bool has_health_settings() const;
  void clear_health_settings() ;
  const ::kentik::synthetics::v202101beta1::HealthSettings& health_settings() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::HealthSettings* release_health_settings();
  ::kentik::synthetics::v202101beta1::HealthSettings* mutable_health_settings();
  void set_allocated_health_settings(::kentik::synthetics::v202101beta1::HealthSettings* value);
  void unsafe_arena_set_allocated_health_settings(::kentik::synthetics::v202101beta1::HealthSettings* value);
  ::kentik::synthetics::v202101beta1::HealthSettings* unsafe_arena_release_health_settings();

  private:
  const ::kentik::synthetics::v202101beta1::HealthSettings& _internal_health_settings() const;
  ::kentik::synthetics::v202101beta1::HealthSettings* _internal_mutable_health_settings();

  public:
  // .kentik.synthetics.v202101beta1.TestMonitoringSettings monitoring_settings = 24 [json_name = "monitoringSettings"];
  bool has_monitoring_settings() const;
  void clear_monitoring_settings() ;
  const ::kentik::synthetics::v202101beta1::TestMonitoringSettings& monitoring_settings() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TestMonitoringSettings* release_monitoring_settings();
  ::kentik::synthetics::v202101beta1::TestMonitoringSettings* mutable_monitoring_settings();
  void set_allocated_monitoring_settings(::kentik::synthetics::v202101beta1::TestMonitoringSettings* value);
  void unsafe_arena_set_allocated_monitoring_settings(::kentik::synthetics::v202101beta1::TestMonitoringSettings* value);
  ::kentik::synthetics::v202101beta1::TestMonitoringSettings* unsafe_arena_release_monitoring_settings();

  private:
  const ::kentik::synthetics::v202101beta1::TestMonitoringSettings& _internal_monitoring_settings() const;
  ::kentik::synthetics::v202101beta1::TestMonitoringSettings* _internal_mutable_monitoring_settings();

  public:
  // .kentik.synthetics.v202101beta1.TestPingSettings ping = 28 [json_name = "ping"];
  bool has_ping() const;
  void clear_ping() ;
  const ::kentik::synthetics::v202101beta1::TestPingSettings& ping() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TestPingSettings* release_ping();
  ::kentik::synthetics::v202101beta1::TestPingSettings* mutable_ping();
  void set_allocated_ping(::kentik::synthetics::v202101beta1::TestPingSettings* value);
  void unsafe_arena_set_allocated_ping(::kentik::synthetics::v202101beta1::TestPingSettings* value);
  ::kentik::synthetics::v202101beta1::TestPingSettings* unsafe_arena_release_ping();

  private:
  const ::kentik::synthetics::v202101beta1::TestPingSettings& _internal_ping() const;
  ::kentik::synthetics::v202101beta1::TestPingSettings* _internal_mutable_ping();

  public:
  // .kentik.synthetics.v202101beta1.TestTraceSettings trace = 29 [json_name = "trace"];
  bool has_trace() const;
  void clear_trace() ;
  const ::kentik::synthetics::v202101beta1::TestTraceSettings& trace() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TestTraceSettings* release_trace();
  ::kentik::synthetics::v202101beta1::TestTraceSettings* mutable_trace();
  void set_allocated_trace(::kentik::synthetics::v202101beta1::TestTraceSettings* value);
  void unsafe_arena_set_allocated_trace(::kentik::synthetics::v202101beta1::TestTraceSettings* value);
  ::kentik::synthetics::v202101beta1::TestTraceSettings* unsafe_arena_release_trace();

  private:
  const ::kentik::synthetics::v202101beta1::TestTraceSettings& _internal_trace() const;
  ::kentik::synthetics::v202101beta1::TestTraceSettings* _internal_mutable_trace();

  public:
  // .kentik.synthetics.v202101beta1.HTTPConfig http = 34 [json_name = "http"];
  bool has_http() const;
  void clear_http() ;
  const ::kentik::synthetics::v202101beta1::HTTPConfig& http() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::HTTPConfig* release_http();
  ::kentik::synthetics::v202101beta1::HTTPConfig* mutable_http();
  void set_allocated_http(::kentik::synthetics::v202101beta1::HTTPConfig* value);
  void unsafe_arena_set_allocated_http(::kentik::synthetics::v202101beta1::HTTPConfig* value);
  ::kentik::synthetics::v202101beta1::HTTPConfig* unsafe_arena_release_http();

  private:
  const ::kentik::synthetics::v202101beta1::HTTPConfig& _internal_http() const;
  ::kentik::synthetics::v202101beta1::HTTPConfig* _internal_mutable_http();

  public:
  // uint32 period = 15 [json_name = "period"];
  void clear_period() ;
  ::uint32_t period() const;
  void set_period(::uint32_t value);

  private:
  ::uint32_t _internal_period() const;
  void _internal_set_period(::uint32_t value);

  public:
  // uint32 count = 16 [json_name = "count"];
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // uint32 expiry = 17 [json_name = "expiry"];
  void clear_expiry() ;
  ::uint32_t expiry() const;
  void set_expiry(::uint32_t value);

  private:
  ::uint32_t _internal_expiry() const;
  void _internal_set_expiry(::uint32_t value);

  public:
  // uint32 limit = 18 [json_name = "limit"];
  void clear_limit() ;
  ::uint32_t limit() const;
  void set_limit(::uint32_t value);

  private:
  ::uint32_t _internal_limit() const;
  void _internal_set_limit(::uint32_t value);

  public:
  // uint32 port = 23 [json_name = "port"];
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // .kentik.synthetics.v202101beta1.IPFamily family = 27 [json_name = "family"];
  void clear_family() ;
  ::kentik::synthetics::v202101beta1::IPFamily family() const;
  void set_family(::kentik::synthetics::v202101beta1::IPFamily value);

  private:
  ::kentik::synthetics::v202101beta1::IPFamily _internal_family() const;
  void _internal_set_family(::kentik::synthetics::v202101beta1::IPFamily value);

  public:
  // bool use_local_ip = 31 [json_name = "useLocalIp"];
  void clear_use_local_ip() ;
  bool use_local_ip() const;
  void set_use_local_ip(bool value);

  private:
  bool _internal_use_local_ip() const;
  void _internal_set_use_local_ip(bool value);

  public:
  // bool reciprocal = 32 [json_name = "reciprocal"];
  void clear_reciprocal() ;
  bool reciprocal() const;
  void set_reciprocal(bool value);

  private:
  bool _internal_reciprocal() const;
  void _internal_set_reciprocal(bool value);

  public:
  // uint32 rollup_level = 33 [json_name = "rollupLevel"];
  void clear_rollup_level() ;
  ::uint32_t rollup_level() const;
  void set_rollup_level(::uint32_t value);

  private:
  ::uint32_t _internal_rollup_level() const;
  void _internal_set_rollup_level(::uint32_t value);

  public:
  // .kentik.synthetics.v202101beta1.HostnameTest hostname = 4 [json_name = "hostname"];
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;

  public:
  void clear_hostname() ;
  const ::kentik::synthetics::v202101beta1::HostnameTest& hostname() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::HostnameTest* release_hostname();
  ::kentik::synthetics::v202101beta1::HostnameTest* mutable_hostname();
  void set_allocated_hostname(::kentik::synthetics::v202101beta1::HostnameTest* value);
  void unsafe_arena_set_allocated_hostname(::kentik::synthetics::v202101beta1::HostnameTest* value);
  ::kentik::synthetics::v202101beta1::HostnameTest* unsafe_arena_release_hostname();

  private:
  const ::kentik::synthetics::v202101beta1::HostnameTest& _internal_hostname() const;
  ::kentik::synthetics::v202101beta1::HostnameTest* _internal_mutable_hostname();

  public:
  // .kentik.synthetics.v202101beta1.IpTest ip = 5 [json_name = "ip"];
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;

  public:
  void clear_ip() ;
  const ::kentik::synthetics::v202101beta1::IpTest& ip() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::IpTest* release_ip();
  ::kentik::synthetics::v202101beta1::IpTest* mutable_ip();
  void set_allocated_ip(::kentik::synthetics::v202101beta1::IpTest* value);
  void unsafe_arena_set_allocated_ip(::kentik::synthetics::v202101beta1::IpTest* value);
  ::kentik::synthetics::v202101beta1::IpTest* unsafe_arena_release_ip();

  private:
  const ::kentik::synthetics::v202101beta1::IpTest& _internal_ip() const;
  ::kentik::synthetics::v202101beta1::IpTest* _internal_mutable_ip();

  public:
  // .kentik.synthetics.v202101beta1.AgentTest agent = 6 [json_name = "agent"];
  bool has_agent() const;
  private:
  bool _internal_has_agent() const;

  public:
  void clear_agent() ;
  const ::kentik::synthetics::v202101beta1::AgentTest& agent() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::AgentTest* release_agent();
  ::kentik::synthetics::v202101beta1::AgentTest* mutable_agent();
  void set_allocated_agent(::kentik::synthetics::v202101beta1::AgentTest* value);
  void unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::AgentTest* value);
  ::kentik::synthetics::v202101beta1::AgentTest* unsafe_arena_release_agent();

  private:
  const ::kentik::synthetics::v202101beta1::AgentTest& _internal_agent() const;
  ::kentik::synthetics::v202101beta1::AgentTest* _internal_mutable_agent();

  public:
  // .kentik.synthetics.v202101beta1.FlowTest flow = 7 [json_name = "flow"];
  bool has_flow() const;
  private:
  bool _internal_has_flow() const;

  public:
  void clear_flow() ;
  const ::kentik::synthetics::v202101beta1::FlowTest& flow() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::FlowTest* release_flow();
  ::kentik::synthetics::v202101beta1::FlowTest* mutable_flow();
  void set_allocated_flow(::kentik::synthetics::v202101beta1::FlowTest* value);
  void unsafe_arena_set_allocated_flow(::kentik::synthetics::v202101beta1::FlowTest* value);
  ::kentik::synthetics::v202101beta1::FlowTest* unsafe_arena_release_flow();

  private:
  const ::kentik::synthetics::v202101beta1::FlowTest& _internal_flow() const;
  ::kentik::synthetics::v202101beta1::FlowTest* _internal_mutable_flow();

  public:
  // .kentik.synthetics.v202101beta1.SiteTest site = 8 [json_name = "site"];
  bool has_site() const;
  private:
  bool _internal_has_site() const;

  public:
  void clear_site() ;
  const ::kentik::synthetics::v202101beta1::SiteTest& site() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::SiteTest* release_site();
  ::kentik::synthetics::v202101beta1::SiteTest* mutable_site();
  void set_allocated_site(::kentik::synthetics::v202101beta1::SiteTest* value);
  void unsafe_arena_set_allocated_site(::kentik::synthetics::v202101beta1::SiteTest* value);
  ::kentik::synthetics::v202101beta1::SiteTest* unsafe_arena_release_site();

  private:
  const ::kentik::synthetics::v202101beta1::SiteTest& _internal_site() const;
  ::kentik::synthetics::v202101beta1::SiteTest* _internal_mutable_site();

  public:
  // .kentik.synthetics.v202101beta1.TagTest tag = 9 [json_name = "tag"];
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;

  public:
  void clear_tag() ;
  const ::kentik::synthetics::v202101beta1::TagTest& tag() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TagTest* release_tag();
  ::kentik::synthetics::v202101beta1::TagTest* mutable_tag();
  void set_allocated_tag(::kentik::synthetics::v202101beta1::TagTest* value);
  void unsafe_arena_set_allocated_tag(::kentik::synthetics::v202101beta1::TagTest* value);
  ::kentik::synthetics::v202101beta1::TagTest* unsafe_arena_release_tag();

  private:
  const ::kentik::synthetics::v202101beta1::TagTest& _internal_tag() const;
  ::kentik::synthetics::v202101beta1::TagTest* _internal_mutable_tag();

  public:
  // .kentik.synthetics.v202101beta1.DnsTest dns = 10 [json_name = "dns"];
  bool has_dns() const;
  private:
  bool _internal_has_dns() const;

  public:
  void clear_dns() ;
  const ::kentik::synthetics::v202101beta1::DnsTest& dns() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::DnsTest* release_dns();
  ::kentik::synthetics::v202101beta1::DnsTest* mutable_dns();
  void set_allocated_dns(::kentik::synthetics::v202101beta1::DnsTest* value);
  void unsafe_arena_set_allocated_dns(::kentik::synthetics::v202101beta1::DnsTest* value);
  ::kentik::synthetics::v202101beta1::DnsTest* unsafe_arena_release_dns();

  private:
  const ::kentik::synthetics::v202101beta1::DnsTest& _internal_dns() const;
  ::kentik::synthetics::v202101beta1::DnsTest* _internal_mutable_dns();

  public:
  // .kentik.synthetics.v202101beta1.UrlTest url = 11 [json_name = "url"];
  bool has_url() const;
  private:
  bool _internal_has_url() const;

  public:
  void clear_url() ;
  const ::kentik::synthetics::v202101beta1::UrlTest& url() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::UrlTest* release_url();
  ::kentik::synthetics::v202101beta1::UrlTest* mutable_url();
  void set_allocated_url(::kentik::synthetics::v202101beta1::UrlTest* value);
  void unsafe_arena_set_allocated_url(::kentik::synthetics::v202101beta1::UrlTest* value);
  ::kentik::synthetics::v202101beta1::UrlTest* unsafe_arena_release_url();

  private:
  const ::kentik::synthetics::v202101beta1::UrlTest& _internal_url() const;
  ::kentik::synthetics::v202101beta1::UrlTest* _internal_mutable_url();

  public:
  // .kentik.synthetics.v202101beta1.GridTest network_grid = 35 [json_name = "networkGrid"];
  bool has_network_grid() const;
  private:
  bool _internal_has_network_grid() const;

  public:
  void clear_network_grid() ;
  const ::kentik::synthetics::v202101beta1::GridTest& network_grid() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::GridTest* release_network_grid();
  ::kentik::synthetics::v202101beta1::GridTest* mutable_network_grid();
  void set_allocated_network_grid(::kentik::synthetics::v202101beta1::GridTest* value);
  void unsafe_arena_set_allocated_network_grid(::kentik::synthetics::v202101beta1::GridTest* value);
  ::kentik::synthetics::v202101beta1::GridTest* unsafe_arena_release_network_grid();

  private:
  const ::kentik::synthetics::v202101beta1::GridTest& _internal_network_grid() const;
  ::kentik::synthetics::v202101beta1::GridTest* _internal_mutable_network_grid();

  public:
  // .kentik.synthetics.v202101beta1.UrlTest page_load = 36 [json_name = "pageLoad"];
  bool has_page_load() const;
  private:
  bool _internal_has_page_load() const;

  public:
  void clear_page_load() ;
  const ::kentik::synthetics::v202101beta1::UrlTest& page_load() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::UrlTest* release_page_load();
  ::kentik::synthetics::v202101beta1::UrlTest* mutable_page_load();
  void set_allocated_page_load(::kentik::synthetics::v202101beta1::UrlTest* value);
  void unsafe_arena_set_allocated_page_load(::kentik::synthetics::v202101beta1::UrlTest* value);
  ::kentik::synthetics::v202101beta1::UrlTest* unsafe_arena_release_page_load();

  private:
  const ::kentik::synthetics::v202101beta1::UrlTest& _internal_page_load() const;
  ::kentik::synthetics::v202101beta1::UrlTest* _internal_mutable_page_load();

  public:
  // .kentik.synthetics.v202101beta1.DnsGridTest dns_grid = 37 [json_name = "dnsGrid"];
  bool has_dns_grid() const;
  private:
  bool _internal_has_dns_grid() const;

  public:
  void clear_dns_grid() ;
  const ::kentik::synthetics::v202101beta1::DnsGridTest& dns_grid() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::DnsGridTest* release_dns_grid();
  ::kentik::synthetics::v202101beta1::DnsGridTest* mutable_dns_grid();
  void set_allocated_dns_grid(::kentik::synthetics::v202101beta1::DnsGridTest* value);
  void unsafe_arena_set_allocated_dns_grid(::kentik::synthetics::v202101beta1::DnsGridTest* value);
  ::kentik::synthetics::v202101beta1::DnsGridTest* unsafe_arena_release_dns_grid();

  private:
  const ::kentik::synthetics::v202101beta1::DnsGridTest& _internal_dns_grid() const;
  ::kentik::synthetics::v202101beta1::DnsGridTest* _internal_mutable_dns_grid();

  public:
  // .kentik.synthetics.v202101beta1.ApplicationMeshTest application_mesh = 38 [json_name = "applicationMesh"];
  bool has_application_mesh() const;
  private:
  bool _internal_has_application_mesh() const;

  public:
  void clear_application_mesh() ;
  const ::kentik::synthetics::v202101beta1::ApplicationMeshTest& application_mesh() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::ApplicationMeshTest* release_application_mesh();
  ::kentik::synthetics::v202101beta1::ApplicationMeshTest* mutable_application_mesh();
  void set_allocated_application_mesh(::kentik::synthetics::v202101beta1::ApplicationMeshTest* value);
  void unsafe_arena_set_allocated_application_mesh(::kentik::synthetics::v202101beta1::ApplicationMeshTest* value);
  ::kentik::synthetics::v202101beta1::ApplicationMeshTest* unsafe_arena_release_application_mesh();

  private:
  const ::kentik::synthetics::v202101beta1::ApplicationMeshTest& _internal_application_mesh() const;
  ::kentik::synthetics::v202101beta1::ApplicationMeshTest* _internal_mutable_application_mesh();

  public:
  void clear_definition();
  DefinitionCase definition_case() const;
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TestSettings)
 private:
  class _Internal;
  void set_has_hostname();
  void set_has_ip();
  void set_has_agent();
  void set_has_flow();
  void set_has_site();
  void set_has_tag();
  void set_has_dns();
  void set_has_url();
  void set_has_network_grid();
  void set_has_page_load();
  void set_has_dns_grid();
  void set_has_application_mesh();
  inline bool has_definition() const;
  inline void clear_has_definition();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 30, 17,
      105, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestSettings& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> agent_ids_;
    ::google::protobuf::RepeatedPtrField<std::string> tasks_;
    ::google::protobuf::RepeatedPtrField<std::string> servers_;
    ::google::protobuf::internal::ArenaStringPtr protocol_;
    ::kentik::synthetics::v202101beta1::HealthSettings* health_settings_;
    ::kentik::synthetics::v202101beta1::TestMonitoringSettings* monitoring_settings_;
    ::kentik::synthetics::v202101beta1::TestPingSettings* ping_;
    ::kentik::synthetics::v202101beta1::TestTraceSettings* trace_;
    ::kentik::synthetics::v202101beta1::HTTPConfig* http_;
    ::uint32_t period_;
    ::uint32_t count_;
    ::uint32_t expiry_;
    ::uint32_t limit_;
    ::uint32_t port_;
    int family_;
    bool use_local_ip_;
    bool reciprocal_;
    ::uint32_t rollup_level_;
    union DefinitionUnion {
      constexpr DefinitionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::kentik::synthetics::v202101beta1::HostnameTest* hostname_;
      ::kentik::synthetics::v202101beta1::IpTest* ip_;
      ::kentik::synthetics::v202101beta1::AgentTest* agent_;
      ::kentik::synthetics::v202101beta1::FlowTest* flow_;
      ::kentik::synthetics::v202101beta1::SiteTest* site_;
      ::kentik::synthetics::v202101beta1::TagTest* tag_;
      ::kentik::synthetics::v202101beta1::DnsTest* dns_;
      ::kentik::synthetics::v202101beta1::UrlTest* url_;
      ::kentik::synthetics::v202101beta1::GridTest* network_grid_;
      ::kentik::synthetics::v202101beta1::UrlTest* page_load_;
      ::kentik::synthetics::v202101beta1::DnsGridTest* dns_grid_;
      ::kentik::synthetics::v202101beta1::ApplicationMeshTest* application_mesh_;
    } definition_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class PatchAgentResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.PatchAgentResponse) */ {
 public:
  inline PatchAgentResponse() : PatchAgentResponse(nullptr) {}
  ~PatchAgentResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchAgentResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchAgentResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchAgentResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchAgentResponse(const PatchAgentResponse& from) : PatchAgentResponse(nullptr, from) {}
  inline PatchAgentResponse(PatchAgentResponse&& from) noexcept
      : PatchAgentResponse(nullptr, std::move(from)) {}
  inline PatchAgentResponse& operator=(const PatchAgentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchAgentResponse& operator=(PatchAgentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchAgentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchAgentResponse* internal_default_instance() {
    return reinterpret_cast<const PatchAgentResponse*>(
        &_PatchAgentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(PatchAgentResponse& a, PatchAgentResponse& b) { a.Swap(&b); }
  inline void Swap(PatchAgentResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchAgentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchAgentResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchAgentResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchAgentResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchAgentResponse& from) { PatchAgentResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchAgentResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.PatchAgentResponse"; }

 protected:
  explicit PatchAgentResponse(::google::protobuf::Arena* arena);
  PatchAgentResponse(::google::protobuf::Arena* arena, const PatchAgentResponse& from);
  PatchAgentResponse(::google::protobuf::Arena* arena, PatchAgentResponse&& from) noexcept
      : PatchAgentResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentFieldNumber = 1,
  };
  // .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
  bool has_agent() const;
  void clear_agent() ;
  const ::kentik::synthetics::v202101beta1::Agent& agent() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Agent* release_agent();
  ::kentik::synthetics::v202101beta1::Agent* mutable_agent();
  void set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  void unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  ::kentik::synthetics::v202101beta1::Agent* unsafe_arena_release_agent();

  private:
  const ::kentik::synthetics::v202101beta1::Agent& _internal_agent() const;
  ::kentik::synthetics::v202101beta1::Agent* _internal_mutable_agent();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.PatchAgentResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchAgentResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Agent* agent_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class PatchAgentRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.PatchAgentRequest) */ {
 public:
  inline PatchAgentRequest() : PatchAgentRequest(nullptr) {}
  ~PatchAgentRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchAgentRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchAgentRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchAgentRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchAgentRequest(const PatchAgentRequest& from) : PatchAgentRequest(nullptr, from) {}
  inline PatchAgentRequest(PatchAgentRequest&& from) noexcept
      : PatchAgentRequest(nullptr, std::move(from)) {}
  inline PatchAgentRequest& operator=(const PatchAgentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchAgentRequest& operator=(PatchAgentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchAgentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchAgentRequest* internal_default_instance() {
    return reinterpret_cast<const PatchAgentRequest*>(
        &_PatchAgentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 63;
  friend void swap(PatchAgentRequest& a, PatchAgentRequest& b) { a.Swap(&b); }
  inline void Swap(PatchAgentRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchAgentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchAgentRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchAgentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchAgentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchAgentRequest& from) { PatchAgentRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchAgentRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.PatchAgentRequest"; }

 protected:
  explicit PatchAgentRequest(::google::protobuf::Arena* arena);
  PatchAgentRequest(::google::protobuf::Arena* arena, const PatchAgentRequest& from);
  PatchAgentRequest(::google::protobuf::Arena* arena, PatchAgentRequest&& from) noexcept
      : PatchAgentRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentFieldNumber = 1,
    kMaskFieldNumber = 2,
  };
  // .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
  bool has_agent() const;
  void clear_agent() ;
  const ::kentik::synthetics::v202101beta1::Agent& agent() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Agent* release_agent();
  ::kentik::synthetics::v202101beta1::Agent* mutable_agent();
  void set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  void unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  ::kentik::synthetics::v202101beta1::Agent* unsafe_arena_release_agent();

  private:
  const ::kentik::synthetics::v202101beta1::Agent& _internal_agent() const;
  ::kentik::synthetics::v202101beta1::Agent* _internal_mutable_agent();

  public:
  // .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
  bool has_mask() const;
  void clear_mask() ;
  const ::google::protobuf::FieldMask& mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_mask();
  ::google::protobuf::FieldMask* mutable_mask();
  void set_allocated_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_mask();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.PatchAgentRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchAgentRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Agent* agent_;
    ::google::protobuf::FieldMask* mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class MeshColumn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.MeshColumn) */ {
 public:
  inline MeshColumn() : MeshColumn(nullptr) {}
  ~MeshColumn() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshColumn* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshColumn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshColumn(
      ::google::protobuf::internal::ConstantInitialized);

  inline MeshColumn(const MeshColumn& from) : MeshColumn(nullptr, from) {}
  inline MeshColumn(MeshColumn&& from) noexcept
      : MeshColumn(nullptr, std::move(from)) {}
  inline MeshColumn& operator=(const MeshColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshColumn& operator=(MeshColumn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshColumn* internal_default_instance() {
    return reinterpret_cast<const MeshColumn*>(
        &_MeshColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(MeshColumn& a, MeshColumn& b) { a.Swap(&b); }
  inline void Swap(MeshColumn* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshColumn* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshColumn& from) { MeshColumn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshColumn* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.MeshColumn"; }

 protected:
  explicit MeshColumn(::google::protobuf::Arena* arena);
  MeshColumn(::google::protobuf::Arena* arena, const MeshColumn& from);
  MeshColumn(::google::protobuf::Arena* arena, MeshColumn&& from) noexcept
      : MeshColumn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHealthFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kAliasFieldNumber = 3,
    kTargetFieldNumber = 4,
    kMetricsFieldNumber = 5,
  };
  // repeated .kentik.synthetics.v202101beta1.MeshMetrics health = 6 [json_name = "health"];
  int health_size() const;
  private:
  int _internal_health_size() const;

  public:
  void clear_health() ;
  ::kentik::synthetics::v202101beta1::MeshMetrics* mutable_health(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>* mutable_health();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>& _internal_health() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>* _internal_mutable_health();
  public:
  const ::kentik::synthetics::v202101beta1::MeshMetrics& health(int index) const;
  ::kentik::synthetics::v202101beta1::MeshMetrics* add_health();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>& health() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string alias = 3 [json_name = "alias"];
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // string target = 4 [json_name = "target"];
  void clear_target() ;
  const std::string& target() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* value);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // .kentik.synthetics.v202101beta1.MeshMetrics metrics = 5 [json_name = "metrics"];
  bool has_metrics() const;
  void clear_metrics() ;
  const ::kentik::synthetics::v202101beta1::MeshMetrics& metrics() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::MeshMetrics* release_metrics();
  ::kentik::synthetics::v202101beta1::MeshMetrics* mutable_metrics();
  void set_allocated_metrics(::kentik::synthetics::v202101beta1::MeshMetrics* value);
  void unsafe_arena_set_allocated_metrics(::kentik::synthetics::v202101beta1::MeshMetrics* value);
  ::kentik::synthetics::v202101beta1::MeshMetrics* unsafe_arena_release_metrics();

  private:
  const ::kentik::synthetics::v202101beta1::MeshMetrics& _internal_metrics() const;
  ::kentik::synthetics::v202101beta1::MeshMetrics* _internal_mutable_metrics();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.MeshColumn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MeshColumn& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::MeshMetrics > health_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::ArenaStringPtr target_;
    ::kentik::synthetics::v202101beta1::MeshMetrics* metrics_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ListAgentsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ListAgentsResponse) */ {
 public:
  inline ListAgentsResponse() : ListAgentsResponse(nullptr) {}
  ~ListAgentsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListAgentsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListAgentsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListAgentsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListAgentsResponse(const ListAgentsResponse& from) : ListAgentsResponse(nullptr, from) {}
  inline ListAgentsResponse(ListAgentsResponse&& from) noexcept
      : ListAgentsResponse(nullptr, std::move(from)) {}
  inline ListAgentsResponse& operator=(const ListAgentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAgentsResponse& operator=(ListAgentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAgentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAgentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAgentsResponse*>(
        &_ListAgentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(ListAgentsResponse& a, ListAgentsResponse& b) { a.Swap(&b); }
  inline void Swap(ListAgentsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAgentsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAgentsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListAgentsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAgentsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListAgentsResponse& from) { ListAgentsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListAgentsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ListAgentsResponse"; }

 protected:
  explicit ListAgentsResponse(::google::protobuf::Arena* arena);
  ListAgentsResponse(::google::protobuf::Arena* arena, const ListAgentsResponse& from);
  ListAgentsResponse(::google::protobuf::Arena* arena, ListAgentsResponse&& from) noexcept
      : ListAgentsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentsFieldNumber = 1,
    kInvalidAgentsCountFieldNumber = 2,
  };
  // repeated .kentik.synthetics.v202101beta1.Agent agents = 1 [json_name = "agents"];
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::kentik::synthetics::v202101beta1::Agent* mutable_agents(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>* mutable_agents();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>& _internal_agents() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>* _internal_mutable_agents();
  public:
  const ::kentik::synthetics::v202101beta1::Agent& agents(int index) const;
  ::kentik::synthetics::v202101beta1::Agent* add_agents();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>& agents() const;
  // uint32 invalid_agents_count = 2 [json_name = "invalidAgentsCount"];
  void clear_invalid_agents_count() ;
  ::uint32_t invalid_agents_count() const;
  void set_invalid_agents_count(::uint32_t value);

  private:
  ::uint32_t _internal_invalid_agents_count() const;
  void _internal_set_invalid_agents_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ListAgentsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListAgentsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::Agent > agents_;
    ::uint32_t invalid_agents_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class IPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.IPInfo) */ {
 public:
  inline IPInfo() : IPInfo(nullptr) {}
  ~IPInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IPInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IPInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline IPInfo(const IPInfo& from) : IPInfo(nullptr, from) {}
  inline IPInfo(IPInfo&& from) noexcept
      : IPInfo(nullptr, std::move(from)) {}
  inline IPInfo& operator=(const IPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPInfo& operator=(IPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPInfo* internal_default_instance() {
    return reinterpret_cast<const IPInfo*>(
        &_IPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(IPInfo& a, IPInfo& b) { a.Swap(&b); }
  inline void Swap(IPInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IPInfo& from) { IPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IPInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.IPInfo"; }

 protected:
  explicit IPInfo(::google::protobuf::Arena* arena);
  IPInfo(::google::protobuf::Arena* arena, const IPInfo& from);
  IPInfo(::google::protobuf::Arena* arena, IPInfo&& from) noexcept
      : IPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpFieldNumber = 1,
    kDeviceIdFieldNumber = 5,
    kSiteIdFieldNumber = 6,
    kEgressFieldNumber = 7,
    kAsnFieldNumber = 2,
    kGeoFieldNumber = 3,
    kDnsFieldNumber = 4,
  };
  // string ip = 1 [json_name = "ip"];
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string device_id = 5 [json_name = "deviceId"];
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // string site_id = 6 [json_name = "siteId"];
  void clear_site_id() ;
  const std::string& site_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_site_id(Arg_&& arg, Args_... args);
  std::string* mutable_site_id();
  PROTOBUF_NODISCARD std::string* release_site_id();
  void set_allocated_site_id(std::string* value);

  private:
  const std::string& _internal_site_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_site_id(
      const std::string& value);
  std::string* _internal_mutable_site_id();

  public:
  // string egress = 7 [json_name = "egress"];
  void clear_egress() ;
  const std::string& egress() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_egress(Arg_&& arg, Args_... args);
  std::string* mutable_egress();
  PROTOBUF_NODISCARD std::string* release_egress();
  void set_allocated_egress(std::string* value);

  private:
  const std::string& _internal_egress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress(
      const std::string& value);
  std::string* _internal_mutable_egress();

  public:
  // .kentik.synthetics.v202101beta1.ASN asn = 2 [json_name = "asn"];
  bool has_asn() const;
  void clear_asn() ;
  const ::kentik::synthetics::v202101beta1::ASN& asn() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::ASN* release_asn();
  ::kentik::synthetics::v202101beta1::ASN* mutable_asn();
  void set_allocated_asn(::kentik::synthetics::v202101beta1::ASN* value);
  void unsafe_arena_set_allocated_asn(::kentik::synthetics::v202101beta1::ASN* value);
  ::kentik::synthetics::v202101beta1::ASN* unsafe_arena_release_asn();

  private:
  const ::kentik::synthetics::v202101beta1::ASN& _internal_asn() const;
  ::kentik::synthetics::v202101beta1::ASN* _internal_mutable_asn();

  public:
  // .kentik.synthetics.v202101beta1.Geo geo = 3 [json_name = "geo"];
  bool has_geo() const;
  void clear_geo() ;
  const ::kentik::synthetics::v202101beta1::Geo& geo() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Geo* release_geo();
  ::kentik::synthetics::v202101beta1::Geo* mutable_geo();
  void set_allocated_geo(::kentik::synthetics::v202101beta1::Geo* value);
  void unsafe_arena_set_allocated_geo(::kentik::synthetics::v202101beta1::Geo* value);
  ::kentik::synthetics::v202101beta1::Geo* unsafe_arena_release_geo();

  private:
  const ::kentik::synthetics::v202101beta1::Geo& _internal_geo() const;
  ::kentik::synthetics::v202101beta1::Geo* _internal_mutable_geo();

  public:
  // .kentik.synthetics.v202101beta1.DNS dns = 4 [json_name = "dns"];
  bool has_dns() const;
  void clear_dns() ;
  const ::kentik::synthetics::v202101beta1::DNS& dns() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::DNS* release_dns();
  ::kentik::synthetics::v202101beta1::DNS* mutable_dns();
  void set_allocated_dns(::kentik::synthetics::v202101beta1::DNS* value);
  void unsafe_arena_set_allocated_dns(::kentik::synthetics::v202101beta1::DNS* value);
  ::kentik::synthetics::v202101beta1::DNS* unsafe_arena_release_dns();

  private:
  const ::kentik::synthetics::v202101beta1::DNS& _internal_dns() const;
  ::kentik::synthetics::v202101beta1::DNS* _internal_mutable_dns();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.IPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      70, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IPInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr site_id_;
    ::google::protobuf::internal::ArenaStringPtr egress_;
    ::kentik::synthetics::v202101beta1::ASN* asn_;
    ::kentik::synthetics::v202101beta1::Geo* geo_;
    ::kentik::synthetics::v202101beta1::DNS* dns_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class HealthMoment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.HealthMoment) */ {
 public:
  inline HealthMoment() : HealthMoment(nullptr) {}
  ~HealthMoment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthMoment* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthMoment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthMoment(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthMoment(const HealthMoment& from) : HealthMoment(nullptr, from) {}
  inline HealthMoment(HealthMoment&& from) noexcept
      : HealthMoment(nullptr, std::move(from)) {}
  inline HealthMoment& operator=(const HealthMoment& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthMoment& operator=(HealthMoment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthMoment& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthMoment* internal_default_instance() {
    return reinterpret_cast<const HealthMoment*>(
        &_HealthMoment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(HealthMoment& a, HealthMoment& b) { a.Swap(&b); }
  inline void Swap(HealthMoment* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthMoment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthMoment* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthMoment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthMoment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthMoment& from) { HealthMoment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthMoment* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.HealthMoment"; }

 protected:
  explicit HealthMoment(::google::protobuf::Arena* arena);
  HealthMoment(::google::protobuf::Arena* arena, const HealthMoment& from);
  HealthMoment(::google::protobuf::Arena* arena, HealthMoment&& from) noexcept
      : HealthMoment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOtherHealthsFieldNumber = 21,
    kSrcIpFieldNumber = 2,
    kDstIpFieldNumber = 3,
    kLatencyHealthFieldNumber = 10,
    kPacketLossHealthFieldNumber = 11,
    kJitterHealthFieldNumber = 16,
    kDataFieldNumber = 17,
    kTaskTypeFieldNumber = 20,
    kTimeFieldNumber = 1,
    kOverallHealthFieldNumber = 12,
    kPacketLossFieldNumber = 4,
    kAvgLatencyFieldNumber = 5,
    kAvgWeightedLatencyFieldNumber = 6,
    kRollingAvgLatencyFieldNumber = 7,
    kRollingStddevLatencyFieldNumber = 8,
    kRollingAvgWeightedLatencyFieldNumber = 9,
    kAvgJitterFieldNumber = 13,
    kRollingAvgJitterFieldNumber = 14,
    kRollingStdJitterFieldNumber = 15,
    kSizeFieldNumber = 18,
    kStatusFieldNumber = 19,
  };
  // map<string, string> other_healths = 21 [json_name = "otherHealths"];
  int other_healths_size() const;
  private:
  int _internal_other_healths_size() const;

  public:
  void clear_other_healths() ;
  const ::google::protobuf::Map<std::string, std::string>& other_healths() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_other_healths();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_other_healths() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_other_healths();

  public:
  // string src_ip = 2 [json_name = "srcIp"];
  void clear_src_ip() ;
  const std::string& src_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_ip(Arg_&& arg, Args_... args);
  std::string* mutable_src_ip();
  PROTOBUF_NODISCARD std::string* release_src_ip();
  void set_allocated_src_ip(std::string* value);

  private:
  const std::string& _internal_src_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_ip(
      const std::string& value);
  std::string* _internal_mutable_src_ip();

  public:
  // string dst_ip = 3 [json_name = "dstIp"];
  void clear_dst_ip() ;
  const std::string& dst_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_ip(Arg_&& arg, Args_... args);
  std::string* mutable_dst_ip();
  PROTOBUF_NODISCARD std::string* release_dst_ip();
  void set_allocated_dst_ip(std::string* value);

  private:
  const std::string& _internal_dst_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_ip(
      const std::string& value);
  std::string* _internal_mutable_dst_ip();

  public:
  // string latency_health = 10 [json_name = "latencyHealth"];
  void clear_latency_health() ;
  const std::string& latency_health() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_latency_health(Arg_&& arg, Args_... args);
  std::string* mutable_latency_health();
  PROTOBUF_NODISCARD std::string* release_latency_health();
  void set_allocated_latency_health(std::string* value);

  private:
  const std::string& _internal_latency_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latency_health(
      const std::string& value);
  std::string* _internal_mutable_latency_health();

  public:
  // string packet_loss_health = 11 [json_name = "packetLossHealth"];
  void clear_packet_loss_health() ;
  const std::string& packet_loss_health() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet_loss_health(Arg_&& arg, Args_... args);
  std::string* mutable_packet_loss_health();
  PROTOBUF_NODISCARD std::string* release_packet_loss_health();
  void set_allocated_packet_loss_health(std::string* value);

  private:
  const std::string& _internal_packet_loss_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_loss_health(
      const std::string& value);
  std::string* _internal_mutable_packet_loss_health();

  public:
  // string jitter_health = 16 [json_name = "jitterHealth"];
  void clear_jitter_health() ;
  const std::string& jitter_health() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jitter_health(Arg_&& arg, Args_... args);
  std::string* mutable_jitter_health();
  PROTOBUF_NODISCARD std::string* release_jitter_health();
  void set_allocated_jitter_health(std::string* value);

  private:
  const std::string& _internal_jitter_health() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jitter_health(
      const std::string& value);
  std::string* _internal_mutable_jitter_health();

  public:
  // string data = 17 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string task_type = 20 [json_name = "taskType"];
  void clear_task_type() ;
  const std::string& task_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_type(Arg_&& arg, Args_... args);
  std::string* mutable_task_type();
  PROTOBUF_NODISCARD std::string* release_task_type();
  void set_allocated_task_type(std::string* value);

  private:
  const std::string& _internal_task_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_type(
      const std::string& value);
  std::string* _internal_mutable_task_type();

  public:
  // .google.protobuf.Timestamp time = 1 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .kentik.synthetics.v202101beta1.Health overall_health = 12 [json_name = "overallHealth"];
  bool has_overall_health() const;
  void clear_overall_health() ;
  const ::kentik::synthetics::v202101beta1::Health& overall_health() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Health* release_overall_health();
  ::kentik::synthetics::v202101beta1::Health* mutable_overall_health();
  void set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  void unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  ::kentik::synthetics::v202101beta1::Health* unsafe_arena_release_overall_health();

  private:
  const ::kentik::synthetics::v202101beta1::Health& _internal_overall_health() const;
  ::kentik::synthetics::v202101beta1::Health* _internal_mutable_overall_health();

  public:
  // double packet_loss = 4 [json_name = "packetLoss"];
  void clear_packet_loss() ;
  double packet_loss() const;
  void set_packet_loss(double value);

  private:
  double _internal_packet_loss() const;
  void _internal_set_packet_loss(double value);

  public:
  // uint32 avg_latency = 5 [json_name = "avgLatency"];
  void clear_avg_latency() ;
  ::uint32_t avg_latency() const;
  void set_avg_latency(::uint32_t value);

  private:
  ::uint32_t _internal_avg_latency() const;
  void _internal_set_avg_latency(::uint32_t value);

  public:
  // uint32 avg_weighted_latency = 6 [json_name = "avgWeightedLatency"];
  void clear_avg_weighted_latency() ;
  ::uint32_t avg_weighted_latency() const;
  void set_avg_weighted_latency(::uint32_t value);

  private:
  ::uint32_t _internal_avg_weighted_latency() const;
  void _internal_set_avg_weighted_latency(::uint32_t value);

  public:
  // uint32 rolling_avg_latency = 7 [json_name = "rollingAvgLatency"];
  void clear_rolling_avg_latency() ;
  ::uint32_t rolling_avg_latency() const;
  void set_rolling_avg_latency(::uint32_t value);

  private:
  ::uint32_t _internal_rolling_avg_latency() const;
  void _internal_set_rolling_avg_latency(::uint32_t value);

  public:
  // uint32 rolling_stddev_latency = 8 [json_name = "rollingStddevLatency"];
  void clear_rolling_stddev_latency() ;
  ::uint32_t rolling_stddev_latency() const;
  void set_rolling_stddev_latency(::uint32_t value);

  private:
  ::uint32_t _internal_rolling_stddev_latency() const;
  void _internal_set_rolling_stddev_latency(::uint32_t value);

  public:
  // uint32 rolling_avg_weighted_latency = 9 [json_name = "rollingAvgWeightedLatency"];
  void clear_rolling_avg_weighted_latency() ;
  ::uint32_t rolling_avg_weighted_latency() const;
  void set_rolling_avg_weighted_latency(::uint32_t value);

  private:
  ::uint32_t _internal_rolling_avg_weighted_latency() const;
  void _internal_set_rolling_avg_weighted_latency(::uint32_t value);

  public:
  // uint32 avg_jitter = 13 [json_name = "avgJitter"];
  void clear_avg_jitter() ;
  ::uint32_t avg_jitter() const;
  void set_avg_jitter(::uint32_t value);

  private:
  ::uint32_t _internal_avg_jitter() const;
  void _internal_set_avg_jitter(::uint32_t value);

  public:
  // uint32 rolling_avg_jitter = 14 [json_name = "rollingAvgJitter"];
  void clear_rolling_avg_jitter() ;
  ::uint32_t rolling_avg_jitter() const;
  void set_rolling_avg_jitter(::uint32_t value);

  private:
  ::uint32_t _internal_rolling_avg_jitter() const;
  void _internal_set_rolling_avg_jitter(::uint32_t value);

  public:
  // uint32 rolling_std_jitter = 15 [json_name = "rollingStdJitter"];
  void clear_rolling_std_jitter() ;
  ::uint32_t rolling_std_jitter() const;
  void set_rolling_std_jitter(::uint32_t value);

  private:
  ::uint32_t _internal_rolling_std_jitter() const;
  void _internal_set_rolling_std_jitter(::uint32_t value);

  public:
  // uint32 size = 18 [json_name = "size"];
  void clear_size() ;
  ::uint32_t size() const;
  void set_size(::uint32_t value);

  private:
  ::uint32_t _internal_size() const;
  void _internal_set_size(::uint32_t value);

  public:
  // uint32 status = 19 [json_name = "status"];
  void clear_status() ;
  ::uint32_t status() const;
  void set_status(::uint32_t value);

  private:
  ::uint32_t _internal_status() const;
  void _internal_set_status(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.HealthMoment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 21, 3,
      151, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthMoment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<HealthMoment_OtherHealthsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        other_healths_;
    ::google::protobuf::internal::ArenaStringPtr src_ip_;
    ::google::protobuf::internal::ArenaStringPtr dst_ip_;
    ::google::protobuf::internal::ArenaStringPtr latency_health_;
    ::google::protobuf::internal::ArenaStringPtr packet_loss_health_;
    ::google::protobuf::internal::ArenaStringPtr jitter_health_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr task_type_;
    ::google::protobuf::Timestamp* time_;
    ::kentik::synthetics::v202101beta1::Health* overall_health_;
    double packet_loss_;
    ::uint32_t avg_latency_;
    ::uint32_t avg_weighted_latency_;
    ::uint32_t rolling_avg_latency_;
    ::uint32_t rolling_stddev_latency_;
    ::uint32_t rolling_avg_weighted_latency_;
    ::uint32_t avg_jitter_;
    ::uint32_t rolling_avg_jitter_;
    ::uint32_t rolling_std_jitter_;
    ::uint32_t size_;
    ::uint32_t status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetAgentResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetAgentResponse) */ {
 public:
  inline GetAgentResponse() : GetAgentResponse(nullptr) {}
  ~GetAgentResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetAgentResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetAgentResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAgentResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAgentResponse(const GetAgentResponse& from) : GetAgentResponse(nullptr, from) {}
  inline GetAgentResponse(GetAgentResponse&& from) noexcept
      : GetAgentResponse(nullptr, std::move(from)) {}
  inline GetAgentResponse& operator=(const GetAgentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAgentResponse& operator=(GetAgentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAgentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAgentResponse* internal_default_instance() {
    return reinterpret_cast<const GetAgentResponse*>(
        &_GetAgentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(GetAgentResponse& a, GetAgentResponse& b) { a.Swap(&b); }
  inline void Swap(GetAgentResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAgentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAgentResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetAgentResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAgentResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAgentResponse& from) { GetAgentResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetAgentResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetAgentResponse"; }

 protected:
  explicit GetAgentResponse(::google::protobuf::Arena* arena);
  GetAgentResponse(::google::protobuf::Arena* arena, const GetAgentResponse& from);
  GetAgentResponse(::google::protobuf::Arena* arena, GetAgentResponse&& from) noexcept
      : GetAgentResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentFieldNumber = 1,
  };
  // .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
  bool has_agent() const;
  void clear_agent() ;
  const ::kentik::synthetics::v202101beta1::Agent& agent() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Agent* release_agent();
  ::kentik::synthetics::v202101beta1::Agent* mutable_agent();
  void set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  void unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  ::kentik::synthetics::v202101beta1::Agent* unsafe_arena_release_agent();

  private:
  const ::kentik::synthetics::v202101beta1::Agent& _internal_agent() const;
  ::kentik::synthetics::v202101beta1::Agent* _internal_mutable_agent();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetAgentResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAgentResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Agent* agent_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TracerouteResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TracerouteResult) */ {
 public:
  inline TracerouteResult() : TracerouteResult(nullptr) {}
  ~TracerouteResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TracerouteResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TracerouteResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TracerouteResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline TracerouteResult(const TracerouteResult& from) : TracerouteResult(nullptr, from) {}
  inline TracerouteResult(TracerouteResult&& from) noexcept
      : TracerouteResult(nullptr, std::move(from)) {}
  inline TracerouteResult& operator=(const TracerouteResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TracerouteResult& operator=(TracerouteResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TracerouteResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TracerouteResult* internal_default_instance() {
    return reinterpret_cast<const TracerouteResult*>(
        &_TracerouteResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(TracerouteResult& a, TracerouteResult& b) { a.Swap(&b); }
  inline void Swap(TracerouteResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TracerouteResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TracerouteResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TracerouteResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TracerouteResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TracerouteResult& from) { TracerouteResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TracerouteResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TracerouteResult"; }

 protected:
  explicit TracerouteResult(::google::protobuf::Arena* arena);
  TracerouteResult(::google::protobuf::Arena* arena, const TracerouteResult& from);
  TracerouteResult(::google::protobuf::Arena* arena, TracerouteResult&& from) noexcept
      : TracerouteResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTracesFieldNumber = 2,
    kTimeFieldNumber = 1,
    kCountFieldNumber = 4,
    kDistanceFieldNumber = 5,
    kHopCountFieldNumber = 3,
  };
  // repeated .kentik.synthetics.v202101beta1.Trace traces = 2 [json_name = "traces"];
  int traces_size() const;
  private:
  int _internal_traces_size() const;

  public:
  void clear_traces() ;
  ::kentik::synthetics::v202101beta1::Trace* mutable_traces(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>* mutable_traces();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>& _internal_traces() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>* _internal_mutable_traces();
  public:
  const ::kentik::synthetics::v202101beta1::Trace& traces(int index) const;
  ::kentik::synthetics::v202101beta1::Trace* add_traces();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>& traces() const;
  // .google.protobuf.Timestamp time = 1 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .kentik.synthetics.v202101beta1.Stats count = 4 [json_name = "count"];
  bool has_count() const;
  void clear_count() ;
  const ::kentik::synthetics::v202101beta1::Stats& count() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Stats* release_count();
  ::kentik::synthetics::v202101beta1::Stats* mutable_count();
  void set_allocated_count(::kentik::synthetics::v202101beta1::Stats* value);
  void unsafe_arena_set_allocated_count(::kentik::synthetics::v202101beta1::Stats* value);
  ::kentik::synthetics::v202101beta1::Stats* unsafe_arena_release_count();

  private:
  const ::kentik::synthetics::v202101beta1::Stats& _internal_count() const;
  ::kentik::synthetics::v202101beta1::Stats* _internal_mutable_count();

  public:
  // .kentik.synthetics.v202101beta1.Stats distance = 5 [json_name = "distance"];
  bool has_distance() const;
  void clear_distance() ;
  const ::kentik::synthetics::v202101beta1::Stats& distance() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Stats* release_distance();
  ::kentik::synthetics::v202101beta1::Stats* mutable_distance();
  void set_allocated_distance(::kentik::synthetics::v202101beta1::Stats* value);
  void unsafe_arena_set_allocated_distance(::kentik::synthetics::v202101beta1::Stats* value);
  ::kentik::synthetics::v202101beta1::Stats* unsafe_arena_release_distance();

  private:
  const ::kentik::synthetics::v202101beta1::Stats& _internal_distance() const;
  ::kentik::synthetics::v202101beta1::Stats* _internal_mutable_distance();

  public:
  // int32 hop_count = 3 [json_name = "hopCount"];
  void clear_hop_count() ;
  ::int32_t hop_count() const;
  void set_hop_count(::int32_t value);

  private:
  ::int32_t _internal_hop_count() const;
  void _internal_set_hop_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TracerouteResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TracerouteResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::Trace > traces_;
    ::google::protobuf::Timestamp* time_;
    ::kentik::synthetics::v202101beta1::Stats* count_;
    ::kentik::synthetics::v202101beta1::Stats* distance_;
    ::int32_t hop_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TracerouteLookup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TracerouteLookup) */ {
 public:
  inline TracerouteLookup() : TracerouteLookup(nullptr) {}
  ~TracerouteLookup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TracerouteLookup* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TracerouteLookup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TracerouteLookup(
      ::google::protobuf::internal::ConstantInitialized);

  inline TracerouteLookup(const TracerouteLookup& from) : TracerouteLookup(nullptr, from) {}
  inline TracerouteLookup(TracerouteLookup&& from) noexcept
      : TracerouteLookup(nullptr, std::move(from)) {}
  inline TracerouteLookup& operator=(const TracerouteLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TracerouteLookup& operator=(TracerouteLookup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TracerouteLookup& default_instance() {
    return *internal_default_instance();
  }
  static inline const TracerouteLookup* internal_default_instance() {
    return reinterpret_cast<const TracerouteLookup*>(
        &_TracerouteLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(TracerouteLookup& a, TracerouteLookup& b) { a.Swap(&b); }
  inline void Swap(TracerouteLookup* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TracerouteLookup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TracerouteLookup* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TracerouteLookup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TracerouteLookup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TracerouteLookup& from) { TracerouteLookup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TracerouteLookup* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TracerouteLookup"; }

 protected:
  explicit TracerouteLookup(::google::protobuf::Arena* arena);
  TracerouteLookup(::google::protobuf::Arena* arena, const TracerouteLookup& from);
  TracerouteLookup(::google::protobuf::Arena* arena, TracerouteLookup&& from) noexcept
      : TracerouteLookup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentIdByIpFieldNumber = 1,
    kAgentsFieldNumber = 2,
    kAsnsFieldNumber = 3,
    kDeviceIdByIpFieldNumber = 4,
    kSiteIdByIpFieldNumber = 5,
    kIpsFieldNumber = 6,
  };
  // repeated .kentik.synthetics.v202101beta1.IDByIP agent_id_by_ip = 1 [json_name = "agentIdByIp"];
  int agent_id_by_ip_size() const;
  private:
  int _internal_agent_id_by_ip_size() const;

  public:
  void clear_agent_id_by_ip() ;
  ::kentik::synthetics::v202101beta1::IDByIP* mutable_agent_id_by_ip(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* mutable_agent_id_by_ip();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& _internal_agent_id_by_ip() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* _internal_mutable_agent_id_by_ip();
  public:
  const ::kentik::synthetics::v202101beta1::IDByIP& agent_id_by_ip(int index) const;
  ::kentik::synthetics::v202101beta1::IDByIP* add_agent_id_by_ip();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& agent_id_by_ip() const;
  // repeated .kentik.synthetics.v202101beta1.Agent agents = 2 [json_name = "agents"];
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::kentik::synthetics::v202101beta1::Agent* mutable_agents(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>* mutable_agents();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>& _internal_agents() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>* _internal_mutable_agents();
  public:
  const ::kentik::synthetics::v202101beta1::Agent& agents(int index) const;
  ::kentik::synthetics::v202101beta1::Agent* add_agents();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>& agents() const;
  // repeated .kentik.synthetics.v202101beta1.ASN asns = 3 [json_name = "asns"];
  int asns_size() const;
  private:
  int _internal_asns_size() const;

  public:
  void clear_asns() ;
  ::kentik::synthetics::v202101beta1::ASN* mutable_asns(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>* mutable_asns();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>& _internal_asns() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>* _internal_mutable_asns();
  public:
  const ::kentik::synthetics::v202101beta1::ASN& asns(int index) const;
  ::kentik::synthetics::v202101beta1::ASN* add_asns();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>& asns() const;
  // repeated .kentik.synthetics.v202101beta1.IDByIP device_id_by_ip = 4 [json_name = "deviceIdByIp"];
  int device_id_by_ip_size() const;
  private:
  int _internal_device_id_by_ip_size() const;

  public:
  void clear_device_id_by_ip() ;
  ::kentik::synthetics::v202101beta1::IDByIP* mutable_device_id_by_ip(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* mutable_device_id_by_ip();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& _internal_device_id_by_ip() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* _internal_mutable_device_id_by_ip();
  public:
  const ::kentik::synthetics::v202101beta1::IDByIP& device_id_by_ip(int index) const;
  ::kentik::synthetics::v202101beta1::IDByIP* add_device_id_by_ip();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& device_id_by_ip() const;
  // repeated .kentik.synthetics.v202101beta1.IDByIP site_id_by_ip = 5 [json_name = "siteIdByIp"];
  int site_id_by_ip_size() const;
  private:
  int _internal_site_id_by_ip_size() const;

  public:
  void clear_site_id_by_ip() ;
  ::kentik::synthetics::v202101beta1::IDByIP* mutable_site_id_by_ip(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* mutable_site_id_by_ip();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& _internal_site_id_by_ip() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* _internal_mutable_site_id_by_ip();
  public:
  const ::kentik::synthetics::v202101beta1::IDByIP& site_id_by_ip(int index) const;
  ::kentik::synthetics::v202101beta1::IDByIP* add_site_id_by_ip();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& site_id_by_ip() const;
  // repeated .kentik.synthetics.v202101beta1.IPInfo ips = 6 [json_name = "ips"];
  int ips_size() const;
  private:
  int _internal_ips_size() const;

  public:
  void clear_ips() ;
  ::kentik::synthetics::v202101beta1::IPInfo* mutable_ips(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>* mutable_ips();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>& _internal_ips() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>* _internal_mutable_ips();
  public:
  const ::kentik::synthetics::v202101beta1::IPInfo& ips(int index) const;
  ::kentik::synthetics::v202101beta1::IPInfo* add_ips();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>& ips() const;
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TracerouteLookup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TracerouteLookup& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::IDByIP > agent_id_by_ip_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::Agent > agents_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::ASN > asns_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::IDByIP > device_id_by_ip_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::IDByIP > site_id_by_ip_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::IPInfo > ips_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class Test final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.Test) */ {
 public:
  inline Test() : Test(nullptr) {}
  ~Test() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Test* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Test));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Test(
      ::google::protobuf::internal::ConstantInitialized);

  inline Test(const Test& from) : Test(nullptr, from) {}
  inline Test(Test&& from) noexcept
      : Test(nullptr, std::move(from)) {}
  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test& operator=(Test&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Test& default_instance() {
    return *internal_default_instance();
  }
  static inline const Test* internal_default_instance() {
    return reinterpret_cast<const Test*>(
        &_Test_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(Test& a, Test& b) { a.Swap(&b); }
  inline void Swap(Test* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Test* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Test* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Test>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Test& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Test& from) { Test::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Test* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.Test"; }

 protected:
  explicit Test(::google::protobuf::Arena* arena);
  Test(::google::protobuf::Arena* arena, const Test& from);
  Test(::google::protobuf::Arena* arena, Test&& from) noexcept
      : Test(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDeviceIdFieldNumber = 4,
    kSettingsFieldNumber = 6,
    kExpiresOnFieldNumber = 7,
    kCdateFieldNumber = 8,
    kEdateFieldNumber = 9,
    kCreatedByFieldNumber = 10,
    kLastUpdatedByFieldNumber = 11,
    kStatusFieldNumber = 5,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string type = 3 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string device_id = 4 [json_name = "deviceId"];
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // .kentik.synthetics.v202101beta1.TestSettings settings = 6 [json_name = "settings"];
  bool has_settings() const;
  void clear_settings() ;
  const ::kentik::synthetics::v202101beta1::TestSettings& settings() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TestSettings* release_settings();
  ::kentik::synthetics::v202101beta1::TestSettings* mutable_settings();
  void set_allocated_settings(::kentik::synthetics::v202101beta1::TestSettings* value);
  void unsafe_arena_set_allocated_settings(::kentik::synthetics::v202101beta1::TestSettings* value);
  ::kentik::synthetics::v202101beta1::TestSettings* unsafe_arena_release_settings();

  private:
  const ::kentik::synthetics::v202101beta1::TestSettings& _internal_settings() const;
  ::kentik::synthetics::v202101beta1::TestSettings* _internal_mutable_settings();

  public:
  // .google.protobuf.Timestamp expires_on = 7 [json_name = "expiresOn"];
  bool has_expires_on() const;
  void clear_expires_on() ;
  const ::google::protobuf::Timestamp& expires_on() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_expires_on();
  ::google::protobuf::Timestamp* mutable_expires_on();
  void set_allocated_expires_on(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expires_on(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expires_on();

  private:
  const ::google::protobuf::Timestamp& _internal_expires_on() const;
  ::google::protobuf::Timestamp* _internal_mutable_expires_on();

  public:
  // .google.protobuf.Timestamp cdate = 8 [json_name = "cdate"];
  bool has_cdate() const;
  void clear_cdate() ;
  const ::google::protobuf::Timestamp& cdate() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_cdate();
  ::google::protobuf::Timestamp* mutable_cdate();
  void set_allocated_cdate(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_cdate(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_cdate();

  private:
  const ::google::protobuf::Timestamp& _internal_cdate() const;
  ::google::protobuf::Timestamp* _internal_mutable_cdate();

  public:
  // .google.protobuf.Timestamp edate = 9 [json_name = "edate"];
  bool has_edate() const;
  void clear_edate() ;
  const ::google::protobuf::Timestamp& edate() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_edate();
  ::google::protobuf::Timestamp* mutable_edate();
  void set_allocated_edate(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_edate(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_edate();

  private:
  const ::google::protobuf::Timestamp& _internal_edate() const;
  ::google::protobuf::Timestamp* _internal_mutable_edate();

  public:
  // .kentik.synthetics.v202101beta1.UserInfo created_by = 10 [json_name = "createdBy"];
  bool has_created_by() const;
  void clear_created_by() ;
  const ::kentik::synthetics::v202101beta1::UserInfo& created_by() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::UserInfo* release_created_by();
  ::kentik::synthetics::v202101beta1::UserInfo* mutable_created_by();
  void set_allocated_created_by(::kentik::synthetics::v202101beta1::UserInfo* value);
  void unsafe_arena_set_allocated_created_by(::kentik::synthetics::v202101beta1::UserInfo* value);
  ::kentik::synthetics::v202101beta1::UserInfo* unsafe_arena_release_created_by();

  private:
  const ::kentik::synthetics::v202101beta1::UserInfo& _internal_created_by() const;
  ::kentik::synthetics::v202101beta1::UserInfo* _internal_mutable_created_by();

  public:
  // .kentik.synthetics.v202101beta1.UserInfo last_updated_by = 11 [json_name = "lastUpdatedBy"];
  bool has_last_updated_by() const;
  void clear_last_updated_by() ;
  const ::kentik::synthetics::v202101beta1::UserInfo& last_updated_by() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::UserInfo* release_last_updated_by();
  ::kentik::synthetics::v202101beta1::UserInfo* mutable_last_updated_by();
  void set_allocated_last_updated_by(::kentik::synthetics::v202101beta1::UserInfo* value);
  void unsafe_arena_set_allocated_last_updated_by(::kentik::synthetics::v202101beta1::UserInfo* value);
  ::kentik::synthetics::v202101beta1::UserInfo* unsafe_arena_release_last_updated_by();

  private:
  const ::kentik::synthetics::v202101beta1::UserInfo& _internal_last_updated_by() const;
  ::kentik::synthetics::v202101beta1::UserInfo* _internal_mutable_last_updated_by();

  public:
  // .kentik.synthetics.v202101beta1.TestStatus status = 5 [json_name = "status"];
  void clear_status() ;
  ::kentik::synthetics::v202101beta1::TestStatus status() const;
  void set_status(::kentik::synthetics::v202101beta1::TestStatus value);

  private:
  ::kentik::synthetics::v202101beta1::TestStatus _internal_status() const;
  void _internal_set_status(::kentik::synthetics::v202101beta1::TestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.Test)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 6,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Test& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::kentik::synthetics::v202101beta1::TestSettings* settings_;
    ::google::protobuf::Timestamp* expires_on_;
    ::google::protobuf::Timestamp* cdate_;
    ::google::protobuf::Timestamp* edate_;
    ::kentik::synthetics::v202101beta1::UserInfo* created_by_;
    ::kentik::synthetics::v202101beta1::UserInfo* last_updated_by_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class MeshResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.MeshResponse) */ {
 public:
  inline MeshResponse() : MeshResponse(nullptr) {}
  ~MeshResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MeshResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MeshResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MeshResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MeshResponse(const MeshResponse& from) : MeshResponse(nullptr, from) {}
  inline MeshResponse(MeshResponse&& from) noexcept
      : MeshResponse(nullptr, std::move(from)) {}
  inline MeshResponse& operator=(const MeshResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeshResponse& operator=(MeshResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeshResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeshResponse* internal_default_instance() {
    return reinterpret_cast<const MeshResponse*>(
        &_MeshResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(MeshResponse& a, MeshResponse& b) { a.Swap(&b); }
  inline void Swap(MeshResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeshResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeshResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MeshResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MeshResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MeshResponse& from) { MeshResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MeshResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.MeshResponse"; }

 protected:
  explicit MeshResponse(::google::protobuf::Arena* arena);
  MeshResponse(::google::protobuf::Arena* arena, const MeshResponse& from);
  MeshResponse(::google::protobuf::Arena* arena, MeshResponse&& from) noexcept
      : MeshResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kColumnsFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLocalIpFieldNumber = 3,
    kIpFieldNumber = 4,
    kAliasFieldNumber = 5,
  };
  // repeated .kentik.synthetics.v202101beta1.MeshColumn columns = 6 [json_name = "columns"];
  int columns_size() const;
  private:
  int _internal_columns_size() const;

  public:
  void clear_columns() ;
  ::kentik::synthetics::v202101beta1::MeshColumn* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>* mutable_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>& _internal_columns() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>* _internal_mutable_columns();
  public:
  const ::kentik::synthetics::v202101beta1::MeshColumn& columns(int index) const;
  ::kentik::synthetics::v202101beta1::MeshColumn* add_columns();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>& columns() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string local_ip = 3 [json_name = "localIp"];
  void clear_local_ip() ;
  const std::string& local_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_ip(Arg_&& arg, Args_... args);
  std::string* mutable_local_ip();
  PROTOBUF_NODISCARD std::string* release_local_ip();
  void set_allocated_local_ip(std::string* value);

  private:
  const std::string& _internal_local_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_ip(
      const std::string& value);
  std::string* _internal_mutable_local_ip();

  public:
  // string ip = 4 [json_name = "ip"];
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string alias = 5 [json_name = "alias"];
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.MeshResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MeshResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::MeshColumn > columns_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr local_ip_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class AgentHealth final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.AgentHealth) */ {
 public:
  inline AgentHealth() : AgentHealth(nullptr) {}
  ~AgentHealth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AgentHealth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AgentHealth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AgentHealth(
      ::google::protobuf::internal::ConstantInitialized);

  inline AgentHealth(const AgentHealth& from) : AgentHealth(nullptr, from) {}
  inline AgentHealth(AgentHealth&& from) noexcept
      : AgentHealth(nullptr, std::move(from)) {}
  inline AgentHealth& operator=(const AgentHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentHealth& operator=(AgentHealth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentHealth* internal_default_instance() {
    return reinterpret_cast<const AgentHealth*>(
        &_AgentHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AgentHealth& a, AgentHealth& b) { a.Swap(&b); }
  inline void Swap(AgentHealth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentHealth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentHealth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AgentHealth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AgentHealth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AgentHealth& from) { AgentHealth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AgentHealth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.AgentHealth"; }

 protected:
  explicit AgentHealth(::google::protobuf::Arena* arena);
  AgentHealth(::google::protobuf::Arena* arena, const AgentHealth& from);
  AgentHealth(::google::protobuf::Arena* arena, AgentHealth&& from) noexcept
      : AgentHealth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHealthFieldNumber = 2,
    kAgentFieldNumber = 1,
    kOverallHealthFieldNumber = 3,
  };
  // repeated .kentik.synthetics.v202101beta1.HealthMoment health = 2 [json_name = "health"];
  int health_size() const;
  private:
  int _internal_health_size() const;

  public:
  void clear_health() ;
  ::kentik::synthetics::v202101beta1::HealthMoment* mutable_health(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>* mutable_health();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>& _internal_health() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>* _internal_mutable_health();
  public:
  const ::kentik::synthetics::v202101beta1::HealthMoment& health(int index) const;
  ::kentik::synthetics::v202101beta1::HealthMoment* add_health();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>& health() const;
  // .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
  bool has_agent() const;
  void clear_agent() ;
  const ::kentik::synthetics::v202101beta1::Agent& agent() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Agent* release_agent();
  ::kentik::synthetics::v202101beta1::Agent* mutable_agent();
  void set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  void unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value);
  ::kentik::synthetics::v202101beta1::Agent* unsafe_arena_release_agent();

  private:
  const ::kentik::synthetics::v202101beta1::Agent& _internal_agent() const;
  ::kentik::synthetics::v202101beta1::Agent* _internal_mutable_agent();

  public:
  // .kentik.synthetics.v202101beta1.Health overall_health = 3 [json_name = "overallHealth"];
  bool has_overall_health() const;
  void clear_overall_health() ;
  const ::kentik::synthetics::v202101beta1::Health& overall_health() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Health* release_overall_health();
  ::kentik::synthetics::v202101beta1::Health* mutable_overall_health();
  void set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  void unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  ::kentik::synthetics::v202101beta1::Health* unsafe_arena_release_overall_health();

  private:
  const ::kentik::synthetics::v202101beta1::Health& _internal_overall_health() const;
  ::kentik::synthetics::v202101beta1::Health* _internal_mutable_overall_health();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.AgentHealth)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AgentHealth& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::HealthMoment > health_;
    ::kentik::synthetics::v202101beta1::Agent* agent_;
    ::kentik::synthetics::v202101beta1::Health* overall_health_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TaskHealth final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TaskHealth) */ {
 public:
  inline TaskHealth() : TaskHealth(nullptr) {}
  ~TaskHealth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskHealth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskHealth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskHealth(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskHealth(const TaskHealth& from) : TaskHealth(nullptr, from) {}
  inline TaskHealth(TaskHealth&& from) noexcept
      : TaskHealth(nullptr, std::move(from)) {}
  inline TaskHealth& operator=(const TaskHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskHealth& operator=(TaskHealth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskHealth* internal_default_instance() {
    return reinterpret_cast<const TaskHealth*>(
        &_TaskHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TaskHealth& a, TaskHealth& b) { a.Swap(&b); }
  inline void Swap(TaskHealth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskHealth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskHealth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskHealth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskHealth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskHealth& from) { TaskHealth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskHealth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TaskHealth"; }

 protected:
  explicit TaskHealth(::google::protobuf::Arena* arena);
  TaskHealth(::google::protobuf::Arena* arena, const TaskHealth& from);
  TaskHealth(::google::protobuf::Arena* arena, TaskHealth&& from) noexcept
      : TaskHealth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgentsFieldNumber = 2,
    kTaskFieldNumber = 1,
    kOverallHealthFieldNumber = 3,
    kTargetAgentFieldNumber = 4,
  };
  // repeated .kentik.synthetics.v202101beta1.AgentHealth agents = 2 [json_name = "agents"];
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::kentik::synthetics::v202101beta1::AgentHealth* mutable_agents(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>* mutable_agents();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>& _internal_agents() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>* _internal_mutable_agents();
  public:
  const ::kentik::synthetics::v202101beta1::AgentHealth& agents(int index) const;
  ::kentik::synthetics::v202101beta1::AgentHealth* add_agents();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>& agents() const;
  // .kentik.synthetics.v202101beta1.Task task = 1 [json_name = "task"];
  bool has_task() const;
  void clear_task() ;
  const ::kentik::synthetics::v202101beta1::Task& task() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Task* release_task();
  ::kentik::synthetics::v202101beta1::Task* mutable_task();
  void set_allocated_task(::kentik::synthetics::v202101beta1::Task* value);
  void unsafe_arena_set_allocated_task(::kentik::synthetics::v202101beta1::Task* value);
  ::kentik::synthetics::v202101beta1::Task* unsafe_arena_release_task();

  private:
  const ::kentik::synthetics::v202101beta1::Task& _internal_task() const;
  ::kentik::synthetics::v202101beta1::Task* _internal_mutable_task();

  public:
  // .kentik.synthetics.v202101beta1.Health overall_health = 3 [json_name = "overallHealth"];
  bool has_overall_health() const;
  void clear_overall_health() ;
  const ::kentik::synthetics::v202101beta1::Health& overall_health() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Health* release_overall_health();
  ::kentik::synthetics::v202101beta1::Health* mutable_overall_health();
  void set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  void unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  ::kentik::synthetics::v202101beta1::Health* unsafe_arena_release_overall_health();

  private:
  const ::kentik::synthetics::v202101beta1::Health& _internal_overall_health() const;
  ::kentik::synthetics::v202101beta1::Health* _internal_mutable_overall_health();

  public:
  // .kentik.synthetics.v202101beta1.Agent target_agent = 4 [json_name = "targetAgent"];
  bool has_target_agent() const;
  void clear_target_agent() ;
  const ::kentik::synthetics::v202101beta1::Agent& target_agent() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Agent* release_target_agent();
  ::kentik::synthetics::v202101beta1::Agent* mutable_target_agent();
  void set_allocated_target_agent(::kentik::synthetics::v202101beta1::Agent* value);
  void unsafe_arena_set_allocated_target_agent(::kentik::synthetics::v202101beta1::Agent* value);
  ::kentik::synthetics::v202101beta1::Agent* unsafe_arena_release_target_agent();

  private:
  const ::kentik::synthetics::v202101beta1::Agent& _internal_target_agent() const;
  ::kentik::synthetics::v202101beta1::Agent* _internal_mutable_target_agent();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TaskHealth)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskHealth& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::AgentHealth > agents_;
    ::kentik::synthetics::v202101beta1::Task* task_;
    ::kentik::synthetics::v202101beta1::Health* overall_health_;
    ::kentik::synthetics::v202101beta1::Agent* target_agent_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class PatchTestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.PatchTestResponse) */ {
 public:
  inline PatchTestResponse() : PatchTestResponse(nullptr) {}
  ~PatchTestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchTestResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchTestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchTestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchTestResponse(const PatchTestResponse& from) : PatchTestResponse(nullptr, from) {}
  inline PatchTestResponse(PatchTestResponse&& from) noexcept
      : PatchTestResponse(nullptr, std::move(from)) {}
  inline PatchTestResponse& operator=(const PatchTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchTestResponse& operator=(PatchTestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchTestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchTestResponse* internal_default_instance() {
    return reinterpret_cast<const PatchTestResponse*>(
        &_PatchTestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 76;
  friend void swap(PatchTestResponse& a, PatchTestResponse& b) { a.Swap(&b); }
  inline void Swap(PatchTestResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchTestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchTestResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchTestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchTestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchTestResponse& from) { PatchTestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchTestResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.PatchTestResponse"; }

 protected:
  explicit PatchTestResponse(::google::protobuf::Arena* arena);
  PatchTestResponse(::google::protobuf::Arena* arena, const PatchTestResponse& from);
  PatchTestResponse(::google::protobuf::Arena* arena, PatchTestResponse&& from) noexcept
      : PatchTestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestFieldNumber = 1,
  };
  // .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
  bool has_test() const;
  void clear_test() ;
  const ::kentik::synthetics::v202101beta1::Test& test() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Test* release_test();
  ::kentik::synthetics::v202101beta1::Test* mutable_test();
  void set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  void unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  ::kentik::synthetics::v202101beta1::Test* unsafe_arena_release_test();

  private:
  const ::kentik::synthetics::v202101beta1::Test& _internal_test() const;
  ::kentik::synthetics::v202101beta1::Test* _internal_mutable_test();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.PatchTestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchTestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Test* test_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class PatchTestRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.PatchTestRequest) */ {
 public:
  inline PatchTestRequest() : PatchTestRequest(nullptr) {}
  ~PatchTestRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatchTestRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatchTestRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatchTestRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PatchTestRequest(const PatchTestRequest& from) : PatchTestRequest(nullptr, from) {}
  inline PatchTestRequest(PatchTestRequest&& from) noexcept
      : PatchTestRequest(nullptr, std::move(from)) {}
  inline PatchTestRequest& operator=(const PatchTestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchTestRequest& operator=(PatchTestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchTestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchTestRequest* internal_default_instance() {
    return reinterpret_cast<const PatchTestRequest*>(
        &_PatchTestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 75;
  friend void swap(PatchTestRequest& a, PatchTestRequest& b) { a.Swap(&b); }
  inline void Swap(PatchTestRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchTestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchTestRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatchTestRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatchTestRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatchTestRequest& from) { PatchTestRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatchTestRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.PatchTestRequest"; }

 protected:
  explicit PatchTestRequest(::google::protobuf::Arena* arena);
  PatchTestRequest(::google::protobuf::Arena* arena, const PatchTestRequest& from);
  PatchTestRequest(::google::protobuf::Arena* arena, PatchTestRequest&& from) noexcept
      : PatchTestRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestFieldNumber = 1,
    kMaskFieldNumber = 2,
  };
  // .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
  bool has_test() const;
  void clear_test() ;
  const ::kentik::synthetics::v202101beta1::Test& test() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Test* release_test();
  ::kentik::synthetics::v202101beta1::Test* mutable_test();
  void set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  void unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  ::kentik::synthetics::v202101beta1::Test* unsafe_arena_release_test();

  private:
  const ::kentik::synthetics::v202101beta1::Test& _internal_test() const;
  ::kentik::synthetics::v202101beta1::Test* _internal_mutable_test();

  public:
  // .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
  bool has_mask() const;
  void clear_mask() ;
  const ::google::protobuf::FieldMask& mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_mask();
  ::google::protobuf::FieldMask* mutable_mask();
  void set_allocated_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_mask();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.PatchTestRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PatchTestRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Test* test_;
    ::google::protobuf::FieldMask* mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class ListTestsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.ListTestsResponse) */ {
 public:
  inline ListTestsResponse() : ListTestsResponse(nullptr) {}
  ~ListTestsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListTestsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListTestsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListTestsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListTestsResponse(const ListTestsResponse& from) : ListTestsResponse(nullptr, from) {}
  inline ListTestsResponse(ListTestsResponse&& from) noexcept
      : ListTestsResponse(nullptr, std::move(from)) {}
  inline ListTestsResponse& operator=(const ListTestsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTestsResponse& operator=(ListTestsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTestsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTestsResponse* internal_default_instance() {
    return reinterpret_cast<const ListTestsResponse*>(
        &_ListTestsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 68;
  friend void swap(ListTestsResponse& a, ListTestsResponse& b) { a.Swap(&b); }
  inline void Swap(ListTestsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTestsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTestsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListTestsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListTestsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListTestsResponse& from) { ListTestsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListTestsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.ListTestsResponse"; }

 protected:
  explicit ListTestsResponse(::google::protobuf::Arena* arena);
  ListTestsResponse(::google::protobuf::Arena* arena, const ListTestsResponse& from);
  ListTestsResponse(::google::protobuf::Arena* arena, ListTestsResponse&& from) noexcept
      : ListTestsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestsFieldNumber = 1,
    kInvalidTestsCountFieldNumber = 2,
  };
  // repeated .kentik.synthetics.v202101beta1.Test tests = 1 [json_name = "tests"];
  int tests_size() const;
  private:
  int _internal_tests_size() const;

  public:
  void clear_tests() ;
  ::kentik::synthetics::v202101beta1::Test* mutable_tests(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>* mutable_tests();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>& _internal_tests() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>* _internal_mutable_tests();
  public:
  const ::kentik::synthetics::v202101beta1::Test& tests(int index) const;
  ::kentik::synthetics::v202101beta1::Test* add_tests();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>& tests() const;
  // uint32 invalid_tests_count = 2 [json_name = "invalidTestsCount"];
  void clear_invalid_tests_count() ;
  ::uint32_t invalid_tests_count() const;
  void set_invalid_tests_count(::uint32_t value);

  private:
  ::uint32_t _internal_invalid_tests_count() const;
  void _internal_set_invalid_tests_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.ListTestsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListTestsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::Test > tests_;
    ::uint32_t invalid_tests_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetTraceForTestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetTraceForTestResponse) */ {
 public:
  inline GetTraceForTestResponse() : GetTraceForTestResponse(nullptr) {}
  ~GetTraceForTestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTraceForTestResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTraceForTestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTraceForTestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTraceForTestResponse(const GetTraceForTestResponse& from) : GetTraceForTestResponse(nullptr, from) {}
  inline GetTraceForTestResponse(GetTraceForTestResponse&& from) noexcept
      : GetTraceForTestResponse(nullptr, std::move(from)) {}
  inline GetTraceForTestResponse& operator=(const GetTraceForTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTraceForTestResponse& operator=(GetTraceForTestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTraceForTestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTraceForTestResponse* internal_default_instance() {
    return reinterpret_cast<const GetTraceForTestResponse*>(
        &_GetTraceForTestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(GetTraceForTestResponse& a, GetTraceForTestResponse& b) { a.Swap(&b); }
  inline void Swap(GetTraceForTestResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTraceForTestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTraceForTestResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTraceForTestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTraceForTestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTraceForTestResponse& from) { GetTraceForTestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTraceForTestResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetTraceForTestResponse"; }

 protected:
  explicit GetTraceForTestResponse(::google::protobuf::Arena* arena);
  GetTraceForTestResponse(::google::protobuf::Arena* arena, const GetTraceForTestResponse& from);
  GetTraceForTestResponse(::google::protobuf::Arena* arena, GetTraceForTestResponse&& from) noexcept
      : GetTraceForTestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTraceRoutesFieldNumber = 2,
    kLookupsFieldNumber = 1,
    kTraceRoutesInfoFieldNumber = 3,
  };
  // repeated .kentik.synthetics.v202101beta1.TracerouteResult trace_routes = 2 [json_name = "traceRoutes"];
  int trace_routes_size() const;
  private:
  int _internal_trace_routes_size() const;

  public:
  void clear_trace_routes() ;
  ::kentik::synthetics::v202101beta1::TracerouteResult* mutable_trace_routes(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>* mutable_trace_routes();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>& _internal_trace_routes() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>* _internal_mutable_trace_routes();
  public:
  const ::kentik::synthetics::v202101beta1::TracerouteResult& trace_routes(int index) const;
  ::kentik::synthetics::v202101beta1::TracerouteResult* add_trace_routes();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>& trace_routes() const;
  // .kentik.synthetics.v202101beta1.TracerouteLookup lookups = 1 [json_name = "lookups"];
  bool has_lookups() const;
  void clear_lookups() ;
  const ::kentik::synthetics::v202101beta1::TracerouteLookup& lookups() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TracerouteLookup* release_lookups();
  ::kentik::synthetics::v202101beta1::TracerouteLookup* mutable_lookups();
  void set_allocated_lookups(::kentik::synthetics::v202101beta1::TracerouteLookup* value);
  void unsafe_arena_set_allocated_lookups(::kentik::synthetics::v202101beta1::TracerouteLookup* value);
  ::kentik::synthetics::v202101beta1::TracerouteLookup* unsafe_arena_release_lookups();

  private:
  const ::kentik::synthetics::v202101beta1::TracerouteLookup& _internal_lookups() const;
  ::kentik::synthetics::v202101beta1::TracerouteLookup* _internal_mutable_lookups();

  public:
  // .kentik.synthetics.v202101beta1.TracerouteInfo trace_routes_info = 3 [json_name = "traceRoutesInfo"];
  bool has_trace_routes_info() const;
  void clear_trace_routes_info() ;
  const ::kentik::synthetics::v202101beta1::TracerouteInfo& trace_routes_info() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::TracerouteInfo* release_trace_routes_info();
  ::kentik::synthetics::v202101beta1::TracerouteInfo* mutable_trace_routes_info();
  void set_allocated_trace_routes_info(::kentik::synthetics::v202101beta1::TracerouteInfo* value);
  void unsafe_arena_set_allocated_trace_routes_info(::kentik::synthetics::v202101beta1::TracerouteInfo* value);
  ::kentik::synthetics::v202101beta1::TracerouteInfo* unsafe_arena_release_trace_routes_info();

  private:
  const ::kentik::synthetics::v202101beta1::TracerouteInfo& _internal_trace_routes_info() const;
  ::kentik::synthetics::v202101beta1::TracerouteInfo* _internal_mutable_trace_routes_info();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetTraceForTestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTraceForTestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::TracerouteResult > trace_routes_;
    ::kentik::synthetics::v202101beta1::TracerouteLookup* lookups_;
    ::kentik::synthetics::v202101beta1::TracerouteInfo* trace_routes_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetTestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetTestResponse) */ {
 public:
  inline GetTestResponse() : GetTestResponse(nullptr) {}
  ~GetTestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetTestResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetTestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTestResponse(const GetTestResponse& from) : GetTestResponse(nullptr, from) {}
  inline GetTestResponse(GetTestResponse&& from) noexcept
      : GetTestResponse(nullptr, std::move(from)) {}
  inline GetTestResponse& operator=(const GetTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTestResponse& operator=(GetTestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTestResponse* internal_default_instance() {
    return reinterpret_cast<const GetTestResponse*>(
        &_GetTestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 72;
  friend void swap(GetTestResponse& a, GetTestResponse& b) { a.Swap(&b); }
  inline void Swap(GetTestResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTestResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetTestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTestResponse& from) { GetTestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetTestResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetTestResponse"; }

 protected:
  explicit GetTestResponse(::google::protobuf::Arena* arena);
  GetTestResponse(::google::protobuf::Arena* arena, const GetTestResponse& from);
  GetTestResponse(::google::protobuf::Arena* arena, GetTestResponse&& from) noexcept
      : GetTestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestFieldNumber = 1,
  };
  // .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
  bool has_test() const;
  void clear_test() ;
  const ::kentik::synthetics::v202101beta1::Test& test() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Test* release_test();
  ::kentik::synthetics::v202101beta1::Test* mutable_test();
  void set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  void unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  ::kentik::synthetics::v202101beta1::Test* unsafe_arena_release_test();

  private:
  const ::kentik::synthetics::v202101beta1::Test& _internal_test() const;
  ::kentik::synthetics::v202101beta1::Test* _internal_mutable_test();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetTestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Test* test_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class CreateTestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.CreateTestResponse) */ {
 public:
  inline CreateTestResponse() : CreateTestResponse(nullptr) {}
  ~CreateTestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateTestResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateTestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTestResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTestResponse(const CreateTestResponse& from) : CreateTestResponse(nullptr, from) {}
  inline CreateTestResponse(CreateTestResponse&& from) noexcept
      : CreateTestResponse(nullptr, std::move(from)) {}
  inline CreateTestResponse& operator=(const CreateTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTestResponse& operator=(CreateTestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTestResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTestResponse*>(
        &_CreateTestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 70;
  friend void swap(CreateTestResponse& a, CreateTestResponse& b) { a.Swap(&b); }
  inline void Swap(CreateTestResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTestResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateTestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTestResponse& from) { CreateTestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateTestResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.CreateTestResponse"; }

 protected:
  explicit CreateTestResponse(::google::protobuf::Arena* arena);
  CreateTestResponse(::google::protobuf::Arena* arena, const CreateTestResponse& from);
  CreateTestResponse(::google::protobuf::Arena* arena, CreateTestResponse&& from) noexcept
      : CreateTestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestFieldNumber = 1,
  };
  // .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
  bool has_test() const;
  void clear_test() ;
  const ::kentik::synthetics::v202101beta1::Test& test() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Test* release_test();
  ::kentik::synthetics::v202101beta1::Test* mutable_test();
  void set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  void unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  ::kentik::synthetics::v202101beta1::Test* unsafe_arena_release_test();

  private:
  const ::kentik::synthetics::v202101beta1::Test& _internal_test() const;
  ::kentik::synthetics::v202101beta1::Test* _internal_mutable_test();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.CreateTestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Test* test_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class CreateTestRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.CreateTestRequest) */ {
 public:
  inline CreateTestRequest() : CreateTestRequest(nullptr) {}
  ~CreateTestRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateTestRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateTestRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateTestRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateTestRequest(const CreateTestRequest& from) : CreateTestRequest(nullptr, from) {}
  inline CreateTestRequest(CreateTestRequest&& from) noexcept
      : CreateTestRequest(nullptr, std::move(from)) {}
  inline CreateTestRequest& operator=(const CreateTestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTestRequest& operator=(CreateTestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTestRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTestRequest*>(
        &_CreateTestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 69;
  friend void swap(CreateTestRequest& a, CreateTestRequest& b) { a.Swap(&b); }
  inline void Swap(CreateTestRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTestRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateTestRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateTestRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateTestRequest& from) { CreateTestRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateTestRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.CreateTestRequest"; }

 protected:
  explicit CreateTestRequest(::google::protobuf::Arena* arena);
  CreateTestRequest(::google::protobuf::Arena* arena, const CreateTestRequest& from);
  CreateTestRequest(::google::protobuf::Arena* arena, CreateTestRequest&& from) noexcept
      : CreateTestRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTestFieldNumber = 1,
  };
  // .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
  bool has_test() const;
  void clear_test() ;
  const ::kentik::synthetics::v202101beta1::Test& test() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Test* release_test();
  ::kentik::synthetics::v202101beta1::Test* mutable_test();
  void set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  void unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value);
  ::kentik::synthetics::v202101beta1::Test* unsafe_arena_release_test();

  private:
  const ::kentik::synthetics::v202101beta1::Test& _internal_test() const;
  ::kentik::synthetics::v202101beta1::Test* _internal_mutable_test();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.CreateTestRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateTestRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::synthetics::v202101beta1::Test* test_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class TestHealth final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.TestHealth) */ {
 public:
  inline TestHealth() : TestHealth(nullptr) {}
  ~TestHealth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TestHealth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TestHealth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TestHealth(
      ::google::protobuf::internal::ConstantInitialized);

  inline TestHealth(const TestHealth& from) : TestHealth(nullptr, from) {}
  inline TestHealth(TestHealth&& from) noexcept
      : TestHealth(nullptr, std::move(from)) {}
  inline TestHealth& operator=(const TestHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestHealth& operator=(TestHealth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestHealth* internal_default_instance() {
    return reinterpret_cast<const TestHealth*>(
        &_TestHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TestHealth& a, TestHealth& b) { a.Swap(&b); }
  inline void Swap(TestHealth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestHealth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestHealth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TestHealth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestHealth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TestHealth& from) { TestHealth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TestHealth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.TestHealth"; }

 protected:
  explicit TestHealth(::google::protobuf::Arena* arena);
  TestHealth(::google::protobuf::Arena* arena, const TestHealth& from);
  TestHealth(::google::protobuf::Arena* arena, TestHealth&& from) noexcept
      : TestHealth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTasksFieldNumber = 2,
    kHealthTsFieldNumber = 4,
    kAgentTaskConfigFieldNumber = 5,
    kMeshFieldNumber = 6,
    kTestIdFieldNumber = 1,
    kOverallHealthFieldNumber = 3,
  };
  // repeated .kentik.synthetics.v202101beta1.TaskHealth tasks = 2 [json_name = "tasks"];
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::kentik::synthetics::v202101beta1::TaskHealth* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>* _internal_mutable_tasks();
  public:
  const ::kentik::synthetics::v202101beta1::TaskHealth& tasks(int index) const;
  ::kentik::synthetics::v202101beta1::TaskHealth* add_tasks();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>& tasks() const;
  // repeated .kentik.synthetics.v202101beta1.Health health_ts = 4 [json_name = "healthTs"];
  int health_ts_size() const;
  private:
  int _internal_health_ts_size() const;

  public:
  void clear_health_ts() ;
  ::kentik::synthetics::v202101beta1::Health* mutable_health_ts(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>* mutable_health_ts();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>& _internal_health_ts() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>* _internal_mutable_health_ts();
  public:
  const ::kentik::synthetics::v202101beta1::Health& health_ts(int index) const;
  ::kentik::synthetics::v202101beta1::Health* add_health_ts();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>& health_ts() const;
  // repeated .kentik.synthetics.v202101beta1.AgentTaskConfig agent_task_config = 5 [json_name = "agentTaskConfig"];
  int agent_task_config_size() const;
  private:
  int _internal_agent_task_config_size() const;

  public:
  void clear_agent_task_config() ;
  ::kentik::synthetics::v202101beta1::AgentTaskConfig* mutable_agent_task_config(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>* mutable_agent_task_config();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>& _internal_agent_task_config() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>* _internal_mutable_agent_task_config();
  public:
  const ::kentik::synthetics::v202101beta1::AgentTaskConfig& agent_task_config(int index) const;
  ::kentik::synthetics::v202101beta1::AgentTaskConfig* add_agent_task_config();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>& agent_task_config() const;
  // repeated .kentik.synthetics.v202101beta1.MeshResponse mesh = 6 [json_name = "mesh"];
  int mesh_size() const;
  private:
  int _internal_mesh_size() const;

  public:
  void clear_mesh() ;
  ::kentik::synthetics::v202101beta1::MeshResponse* mutable_mesh(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>* mutable_mesh();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>& _internal_mesh() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>* _internal_mutable_mesh();
  public:
  const ::kentik::synthetics::v202101beta1::MeshResponse& mesh(int index) const;
  ::kentik::synthetics::v202101beta1::MeshResponse* add_mesh();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>& mesh() const;
  // string test_id = 1 [json_name = "testId"];
  void clear_test_id() ;
  const std::string& test_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_test_id(Arg_&& arg, Args_... args);
  std::string* mutable_test_id();
  PROTOBUF_NODISCARD std::string* release_test_id();
  void set_allocated_test_id(std::string* value);

  private:
  const std::string& _internal_test_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test_id(
      const std::string& value);
  std::string* _internal_mutable_test_id();

  public:
  // .kentik.synthetics.v202101beta1.Health overall_health = 3 [json_name = "overallHealth"];
  bool has_overall_health() const;
  void clear_overall_health() ;
  const ::kentik::synthetics::v202101beta1::Health& overall_health() const;
  PROTOBUF_NODISCARD ::kentik::synthetics::v202101beta1::Health* release_overall_health();
  ::kentik::synthetics::v202101beta1::Health* mutable_overall_health();
  void set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  void unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value);
  ::kentik::synthetics::v202101beta1::Health* unsafe_arena_release_overall_health();

  private:
  const ::kentik::synthetics::v202101beta1::Health& _internal_overall_health() const;
  ::kentik::synthetics::v202101beta1::Health* _internal_mutable_overall_health();

  public:
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.TestHealth)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TestHealth& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::TaskHealth > tasks_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::Health > health_ts_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::AgentTaskConfig > agent_task_config_;
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::MeshResponse > mesh_;
    ::google::protobuf::internal::ArenaStringPtr test_id_;
    ::kentik::synthetics::v202101beta1::Health* overall_health_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};
// -------------------------------------------------------------------

class GetHealthForTestsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.synthetics.v202101beta1.GetHealthForTestsResponse) */ {
 public:
  inline GetHealthForTestsResponse() : GetHealthForTestsResponse(nullptr) {}
  ~GetHealthForTestsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetHealthForTestsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetHealthForTestsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHealthForTestsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHealthForTestsResponse(const GetHealthForTestsResponse& from) : GetHealthForTestsResponse(nullptr, from) {}
  inline GetHealthForTestsResponse(GetHealthForTestsResponse&& from) noexcept
      : GetHealthForTestsResponse(nullptr, std::move(from)) {}
  inline GetHealthForTestsResponse& operator=(const GetHealthForTestsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHealthForTestsResponse& operator=(GetHealthForTestsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHealthForTestsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHealthForTestsResponse* internal_default_instance() {
    return reinterpret_cast<const GetHealthForTestsResponse*>(
        &_GetHealthForTestsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(GetHealthForTestsResponse& a, GetHealthForTestsResponse& b) { a.Swap(&b); }
  inline void Swap(GetHealthForTestsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHealthForTestsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHealthForTestsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetHealthForTestsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetHealthForTestsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetHealthForTestsResponse& from) { GetHealthForTestsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetHealthForTestsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.synthetics.v202101beta1.GetHealthForTestsResponse"; }

 protected:
  explicit GetHealthForTestsResponse(::google::protobuf::Arena* arena);
  GetHealthForTestsResponse(::google::protobuf::Arena* arena, const GetHealthForTestsResponse& from);
  GetHealthForTestsResponse(::google::protobuf::Arena* arena, GetHealthForTestsResponse&& from) noexcept
      : GetHealthForTestsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHealthFieldNumber = 1,
  };
  // repeated .kentik.synthetics.v202101beta1.TestHealth health = 1 [json_name = "health"];
  int health_size() const;
  private:
  int _internal_health_size() const;

  public:
  void clear_health() ;
  ::kentik::synthetics::v202101beta1::TestHealth* mutable_health(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>* mutable_health();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>& _internal_health() const;
  ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>* _internal_mutable_health();
  public:
  const ::kentik::synthetics::v202101beta1::TestHealth& health(int index) const;
  ::kentik::synthetics::v202101beta1::TestHealth* add_health();
  const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>& health() const;
  // @@protoc_insertion_point(class_scope:kentik.synthetics.v202101beta1.GetHealthForTestsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHealthForTestsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::synthetics::v202101beta1::TestHealth > health_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Health

// string health = 1 [json_name = "health"];
inline void Health::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.ClearToEmpty();
}
inline const std::string& Health::health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Health.health)
  return _internal_health();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Health::set_health(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Health.health)
}
inline std::string* Health::mutable_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Health.health)
  return _s;
}
inline const std::string& Health::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_.Get();
}
inline void Health::_internal_set_health(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Set(value, GetArena());
}
inline std::string* Health::_internal_mutable_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.health_.Mutable( GetArena());
}
inline std::string* Health::release_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Health.health)
  return _impl_.health_.Release();
}
inline void Health::set_allocated_health(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.health_.IsDefault()) {
    _impl_.health_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Health.health)
}

// .google.protobuf.Timestamp time = 2 [json_name = "time"];
inline bool Health::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Health::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Health::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Health.time)
  return _internal_time();
}
inline void Health::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Health.time)
}
inline ::google::protobuf::Timestamp* Health::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Health::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Health.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Health::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* Health::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Health.time)
  return _msg;
}
inline void Health::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Health.time)
}

// -------------------------------------------------------------------

// AgentTaskConfig

// uint64 id = 1 [json_name = "id"];
inline void AgentTaskConfig::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t AgentTaskConfig::id() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.AgentTaskConfig.id)
  return _internal_id();
}
inline void AgentTaskConfig::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.AgentTaskConfig.id)
}
inline ::uint64_t AgentTaskConfig::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void AgentTaskConfig::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// repeated string targets = 2 [json_name = "targets"];
inline int AgentTaskConfig::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int AgentTaskConfig::targets_size() const {
  return _internal_targets_size();
}
inline void AgentTaskConfig::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline std::string* AgentTaskConfig::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
  return _s;
}
inline const std::string& AgentTaskConfig::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
  return _internal_targets().Get(index);
}
inline std::string* AgentTaskConfig::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
  return _internal_mutable_targets()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AgentTaskConfig::set_targets(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_targets()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
}
template <typename Arg_, typename... Args_>
inline void AgentTaskConfig::add_targets(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_targets(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AgentTaskConfig::targets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
  return _internal_targets();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AgentTaskConfig::mutable_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.AgentTaskConfig.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AgentTaskConfig::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AgentTaskConfig::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// TestHealth

// string test_id = 1 [json_name = "testId"];
inline void TestHealth::clear_test_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.ClearToEmpty();
}
inline const std::string& TestHealth::test_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestHealth.test_id)
  return _internal_test_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestHealth::set_test_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestHealth.test_id)
}
inline std::string* TestHealth::mutable_test_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_test_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestHealth.test_id)
  return _s;
}
inline const std::string& TestHealth::_internal_test_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.test_id_.Get();
}
inline void TestHealth::_internal_set_test_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.Set(value, GetArena());
}
inline std::string* TestHealth::_internal_mutable_test_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.test_id_.Mutable( GetArena());
}
inline std::string* TestHealth::release_test_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestHealth.test_id)
  return _impl_.test_id_.Release();
}
inline void TestHealth::set_allocated_test_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.test_id_.IsDefault()) {
    _impl_.test_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestHealth.test_id)
}

// repeated .kentik.synthetics.v202101beta1.TaskHealth tasks = 2 [json_name = "tasks"];
inline int TestHealth::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int TestHealth::tasks_size() const {
  return _internal_tasks_size();
}
inline void TestHealth::clear_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tasks_.Clear();
}
inline ::kentik::synthetics::v202101beta1::TaskHealth* TestHealth::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestHealth.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>* TestHealth::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestHealth.tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tasks();
}
inline const ::kentik::synthetics::v202101beta1::TaskHealth& TestHealth::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestHealth.tasks)
  return _internal_tasks().Get(index);
}
inline ::kentik::synthetics::v202101beta1::TaskHealth* TestHealth::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::TaskHealth* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestHealth.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>& TestHealth::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestHealth.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>&
TestHealth::_internal_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TaskHealth>*
TestHealth::_internal_mutable_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tasks_;
}

// .kentik.synthetics.v202101beta1.Health overall_health = 3 [json_name = "overallHealth"];
inline bool TestHealth::has_overall_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overall_health_ != nullptr);
  return value;
}
inline void TestHealth::clear_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ != nullptr) _impl_.overall_health_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Health& TestHealth::_internal_overall_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Health* p = _impl_.overall_health_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Health&>(::kentik::synthetics::v202101beta1::_Health_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Health& TestHealth::overall_health() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestHealth.overall_health)
  return _internal_overall_health();
}
inline void TestHealth::unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.overall_health_);
  }
  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestHealth.overall_health)
}
inline ::kentik::synthetics::v202101beta1::Health* TestHealth::release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Health* released = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Health* TestHealth::unsafe_arena_release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestHealth.overall_health)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Health* temp = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Health* TestHealth::_internal_mutable_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Health>(GetArena());
    _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(p);
  }
  return _impl_.overall_health_;
}
inline ::kentik::synthetics::v202101beta1::Health* TestHealth::mutable_overall_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Health* _msg = _internal_mutable_overall_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestHealth.overall_health)
  return _msg;
}
inline void TestHealth::set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.overall_health_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestHealth.overall_health)
}

// repeated .kentik.synthetics.v202101beta1.Health health_ts = 4 [json_name = "healthTs"];
inline int TestHealth::_internal_health_ts_size() const {
  return _internal_health_ts().size();
}
inline int TestHealth::health_ts_size() const {
  return _internal_health_ts_size();
}
inline void TestHealth::clear_health_ts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ts_.Clear();
}
inline ::kentik::synthetics::v202101beta1::Health* TestHealth::mutable_health_ts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestHealth.health_ts)
  return _internal_mutable_health_ts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>* TestHealth::mutable_health_ts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestHealth.health_ts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_health_ts();
}
inline const ::kentik::synthetics::v202101beta1::Health& TestHealth::health_ts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestHealth.health_ts)
  return _internal_health_ts().Get(index);
}
inline ::kentik::synthetics::v202101beta1::Health* TestHealth::add_health_ts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::Health* _add = _internal_mutable_health_ts()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestHealth.health_ts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>& TestHealth::health_ts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestHealth.health_ts)
  return _internal_health_ts();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>&
TestHealth::_internal_health_ts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_ts_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Health>*
TestHealth::_internal_mutable_health_ts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.health_ts_;
}

// repeated .kentik.synthetics.v202101beta1.AgentTaskConfig agent_task_config = 5 [json_name = "agentTaskConfig"];
inline int TestHealth::_internal_agent_task_config_size() const {
  return _internal_agent_task_config().size();
}
inline int TestHealth::agent_task_config_size() const {
  return _internal_agent_task_config_size();
}
inline void TestHealth::clear_agent_task_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_task_config_.Clear();
}
inline ::kentik::synthetics::v202101beta1::AgentTaskConfig* TestHealth::mutable_agent_task_config(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestHealth.agent_task_config)
  return _internal_mutable_agent_task_config()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>* TestHealth::mutable_agent_task_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestHealth.agent_task_config)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agent_task_config();
}
inline const ::kentik::synthetics::v202101beta1::AgentTaskConfig& TestHealth::agent_task_config(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestHealth.agent_task_config)
  return _internal_agent_task_config().Get(index);
}
inline ::kentik::synthetics::v202101beta1::AgentTaskConfig* TestHealth::add_agent_task_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::AgentTaskConfig* _add = _internal_mutable_agent_task_config()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestHealth.agent_task_config)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>& TestHealth::agent_task_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestHealth.agent_task_config)
  return _internal_agent_task_config();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>&
TestHealth::_internal_agent_task_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_task_config_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentTaskConfig>*
TestHealth::_internal_mutable_agent_task_config() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agent_task_config_;
}

// repeated .kentik.synthetics.v202101beta1.MeshResponse mesh = 6 [json_name = "mesh"];
inline int TestHealth::_internal_mesh_size() const {
  return _internal_mesh().size();
}
inline int TestHealth::mesh_size() const {
  return _internal_mesh_size();
}
inline void TestHealth::clear_mesh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mesh_.Clear();
}
inline ::kentik::synthetics::v202101beta1::MeshResponse* TestHealth::mutable_mesh(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestHealth.mesh)
  return _internal_mutable_mesh()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>* TestHealth::mutable_mesh()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestHealth.mesh)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_mesh();
}
inline const ::kentik::synthetics::v202101beta1::MeshResponse& TestHealth::mesh(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestHealth.mesh)
  return _internal_mesh().Get(index);
}
inline ::kentik::synthetics::v202101beta1::MeshResponse* TestHealth::add_mesh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::MeshResponse* _add = _internal_mutable_mesh()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestHealth.mesh)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>& TestHealth::mesh() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestHealth.mesh)
  return _internal_mesh();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>&
TestHealth::_internal_mesh() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mesh_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshResponse>*
TestHealth::_internal_mutable_mesh() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.mesh_;
}

// -------------------------------------------------------------------

// TaskHealth

// .kentik.synthetics.v202101beta1.Task task = 1 [json_name = "task"];
inline bool TaskHealth::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline void TaskHealth::clear_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ != nullptr) _impl_.task_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Task& TaskHealth::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Task&>(::kentik::synthetics::v202101beta1::_Task_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Task& TaskHealth::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TaskHealth.task)
  return _internal_task();
}
inline void TaskHealth::unsafe_arena_set_allocated_task(::kentik::synthetics::v202101beta1::Task* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Task*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TaskHealth.task)
}
inline ::kentik::synthetics::v202101beta1::Task* TaskHealth::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Task* released = _impl_.task_;
  _impl_.task_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Task* TaskHealth::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TaskHealth.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Task* TaskHealth::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Task>(GetArena());
    _impl_.task_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Task*>(p);
  }
  return _impl_.task_;
}
inline ::kentik::synthetics::v202101beta1::Task* TaskHealth::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TaskHealth.task)
  return _msg;
}
inline void TaskHealth::set_allocated_task(::kentik::synthetics::v202101beta1::Task* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Task*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TaskHealth.task)
}

// repeated .kentik.synthetics.v202101beta1.AgentHealth agents = 2 [json_name = "agents"];
inline int TaskHealth::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int TaskHealth::agents_size() const {
  return _internal_agents_size();
}
inline void TaskHealth::clear_agents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agents_.Clear();
}
inline ::kentik::synthetics::v202101beta1::AgentHealth* TaskHealth::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TaskHealth.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>* TaskHealth::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TaskHealth.agents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agents();
}
inline const ::kentik::synthetics::v202101beta1::AgentHealth& TaskHealth::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TaskHealth.agents)
  return _internal_agents().Get(index);
}
inline ::kentik::synthetics::v202101beta1::AgentHealth* TaskHealth::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::AgentHealth* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TaskHealth.agents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>& TaskHealth::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TaskHealth.agents)
  return _internal_agents();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>&
TaskHealth::_internal_agents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agents_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::AgentHealth>*
TaskHealth::_internal_mutable_agents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agents_;
}

// .kentik.synthetics.v202101beta1.Health overall_health = 3 [json_name = "overallHealth"];
inline bool TaskHealth::has_overall_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overall_health_ != nullptr);
  return value;
}
inline void TaskHealth::clear_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ != nullptr) _impl_.overall_health_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::Health& TaskHealth::_internal_overall_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Health* p = _impl_.overall_health_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Health&>(::kentik::synthetics::v202101beta1::_Health_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Health& TaskHealth::overall_health() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TaskHealth.overall_health)
  return _internal_overall_health();
}
inline void TaskHealth::unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.overall_health_);
  }
  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TaskHealth.overall_health)
}
inline ::kentik::synthetics::v202101beta1::Health* TaskHealth::release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* released = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Health* TaskHealth::unsafe_arena_release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TaskHealth.overall_health)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* temp = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Health* TaskHealth::_internal_mutable_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Health>(GetArena());
    _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(p);
  }
  return _impl_.overall_health_;
}
inline ::kentik::synthetics::v202101beta1::Health* TaskHealth::mutable_overall_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* _msg = _internal_mutable_overall_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TaskHealth.overall_health)
  return _msg;
}
inline void TaskHealth::set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.overall_health_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TaskHealth.overall_health)
}

// .kentik.synthetics.v202101beta1.Agent target_agent = 4 [json_name = "targetAgent"];
inline bool TaskHealth::has_target_agent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_agent_ != nullptr);
  return value;
}
inline void TaskHealth::clear_target_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_agent_ != nullptr) _impl_.target_agent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::synthetics::v202101beta1::Agent& TaskHealth::_internal_target_agent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Agent* p = _impl_.target_agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Agent&>(::kentik::synthetics::v202101beta1::_Agent_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Agent& TaskHealth::target_agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TaskHealth.target_agent)
  return _internal_target_agent();
}
inline void TaskHealth::unsafe_arena_set_allocated_target_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_agent_);
  }
  _impl_.target_agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TaskHealth.target_agent)
}
inline ::kentik::synthetics::v202101beta1::Agent* TaskHealth::release_target_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::Agent* released = _impl_.target_agent_;
  _impl_.target_agent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Agent* TaskHealth::unsafe_arena_release_target_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TaskHealth.target_agent)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::Agent* temp = _impl_.target_agent_;
  _impl_.target_agent_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Agent* TaskHealth::_internal_mutable_target_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_agent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Agent>(GetArena());
    _impl_.target_agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(p);
  }
  return _impl_.target_agent_;
}
inline ::kentik::synthetics::v202101beta1::Agent* TaskHealth::mutable_target_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::synthetics::v202101beta1::Agent* _msg = _internal_mutable_target_agent();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TaskHealth.target_agent)
  return _msg;
}
inline void TaskHealth::set_allocated_target_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.target_agent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.target_agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TaskHealth.target_agent)
}

// -------------------------------------------------------------------

// AgentHealth

// .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
inline bool AgentHealth::has_agent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.agent_ != nullptr);
  return value;
}
inline void AgentHealth::clear_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ != nullptr) _impl_.agent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Agent& AgentHealth::_internal_agent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Agent* p = _impl_.agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Agent&>(::kentik::synthetics::v202101beta1::_Agent_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Agent& AgentHealth::agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.AgentHealth.agent)
  return _internal_agent();
}
inline void AgentHealth::unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.agent_);
  }
  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.AgentHealth.agent)
}
inline ::kentik::synthetics::v202101beta1::Agent* AgentHealth::release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* released = _impl_.agent_;
  _impl_.agent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Agent* AgentHealth::unsafe_arena_release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.AgentHealth.agent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* temp = _impl_.agent_;
  _impl_.agent_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Agent* AgentHealth::_internal_mutable_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Agent>(GetArena());
    _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(p);
  }
  return _impl_.agent_;
}
inline ::kentik::synthetics::v202101beta1::Agent* AgentHealth::mutable_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* _msg = _internal_mutable_agent();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.AgentHealth.agent)
  return _msg;
}
inline void AgentHealth::set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.agent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.AgentHealth.agent)
}

// repeated .kentik.synthetics.v202101beta1.HealthMoment health = 2 [json_name = "health"];
inline int AgentHealth::_internal_health_size() const {
  return _internal_health().size();
}
inline int AgentHealth::health_size() const {
  return _internal_health_size();
}
inline void AgentHealth::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Clear();
}
inline ::kentik::synthetics::v202101beta1::HealthMoment* AgentHealth::mutable_health(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.AgentHealth.health)
  return _internal_mutable_health()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>* AgentHealth::mutable_health()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.AgentHealth.health)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_health();
}
inline const ::kentik::synthetics::v202101beta1::HealthMoment& AgentHealth::health(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.AgentHealth.health)
  return _internal_health().Get(index);
}
inline ::kentik::synthetics::v202101beta1::HealthMoment* AgentHealth::add_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::HealthMoment* _add = _internal_mutable_health()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.AgentHealth.health)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>& AgentHealth::health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.AgentHealth.health)
  return _internal_health();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>&
AgentHealth::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::HealthMoment>*
AgentHealth::_internal_mutable_health() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.health_;
}

// .kentik.synthetics.v202101beta1.Health overall_health = 3 [json_name = "overallHealth"];
inline bool AgentHealth::has_overall_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overall_health_ != nullptr);
  return value;
}
inline void AgentHealth::clear_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ != nullptr) _impl_.overall_health_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::Health& AgentHealth::_internal_overall_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Health* p = _impl_.overall_health_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Health&>(::kentik::synthetics::v202101beta1::_Health_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Health& AgentHealth::overall_health() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.AgentHealth.overall_health)
  return _internal_overall_health();
}
inline void AgentHealth::unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.overall_health_);
  }
  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.AgentHealth.overall_health)
}
inline ::kentik::synthetics::v202101beta1::Health* AgentHealth::release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* released = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Health* AgentHealth::unsafe_arena_release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.AgentHealth.overall_health)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* temp = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Health* AgentHealth::_internal_mutable_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Health>(GetArena());
    _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(p);
  }
  return _impl_.overall_health_;
}
inline ::kentik::synthetics::v202101beta1::Health* AgentHealth::mutable_overall_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* _msg = _internal_mutable_overall_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.AgentHealth.overall_health)
  return _msg;
}
inline void AgentHealth::set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.overall_health_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.AgentHealth.overall_health)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HealthMoment

// .google.protobuf.Timestamp time = 1 [json_name = "time"];
inline bool HealthMoment::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& HealthMoment::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& HealthMoment::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.time)
  return _internal_time();
}
inline void HealthMoment::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.time)
}
inline ::google::protobuf::Timestamp* HealthMoment::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* HealthMoment::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* HealthMoment::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* HealthMoment::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.time)
  return _msg;
}
inline void HealthMoment::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.time)
}

// string src_ip = 2 [json_name = "srcIp"];
inline void HealthMoment::clear_src_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_ip_.ClearToEmpty();
}
inline const std::string& HealthMoment::src_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.src_ip)
  return _internal_src_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_src_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.src_ip)
}
inline std::string* HealthMoment::mutable_src_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.src_ip)
  return _s;
}
inline const std::string& HealthMoment::_internal_src_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_ip_.Get();
}
inline void HealthMoment::_internal_set_src_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_ip_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_src_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.src_ip_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_src_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.src_ip)
  return _impl_.src_ip_.Release();
}
inline void HealthMoment::set_allocated_src_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.src_ip_.IsDefault()) {
    _impl_.src_ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.src_ip)
}

// string dst_ip = 3 [json_name = "dstIp"];
inline void HealthMoment::clear_dst_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_ip_.ClearToEmpty();
}
inline const std::string& HealthMoment::dst_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.dst_ip)
  return _internal_dst_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_dst_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.dst_ip)
}
inline std::string* HealthMoment::mutable_dst_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dst_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.dst_ip)
  return _s;
}
inline const std::string& HealthMoment::_internal_dst_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dst_ip_.Get();
}
inline void HealthMoment::_internal_set_dst_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_ip_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_dst_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dst_ip_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_dst_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.dst_ip)
  return _impl_.dst_ip_.Release();
}
inline void HealthMoment::set_allocated_dst_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dst_ip_.IsDefault()) {
    _impl_.dst_ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.dst_ip)
}

// double packet_loss = 4 [json_name = "packetLoss"];
inline void HealthMoment::clear_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_ = 0;
}
inline double HealthMoment::packet_loss() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.packet_loss)
  return _internal_packet_loss();
}
inline void HealthMoment::set_packet_loss(double value) {
  _internal_set_packet_loss(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.packet_loss)
}
inline double HealthMoment::_internal_packet_loss() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packet_loss_;
}
inline void HealthMoment::_internal_set_packet_loss(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_ = value;
}

// uint32 avg_latency = 5 [json_name = "avgLatency"];
inline void HealthMoment::clear_avg_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_latency_ = 0u;
}
inline ::uint32_t HealthMoment::avg_latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.avg_latency)
  return _internal_avg_latency();
}
inline void HealthMoment::set_avg_latency(::uint32_t value) {
  _internal_set_avg_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.avg_latency)
}
inline ::uint32_t HealthMoment::_internal_avg_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_latency_;
}
inline void HealthMoment::_internal_set_avg_latency(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_latency_ = value;
}

// uint32 avg_weighted_latency = 6 [json_name = "avgWeightedLatency"];
inline void HealthMoment::clear_avg_weighted_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_weighted_latency_ = 0u;
}
inline ::uint32_t HealthMoment::avg_weighted_latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.avg_weighted_latency)
  return _internal_avg_weighted_latency();
}
inline void HealthMoment::set_avg_weighted_latency(::uint32_t value) {
  _internal_set_avg_weighted_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.avg_weighted_latency)
}
inline ::uint32_t HealthMoment::_internal_avg_weighted_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_weighted_latency_;
}
inline void HealthMoment::_internal_set_avg_weighted_latency(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_weighted_latency_ = value;
}

// uint32 rolling_avg_latency = 7 [json_name = "rollingAvgLatency"];
inline void HealthMoment::clear_rolling_avg_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_avg_latency_ = 0u;
}
inline ::uint32_t HealthMoment::rolling_avg_latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.rolling_avg_latency)
  return _internal_rolling_avg_latency();
}
inline void HealthMoment::set_rolling_avg_latency(::uint32_t value) {
  _internal_set_rolling_avg_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.rolling_avg_latency)
}
inline ::uint32_t HealthMoment::_internal_rolling_avg_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rolling_avg_latency_;
}
inline void HealthMoment::_internal_set_rolling_avg_latency(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_avg_latency_ = value;
}

// uint32 rolling_stddev_latency = 8 [json_name = "rollingStddevLatency"];
inline void HealthMoment::clear_rolling_stddev_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_stddev_latency_ = 0u;
}
inline ::uint32_t HealthMoment::rolling_stddev_latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.rolling_stddev_latency)
  return _internal_rolling_stddev_latency();
}
inline void HealthMoment::set_rolling_stddev_latency(::uint32_t value) {
  _internal_set_rolling_stddev_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.rolling_stddev_latency)
}
inline ::uint32_t HealthMoment::_internal_rolling_stddev_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rolling_stddev_latency_;
}
inline void HealthMoment::_internal_set_rolling_stddev_latency(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_stddev_latency_ = value;
}

// uint32 rolling_avg_weighted_latency = 9 [json_name = "rollingAvgWeightedLatency"];
inline void HealthMoment::clear_rolling_avg_weighted_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_avg_weighted_latency_ = 0u;
}
inline ::uint32_t HealthMoment::rolling_avg_weighted_latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.rolling_avg_weighted_latency)
  return _internal_rolling_avg_weighted_latency();
}
inline void HealthMoment::set_rolling_avg_weighted_latency(::uint32_t value) {
  _internal_set_rolling_avg_weighted_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.rolling_avg_weighted_latency)
}
inline ::uint32_t HealthMoment::_internal_rolling_avg_weighted_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rolling_avg_weighted_latency_;
}
inline void HealthMoment::_internal_set_rolling_avg_weighted_latency(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_avg_weighted_latency_ = value;
}

// string latency_health = 10 [json_name = "latencyHealth"];
inline void HealthMoment::clear_latency_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_health_.ClearToEmpty();
}
inline const std::string& HealthMoment::latency_health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.latency_health)
  return _internal_latency_health();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_latency_health(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_health_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.latency_health)
}
inline std::string* HealthMoment::mutable_latency_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_latency_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.latency_health)
  return _s;
}
inline const std::string& HealthMoment::_internal_latency_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latency_health_.Get();
}
inline void HealthMoment::_internal_set_latency_health(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_health_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_latency_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.latency_health_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_latency_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.latency_health)
  return _impl_.latency_health_.Release();
}
inline void HealthMoment::set_allocated_latency_health(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_health_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.latency_health_.IsDefault()) {
    _impl_.latency_health_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.latency_health)
}

// string packet_loss_health = 11 [json_name = "packetLossHealth"];
inline void HealthMoment::clear_packet_loss_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_health_.ClearToEmpty();
}
inline const std::string& HealthMoment::packet_loss_health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.packet_loss_health)
  return _internal_packet_loss_health();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_packet_loss_health(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_health_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.packet_loss_health)
}
inline std::string* HealthMoment::mutable_packet_loss_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet_loss_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.packet_loss_health)
  return _s;
}
inline const std::string& HealthMoment::_internal_packet_loss_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packet_loss_health_.Get();
}
inline void HealthMoment::_internal_set_packet_loss_health(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_health_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_packet_loss_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.packet_loss_health_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_packet_loss_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.packet_loss_health)
  return _impl_.packet_loss_health_.Release();
}
inline void HealthMoment::set_allocated_packet_loss_health(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_health_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.packet_loss_health_.IsDefault()) {
    _impl_.packet_loss_health_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.packet_loss_health)
}

// .kentik.synthetics.v202101beta1.Health overall_health = 12 [json_name = "overallHealth"];
inline bool HealthMoment::has_overall_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overall_health_ != nullptr);
  return value;
}
inline void HealthMoment::clear_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ != nullptr) _impl_.overall_health_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::Health& HealthMoment::_internal_overall_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Health* p = _impl_.overall_health_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Health&>(::kentik::synthetics::v202101beta1::_Health_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Health& HealthMoment::overall_health() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.overall_health)
  return _internal_overall_health();
}
inline void HealthMoment::unsafe_arena_set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.overall_health_);
  }
  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.overall_health)
}
inline ::kentik::synthetics::v202101beta1::Health* HealthMoment::release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* released = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Health* HealthMoment::unsafe_arena_release_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.overall_health)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* temp = _impl_.overall_health_;
  _impl_.overall_health_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Health* HealthMoment::_internal_mutable_overall_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.overall_health_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Health>(GetArena());
    _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(p);
  }
  return _impl_.overall_health_;
}
inline ::kentik::synthetics::v202101beta1::Health* HealthMoment::mutable_overall_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::Health* _msg = _internal_mutable_overall_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.overall_health)
  return _msg;
}
inline void HealthMoment::set_allocated_overall_health(::kentik::synthetics::v202101beta1::Health* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.overall_health_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.overall_health_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Health*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.overall_health)
}

// uint32 avg_jitter = 13 [json_name = "avgJitter"];
inline void HealthMoment::clear_avg_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_jitter_ = 0u;
}
inline ::uint32_t HealthMoment::avg_jitter() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.avg_jitter)
  return _internal_avg_jitter();
}
inline void HealthMoment::set_avg_jitter(::uint32_t value) {
  _internal_set_avg_jitter(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.avg_jitter)
}
inline ::uint32_t HealthMoment::_internal_avg_jitter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_jitter_;
}
inline void HealthMoment::_internal_set_avg_jitter(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_jitter_ = value;
}

// uint32 rolling_avg_jitter = 14 [json_name = "rollingAvgJitter"];
inline void HealthMoment::clear_rolling_avg_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_avg_jitter_ = 0u;
}
inline ::uint32_t HealthMoment::rolling_avg_jitter() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.rolling_avg_jitter)
  return _internal_rolling_avg_jitter();
}
inline void HealthMoment::set_rolling_avg_jitter(::uint32_t value) {
  _internal_set_rolling_avg_jitter(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.rolling_avg_jitter)
}
inline ::uint32_t HealthMoment::_internal_rolling_avg_jitter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rolling_avg_jitter_;
}
inline void HealthMoment::_internal_set_rolling_avg_jitter(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_avg_jitter_ = value;
}

// uint32 rolling_std_jitter = 15 [json_name = "rollingStdJitter"];
inline void HealthMoment::clear_rolling_std_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_std_jitter_ = 0u;
}
inline ::uint32_t HealthMoment::rolling_std_jitter() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.rolling_std_jitter)
  return _internal_rolling_std_jitter();
}
inline void HealthMoment::set_rolling_std_jitter(::uint32_t value) {
  _internal_set_rolling_std_jitter(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.rolling_std_jitter)
}
inline ::uint32_t HealthMoment::_internal_rolling_std_jitter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rolling_std_jitter_;
}
inline void HealthMoment::_internal_set_rolling_std_jitter(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolling_std_jitter_ = value;
}

// string jitter_health = 16 [json_name = "jitterHealth"];
inline void HealthMoment::clear_jitter_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_health_.ClearToEmpty();
}
inline const std::string& HealthMoment::jitter_health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.jitter_health)
  return _internal_jitter_health();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_jitter_health(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_health_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.jitter_health)
}
inline std::string* HealthMoment::mutable_jitter_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_jitter_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.jitter_health)
  return _s;
}
inline const std::string& HealthMoment::_internal_jitter_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jitter_health_.Get();
}
inline void HealthMoment::_internal_set_jitter_health(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_health_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_jitter_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.jitter_health_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_jitter_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.jitter_health)
  return _impl_.jitter_health_.Release();
}
inline void HealthMoment::set_allocated_jitter_health(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_health_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.jitter_health_.IsDefault()) {
    _impl_.jitter_health_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.jitter_health)
}

// string data = 17 [json_name = "data"];
inline void HealthMoment::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& HealthMoment::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.data)
}
inline std::string* HealthMoment::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.data)
  return _s;
}
inline const std::string& HealthMoment::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void HealthMoment::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.data)
  return _impl_.data_.Release();
}
inline void HealthMoment::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.data)
}

// uint32 size = 18 [json_name = "size"];
inline void HealthMoment::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0u;
}
inline ::uint32_t HealthMoment::size() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.size)
  return _internal_size();
}
inline void HealthMoment::set_size(::uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.size)
}
inline ::uint32_t HealthMoment::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void HealthMoment::_internal_set_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// uint32 status = 19 [json_name = "status"];
inline void HealthMoment::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0u;
}
inline ::uint32_t HealthMoment::status() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.status)
  return _internal_status();
}
inline void HealthMoment::set_status(::uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.status)
}
inline ::uint32_t HealthMoment::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_;
}
inline void HealthMoment::_internal_set_status(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string task_type = 20 [json_name = "taskType"];
inline void HealthMoment::clear_task_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.ClearToEmpty();
}
inline const std::string& HealthMoment::task_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthMoment.task_type)
  return _internal_task_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthMoment::set_task_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthMoment.task_type)
}
inline std::string* HealthMoment::mutable_task_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_type();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HealthMoment.task_type)
  return _s;
}
inline const std::string& HealthMoment::_internal_task_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_type_.Get();
}
inline void HealthMoment::_internal_set_task_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.Set(value, GetArena());
}
inline std::string* HealthMoment::_internal_mutable_task_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_type_.Mutable( GetArena());
}
inline std::string* HealthMoment::release_task_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HealthMoment.task_type)
  return _impl_.task_type_.Release();
}
inline void HealthMoment::set_allocated_task_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_type_.IsDefault()) {
    _impl_.task_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HealthMoment.task_type)
}

// map<string, string> other_healths = 21 [json_name = "otherHealths"];
inline int HealthMoment::_internal_other_healths_size() const {
  return _internal_other_healths().size();
}
inline int HealthMoment::other_healths_size() const {
  return _internal_other_healths_size();
}
inline void HealthMoment::clear_other_healths() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_healths_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HealthMoment::_internal_other_healths() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_healths_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HealthMoment::other_healths() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:kentik.synthetics.v202101beta1.HealthMoment.other_healths)
  return _internal_other_healths();
}
inline ::google::protobuf::Map<std::string, std::string>* HealthMoment::_internal_mutable_other_healths() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.other_healths_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HealthMoment::mutable_other_healths() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:kentik.synthetics.v202101beta1.HealthMoment.other_healths)
  return _internal_mutable_other_healths();
}

// -------------------------------------------------------------------

// Agent

// string id = 1 [json_name = "id"];
inline void Agent::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Agent::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.id)
}
inline std::string* Agent::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.id)
  return _s;
}
inline const std::string& Agent::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Agent::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Agent::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.id)
  return _impl_.id_.Release();
}
inline void Agent::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.id)
}

// string name = 2 [json_name = "name"];
inline void Agent::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Agent::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.name)
}
inline std::string* Agent::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.name)
  return _s;
}
inline const std::string& Agent::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Agent::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Agent::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.name)
  return _impl_.name_.Release();
}
inline void Agent::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.name)
}

// .kentik.synthetics.v202101beta1.AgentStatus status = 3 [json_name = "status"];
inline void Agent::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::kentik::synthetics::v202101beta1::AgentStatus Agent::status() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.status)
  return _internal_status();
}
inline void Agent::set_status(::kentik::synthetics::v202101beta1::AgentStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.status)
}
inline ::kentik::synthetics::v202101beta1::AgentStatus Agent::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::AgentStatus>(_impl_.status_);
}
inline void Agent::_internal_set_status(::kentik::synthetics::v202101beta1::AgentStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string alias = 4 [json_name = "alias"];
inline void Agent::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& Agent::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.alias)
}
inline std::string* Agent::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.alias)
  return _s;
}
inline const std::string& Agent::_internal_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_.Get();
}
inline void Agent::_internal_set_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* Agent::release_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.alias)
  return _impl_.alias_.Release();
}
inline void Agent::set_allocated_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.alias)
}

// string type = 5 [json_name = "type"];
inline void Agent::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Agent::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.type)
}
inline std::string* Agent::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.type)
  return _s;
}
inline const std::string& Agent::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Agent::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Agent::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.type)
  return _impl_.type_.Release();
}
inline void Agent::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.type)
}

// string os = 6 [json_name = "os"];
inline void Agent::clear_os() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.os_.ClearToEmpty();
}
inline const std::string& Agent::os() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.os)
  return _internal_os();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_os(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.os_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.os)
}
inline std::string* Agent::mutable_os() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.os)
  return _s;
}
inline const std::string& Agent::_internal_os() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.os_.Get();
}
inline void Agent::_internal_set_os(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.os_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_os() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.os_.Mutable( GetArena());
}
inline std::string* Agent::release_os() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.os)
  return _impl_.os_.Release();
}
inline void Agent::set_allocated_os(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.os_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.os)
}

// string ip = 7 [json_name = "ip"];
inline void Agent::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Agent::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.ip)
}
inline std::string* Agent::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.ip)
  return _s;
}
inline const std::string& Agent::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_.Get();
}
inline void Agent::_internal_set_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* Agent::release_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.ip)
  return _impl_.ip_.Release();
}
inline void Agent::set_allocated_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.ip)
}

// double lat = 8 [json_name = "lat"];
inline void Agent::clear_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = 0;
}
inline double Agent::lat() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.lat)
  return _internal_lat();
}
inline void Agent::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.lat)
}
inline double Agent::_internal_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lat_;
}
inline void Agent::_internal_set_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = value;
}

// double long = 9 [json_name = "long"];
inline void Agent::clear_long_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long__ = 0;
}
inline double Agent::long_() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.long)
  return _internal_long_();
}
inline void Agent::set_long_(double value) {
  _internal_set_long_(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.long)
}
inline double Agent::_internal_long_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.long__;
}
inline void Agent::_internal_set_long_(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long__ = value;
}

// .google.protobuf.Timestamp last_authed = 10 [json_name = "lastAuthed"];
inline bool Agent::has_last_authed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_authed_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Agent::_internal_last_authed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.last_authed_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Agent::last_authed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.last_authed)
  return _internal_last_authed();
}
inline void Agent::unsafe_arena_set_allocated_last_authed(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_authed_);
  }
  _impl_.last_authed_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Agent.last_authed)
}
inline ::google::protobuf::Timestamp* Agent::release_last_authed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.last_authed_;
  _impl_.last_authed_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Agent::unsafe_arena_release_last_authed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.last_authed)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.last_authed_;
  _impl_.last_authed_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Agent::_internal_mutable_last_authed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_authed_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_authed_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_authed_;
}
inline ::google::protobuf::Timestamp* Agent::mutable_last_authed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_authed();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.last_authed)
  return _msg;
}
inline void Agent::set_allocated_last_authed(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_authed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.last_authed_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.last_authed)
}

// .kentik.synthetics.v202101beta1.IPFamily family = 11 [json_name = "family"];
inline void Agent::clear_family() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.family_ = 0;
}
inline ::kentik::synthetics::v202101beta1::IPFamily Agent::family() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.family)
  return _internal_family();
}
inline void Agent::set_family(::kentik::synthetics::v202101beta1::IPFamily value) {
  _internal_set_family(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.family)
}
inline ::kentik::synthetics::v202101beta1::IPFamily Agent::_internal_family() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::IPFamily>(_impl_.family_);
}
inline void Agent::_internal_set_family(::kentik::synthetics::v202101beta1::IPFamily value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.family_ = value;
}

// uint32 asn = 12 [json_name = "asn"];
inline void Agent::clear_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = 0u;
}
inline ::uint32_t Agent::asn() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.asn)
  return _internal_asn();
}
inline void Agent::set_asn(::uint32_t value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.asn)
}
inline ::uint32_t Agent::_internal_asn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn_;
}
inline void Agent::_internal_set_asn(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = value;
}

// string site_id = 13 [json_name = "siteId"];
inline void Agent::clear_site_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.ClearToEmpty();
}
inline const std::string& Agent::site_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.site_id)
  return _internal_site_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_site_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.site_id)
}
inline std::string* Agent::mutable_site_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_site_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.site_id)
  return _s;
}
inline const std::string& Agent::_internal_site_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.site_id_.Get();
}
inline void Agent::_internal_set_site_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_site_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.site_id_.Mutable( GetArena());
}
inline std::string* Agent::release_site_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.site_id)
  return _impl_.site_id_.Release();
}
inline void Agent::set_allocated_site_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.site_id_.IsDefault()) {
    _impl_.site_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.site_id)
}

// string version = 14 [json_name = "version"];
inline void Agent::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Agent::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.version)
}
inline std::string* Agent::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.version)
  return _s;
}
inline const std::string& Agent::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void Agent::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* Agent::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.version)
  return _impl_.version_.Release();
}
inline void Agent::set_allocated_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.version)
}

// string challenge = 15 [json_name = "challenge"];
inline void Agent::clear_challenge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_.ClearToEmpty();
}
inline const std::string& Agent::challenge() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.challenge)
  return _internal_challenge();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_challenge(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.challenge)
}
inline std::string* Agent::mutable_challenge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_challenge();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.challenge)
  return _s;
}
inline const std::string& Agent::_internal_challenge() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.challenge_.Get();
}
inline void Agent::_internal_set_challenge(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_challenge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.challenge_.Mutable( GetArena());
}
inline std::string* Agent::release_challenge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.challenge)
  return _impl_.challenge_.Release();
}
inline void Agent::set_allocated_challenge(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.challenge_.IsDefault()) {
    _impl_.challenge_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.challenge)
}

// string city = 16 [json_name = "city"];
inline void Agent::clear_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.ClearToEmpty();
}
inline const std::string& Agent::city() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.city)
  return _internal_city();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_city(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.city)
}
inline std::string* Agent::mutable_city() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.city)
  return _s;
}
inline const std::string& Agent::_internal_city() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.city_.Get();
}
inline void Agent::_internal_set_city(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.city_.Mutable( GetArena());
}
inline std::string* Agent::release_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.city)
  return _impl_.city_.Release();
}
inline void Agent::set_allocated_city(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.city_.IsDefault()) {
    _impl_.city_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.city)
}

// string region = 17 [json_name = "region"];
inline void Agent::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.ClearToEmpty();
}
inline const std::string& Agent::region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.region)
  return _internal_region();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_region(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.region)
}
inline std::string* Agent::mutable_region() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.region)
  return _s;
}
inline const std::string& Agent::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_.Get();
}
inline void Agent::_internal_set_region(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.region_.Mutable( GetArena());
}
inline std::string* Agent::release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.region)
  return _impl_.region_.Release();
}
inline void Agent::set_allocated_region(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.region)
}

// string country = 18 [json_name = "country"];
inline void Agent::clear_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.ClearToEmpty();
}
inline const std::string& Agent::country() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.country)
  return _internal_country();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_country(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.country)
}
inline std::string* Agent::mutable_country() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.country)
  return _s;
}
inline const std::string& Agent::_internal_country() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.country_.Get();
}
inline void Agent::_internal_set_country(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.country_.Mutable( GetArena());
}
inline std::string* Agent::release_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.country)
  return _impl_.country_.Release();
}
inline void Agent::set_allocated_country(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.country)
}

// repeated string test_ids = 19 [json_name = "testIds"];
inline int Agent::_internal_test_ids_size() const {
  return _internal_test_ids().size();
}
inline int Agent::test_ids_size() const {
  return _internal_test_ids_size();
}
inline void Agent::clear_test_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_ids_.Clear();
}
inline std::string* Agent::add_test_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_test_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.Agent.test_ids)
  return _s;
}
inline const std::string& Agent::test_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.test_ids)
  return _internal_test_ids().Get(index);
}
inline std::string* Agent::mutable_test_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.test_ids)
  return _internal_mutable_test_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Agent::set_test_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_test_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.test_ids)
}
template <typename Arg_, typename... Args_>
inline void Agent::add_test_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_test_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.Agent.test_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Agent::test_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.Agent.test_ids)
  return _internal_test_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Agent::mutable_test_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.Agent.test_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_test_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Agent::_internal_test_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.test_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Agent::_internal_mutable_test_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.test_ids_;
}

// string local_ip = 20 [json_name = "localIp"];
inline void Agent::clear_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.ClearToEmpty();
}
inline const std::string& Agent::local_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.local_ip)
  return _internal_local_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_local_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.local_ip)
}
inline std::string* Agent::mutable_local_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.local_ip)
  return _s;
}
inline const std::string& Agent::_internal_local_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_ip_.Get();
}
inline void Agent::_internal_set_local_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_ip_.Mutable( GetArena());
}
inline std::string* Agent::release_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.local_ip)
  return _impl_.local_ip_.Release();
}
inline void Agent::set_allocated_local_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.local_ip_.IsDefault()) {
    _impl_.local_ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.local_ip)
}

// string cloud_vpc = 21 [json_name = "cloudVpc"];
inline void Agent::clear_cloud_vpc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cloud_vpc_.ClearToEmpty();
}
inline const std::string& Agent::cloud_vpc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.cloud_vpc)
  return _internal_cloud_vpc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_cloud_vpc(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cloud_vpc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.cloud_vpc)
}
inline std::string* Agent::mutable_cloud_vpc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cloud_vpc();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Agent.cloud_vpc)
  return _s;
}
inline const std::string& Agent::_internal_cloud_vpc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cloud_vpc_.Get();
}
inline void Agent::_internal_set_cloud_vpc(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cloud_vpc_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_cloud_vpc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cloud_vpc_.Mutable( GetArena());
}
inline std::string* Agent::release_cloud_vpc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Agent.cloud_vpc)
  return _impl_.cloud_vpc_.Release();
}
inline void Agent::set_allocated_cloud_vpc(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cloud_vpc_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cloud_vpc_.IsDefault()) {
    _impl_.cloud_vpc_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Agent.cloud_vpc)
}

// .kentik.synthetics.v202101beta1.ImplementType agent_impl = 22 [json_name = "agentImpl"];
inline void Agent::clear_agent_impl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_impl_ = 0;
}
inline ::kentik::synthetics::v202101beta1::ImplementType Agent::agent_impl() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Agent.agent_impl)
  return _internal_agent_impl();
}
inline void Agent::set_agent_impl(::kentik::synthetics::v202101beta1::ImplementType value) {
  _internal_set_agent_impl(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Agent.agent_impl)
}
inline ::kentik::synthetics::v202101beta1::ImplementType Agent::_internal_agent_impl() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::ImplementType>(_impl_.agent_impl_);
}
inline void Agent::_internal_set_agent_impl(::kentik::synthetics::v202101beta1::ImplementType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_impl_ = value;
}

// -------------------------------------------------------------------

// PingTaskDefinition

// string target = 1 [json_name = "target"];
inline void PingTaskDefinition::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& PingTaskDefinition::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PingTaskDefinition.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingTaskDefinition::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.PingTaskDefinition.target)
}
inline std::string* PingTaskDefinition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PingTaskDefinition.target)
  return _s;
}
inline const std::string& PingTaskDefinition::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void PingTaskDefinition::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* PingTaskDefinition::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* PingTaskDefinition::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PingTaskDefinition.target)
  return _impl_.target_.Release();
}
inline void PingTaskDefinition::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PingTaskDefinition.target)
}

// uint32 period = 2 [json_name = "period"];
inline void PingTaskDefinition::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t PingTaskDefinition::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PingTaskDefinition.period)
  return _internal_period();
}
inline void PingTaskDefinition::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.PingTaskDefinition.period)
}
inline ::uint32_t PingTaskDefinition::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void PingTaskDefinition::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 3 [json_name = "expiry"];
inline void PingTaskDefinition::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t PingTaskDefinition::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PingTaskDefinition.expiry)
  return _internal_expiry();
}
inline void PingTaskDefinition::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.PingTaskDefinition.expiry)
}
inline ::uint32_t PingTaskDefinition::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void PingTaskDefinition::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// uint32 count = 4 [json_name = "count"];
inline void PingTaskDefinition::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t PingTaskDefinition::count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PingTaskDefinition.count)
  return _internal_count();
}
inline void PingTaskDefinition::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.PingTaskDefinition.count)
}
inline ::uint32_t PingTaskDefinition::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void PingTaskDefinition::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TraceTaskDefinition

// string target = 1 [json_name = "target"];
inline void TraceTaskDefinition::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& TraceTaskDefinition::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceTaskDefinition.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TraceTaskDefinition::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceTaskDefinition.target)
}
inline std::string* TraceTaskDefinition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TraceTaskDefinition.target)
  return _s;
}
inline const std::string& TraceTaskDefinition::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void TraceTaskDefinition::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* TraceTaskDefinition::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* TraceTaskDefinition::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TraceTaskDefinition.target)
  return _impl_.target_.Release();
}
inline void TraceTaskDefinition::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TraceTaskDefinition.target)
}

// uint32 period = 2 [json_name = "period"];
inline void TraceTaskDefinition::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t TraceTaskDefinition::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceTaskDefinition.period)
  return _internal_period();
}
inline void TraceTaskDefinition::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceTaskDefinition.period)
}
inline ::uint32_t TraceTaskDefinition::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void TraceTaskDefinition::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 3 [json_name = "expiry"];
inline void TraceTaskDefinition::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t TraceTaskDefinition::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceTaskDefinition.expiry)
  return _internal_expiry();
}
inline void TraceTaskDefinition::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceTaskDefinition.expiry)
}
inline ::uint32_t TraceTaskDefinition::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void TraceTaskDefinition::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// uint32 limit = 4 [json_name = "limit"];
inline void TraceTaskDefinition::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0u;
}
inline ::uint32_t TraceTaskDefinition::limit() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceTaskDefinition.limit)
  return _internal_limit();
}
inline void TraceTaskDefinition::set_limit(::uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceTaskDefinition.limit)
}
inline ::uint32_t TraceTaskDefinition::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void TraceTaskDefinition::_internal_set_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// HTTPTaskDefinition

// string target = 1 [json_name = "target"];
inline void HTTPTaskDefinition::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& HTTPTaskDefinition::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPTaskDefinition.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HTTPTaskDefinition::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPTaskDefinition.target)
}
inline std::string* HTTPTaskDefinition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HTTPTaskDefinition.target)
  return _s;
}
inline const std::string& HTTPTaskDefinition::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void HTTPTaskDefinition::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* HTTPTaskDefinition::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* HTTPTaskDefinition::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HTTPTaskDefinition.target)
  return _impl_.target_.Release();
}
inline void HTTPTaskDefinition::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HTTPTaskDefinition.target)
}

// uint32 period = 2 [json_name = "period"];
inline void HTTPTaskDefinition::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t HTTPTaskDefinition::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPTaskDefinition.period)
  return _internal_period();
}
inline void HTTPTaskDefinition::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPTaskDefinition.period)
}
inline ::uint32_t HTTPTaskDefinition::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void HTTPTaskDefinition::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 3 [json_name = "expiry"];
inline void HTTPTaskDefinition::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t HTTPTaskDefinition::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPTaskDefinition.expiry)
  return _internal_expiry();
}
inline void HTTPTaskDefinition::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPTaskDefinition.expiry)
}
inline ::uint32_t HTTPTaskDefinition::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void HTTPTaskDefinition::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// -------------------------------------------------------------------

// Task

// string id = 1 [json_name = "id"];
inline void Task::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Task::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Task.id)
}
inline std::string* Task::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.id)
  return _s;
}
inline const std::string& Task::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Task::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Task::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.id)
  return _impl_.id_.Release();
}
inline void Task::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Task.id)
}

// string test_id = 2 [json_name = "testId"];
inline void Task::clear_test_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.ClearToEmpty();
}
inline const std::string& Task::test_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.test_id)
  return _internal_test_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_test_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Task.test_id)
}
inline std::string* Task::mutable_test_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_test_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.test_id)
  return _s;
}
inline const std::string& Task::_internal_test_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.test_id_.Get();
}
inline void Task::_internal_set_test_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_test_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.test_id_.Mutable( GetArena());
}
inline std::string* Task::release_test_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.test_id)
  return _impl_.test_id_.Release();
}
inline void Task::set_allocated_test_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.test_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.test_id_.IsDefault()) {
    _impl_.test_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Task.test_id)
}

// string device_id = 3 [json_name = "deviceId"];
inline void Task::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& Task::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Task.device_id)
}
inline std::string* Task::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.device_id)
  return _s;
}
inline const std::string& Task::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_.Get();
}
inline void Task::_internal_set_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* Task::release_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.device_id)
  return _impl_.device_id_.Release();
}
inline void Task::set_allocated_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Task.device_id)
}

// .kentik.synthetics.v202101beta1.TaskState state = 4 [json_name = "state"];
inline void Task::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::kentik::synthetics::v202101beta1::TaskState Task::state() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.state)
  return _internal_state();
}
inline void Task::set_state(::kentik::synthetics::v202101beta1::TaskState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Task.state)
}
inline ::kentik::synthetics::v202101beta1::TaskState Task::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::TaskState>(_impl_.state_);
}
inline void Task::_internal_set_state(::kentik::synthetics::v202101beta1::TaskState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// string status = 5 [json_name = "status"];
inline void Task::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& Task::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Task.status)
}
inline std::string* Task::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.status)
  return _s;
}
inline const std::string& Task::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void Task::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* Task::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.status)
  return _impl_.status_.Release();
}
inline void Task::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Task.status)
}

// .kentik.synthetics.v202101beta1.IPFamily family = 6 [json_name = "family"];
inline void Task::clear_family() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.family_ = 0;
}
inline ::kentik::synthetics::v202101beta1::IPFamily Task::family() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.family)
  return _internal_family();
}
inline void Task::set_family(::kentik::synthetics::v202101beta1::IPFamily value) {
  _internal_set_family(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Task.family)
}
inline ::kentik::synthetics::v202101beta1::IPFamily Task::_internal_family() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::IPFamily>(_impl_.family_);
}
inline void Task::_internal_set_family(::kentik::synthetics::v202101beta1::IPFamily value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.family_ = value;
}

// .kentik.synthetics.v202101beta1.PingTaskDefinition ping = 9 [json_name = "ping"];
inline bool Task::has_ping() const {
  return definition_case() == kPing;
}
inline bool Task::_internal_has_ping() const {
  return definition_case() == kPing;
}
inline void Task::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void Task::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kPing) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.ping_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.ping_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::PingTaskDefinition* Task::release_ping() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.ping)
  if (definition_case() == kPing) {
    clear_has_definition();
    auto* temp = _impl_.definition_.ping_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::PingTaskDefinition& Task::_internal_ping() const {
  return definition_case() == kPing ? *_impl_.definition_.ping_ : reinterpret_cast<::kentik::synthetics::v202101beta1::PingTaskDefinition&>(::kentik::synthetics::v202101beta1::_PingTaskDefinition_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::PingTaskDefinition& Task::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.ping)
  return _internal_ping();
}
inline ::kentik::synthetics::v202101beta1::PingTaskDefinition* Task::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.Task.ping)
  if (definition_case() == kPing) {
    clear_has_definition();
    auto* temp = _impl_.definition_.ping_;
    _impl_.definition_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_ping(::kentik::synthetics::v202101beta1::PingTaskDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_ping();
    _impl_.definition_.ping_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Task.ping)
}
inline ::kentik::synthetics::v202101beta1::PingTaskDefinition* Task::_internal_mutable_ping() {
  if (definition_case() != kPing) {
    clear_definition();
    set_has_ping();
    _impl_.definition_.ping_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::PingTaskDefinition>(GetArena());
  }
  return _impl_.definition_.ping_;
}
inline ::kentik::synthetics::v202101beta1::PingTaskDefinition* Task::mutable_ping() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::PingTaskDefinition* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.ping)
  return _msg;
}

// .kentik.synthetics.v202101beta1.TraceTaskDefinition traceroute = 10 [json_name = "traceroute"];
inline bool Task::has_traceroute() const {
  return definition_case() == kTraceroute;
}
inline bool Task::_internal_has_traceroute() const {
  return definition_case() == kTraceroute;
}
inline void Task::set_has_traceroute() {
  _impl_._oneof_case_[0] = kTraceroute;
}
inline void Task::clear_traceroute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kTraceroute) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.traceroute_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.traceroute_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::TraceTaskDefinition* Task::release_traceroute() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.traceroute)
  if (definition_case() == kTraceroute) {
    clear_has_definition();
    auto* temp = _impl_.definition_.traceroute_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.traceroute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::TraceTaskDefinition& Task::_internal_traceroute() const {
  return definition_case() == kTraceroute ? *_impl_.definition_.traceroute_ : reinterpret_cast<::kentik::synthetics::v202101beta1::TraceTaskDefinition&>(::kentik::synthetics::v202101beta1::_TraceTaskDefinition_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TraceTaskDefinition& Task::traceroute() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.traceroute)
  return _internal_traceroute();
}
inline ::kentik::synthetics::v202101beta1::TraceTaskDefinition* Task::unsafe_arena_release_traceroute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.Task.traceroute)
  if (definition_case() == kTraceroute) {
    clear_has_definition();
    auto* temp = _impl_.definition_.traceroute_;
    _impl_.definition_.traceroute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_traceroute(::kentik::synthetics::v202101beta1::TraceTaskDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_traceroute();
    _impl_.definition_.traceroute_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Task.traceroute)
}
inline ::kentik::synthetics::v202101beta1::TraceTaskDefinition* Task::_internal_mutable_traceroute() {
  if (definition_case() != kTraceroute) {
    clear_definition();
    set_has_traceroute();
    _impl_.definition_.traceroute_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TraceTaskDefinition>(GetArena());
  }
  return _impl_.definition_.traceroute_;
}
inline ::kentik::synthetics::v202101beta1::TraceTaskDefinition* Task::mutable_traceroute() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::TraceTaskDefinition* _msg = _internal_mutable_traceroute();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.traceroute)
  return _msg;
}

// .kentik.synthetics.v202101beta1.HTTPTaskDefinition http = 11 [json_name = "http"];
inline bool Task::has_http() const {
  return definition_case() == kHttp;
}
inline bool Task::_internal_has_http() const {
  return definition_case() == kHttp;
}
inline void Task::set_has_http() {
  _impl_._oneof_case_[0] = kHttp;
}
inline void Task::clear_http() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kHttp) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.http_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.http_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* Task::release_http() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.http)
  if (definition_case() == kHttp) {
    clear_has_definition();
    auto* temp = _impl_.definition_.http_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.http_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::HTTPTaskDefinition& Task::_internal_http() const {
  return definition_case() == kHttp ? *_impl_.definition_.http_ : reinterpret_cast<::kentik::synthetics::v202101beta1::HTTPTaskDefinition&>(::kentik::synthetics::v202101beta1::_HTTPTaskDefinition_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::HTTPTaskDefinition& Task::http() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.http)
  return _internal_http();
}
inline ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* Task::unsafe_arena_release_http() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.Task.http)
  if (definition_case() == kHttp) {
    clear_has_definition();
    auto* temp = _impl_.definition_.http_;
    _impl_.definition_.http_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_http(::kentik::synthetics::v202101beta1::HTTPTaskDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_http();
    _impl_.definition_.http_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Task.http)
}
inline ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* Task::_internal_mutable_http() {
  if (definition_case() != kHttp) {
    clear_definition();
    set_has_http();
    _impl_.definition_.http_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::HTTPTaskDefinition>(GetArena());
  }
  return _impl_.definition_.http_;
}
inline ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* Task::mutable_http() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::HTTPTaskDefinition* _msg = _internal_mutable_http();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.http)
  return _msg;
}

// .kentik.synthetics.v202101beta1.KnockTaskDefinition knock = 12 [json_name = "knock"];
inline bool Task::has_knock() const {
  return definition_case() == kKnock;
}
inline bool Task::_internal_has_knock() const {
  return definition_case() == kKnock;
}
inline void Task::set_has_knock() {
  _impl_._oneof_case_[0] = kKnock;
}
inline void Task::clear_knock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kKnock) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.knock_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.knock_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::KnockTaskDefinition* Task::release_knock() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.knock)
  if (definition_case() == kKnock) {
    clear_has_definition();
    auto* temp = _impl_.definition_.knock_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.knock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::KnockTaskDefinition& Task::_internal_knock() const {
  return definition_case() == kKnock ? *_impl_.definition_.knock_ : reinterpret_cast<::kentik::synthetics::v202101beta1::KnockTaskDefinition&>(::kentik::synthetics::v202101beta1::_KnockTaskDefinition_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::KnockTaskDefinition& Task::knock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.knock)
  return _internal_knock();
}
inline ::kentik::synthetics::v202101beta1::KnockTaskDefinition* Task::unsafe_arena_release_knock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.Task.knock)
  if (definition_case() == kKnock) {
    clear_has_definition();
    auto* temp = _impl_.definition_.knock_;
    _impl_.definition_.knock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_knock(::kentik::synthetics::v202101beta1::KnockTaskDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_knock();
    _impl_.definition_.knock_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Task.knock)
}
inline ::kentik::synthetics::v202101beta1::KnockTaskDefinition* Task::_internal_mutable_knock() {
  if (definition_case() != kKnock) {
    clear_definition();
    set_has_knock();
    _impl_.definition_.knock_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::KnockTaskDefinition>(GetArena());
  }
  return _impl_.definition_.knock_;
}
inline ::kentik::synthetics::v202101beta1::KnockTaskDefinition* Task::mutable_knock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::KnockTaskDefinition* _msg = _internal_mutable_knock();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.knock)
  return _msg;
}

// .kentik.synthetics.v202101beta1.DNSTaskDefinition dns = 13 [json_name = "dns"];
inline bool Task::has_dns() const {
  return definition_case() == kDns;
}
inline bool Task::_internal_has_dns() const {
  return definition_case() == kDns;
}
inline void Task::set_has_dns() {
  _impl_._oneof_case_[0] = kDns;
}
inline void Task::clear_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kDns) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.dns_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.dns_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::DNSTaskDefinition* Task::release_dns() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.dns)
  if (definition_case() == kDns) {
    clear_has_definition();
    auto* temp = _impl_.definition_.dns_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.dns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::DNSTaskDefinition& Task::_internal_dns() const {
  return definition_case() == kDns ? *_impl_.definition_.dns_ : reinterpret_cast<::kentik::synthetics::v202101beta1::DNSTaskDefinition&>(::kentik::synthetics::v202101beta1::_DNSTaskDefinition_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::DNSTaskDefinition& Task::dns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.dns)
  return _internal_dns();
}
inline ::kentik::synthetics::v202101beta1::DNSTaskDefinition* Task::unsafe_arena_release_dns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.Task.dns)
  if (definition_case() == kDns) {
    clear_has_definition();
    auto* temp = _impl_.definition_.dns_;
    _impl_.definition_.dns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_dns(::kentik::synthetics::v202101beta1::DNSTaskDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_dns();
    _impl_.definition_.dns_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Task.dns)
}
inline ::kentik::synthetics::v202101beta1::DNSTaskDefinition* Task::_internal_mutable_dns() {
  if (definition_case() != kDns) {
    clear_definition();
    set_has_dns();
    _impl_.definition_.dns_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::DNSTaskDefinition>(GetArena());
  }
  return _impl_.definition_.dns_;
}
inline ::kentik::synthetics::v202101beta1::DNSTaskDefinition* Task::mutable_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::DNSTaskDefinition* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.dns)
  return _msg;
}

// .kentik.synthetics.v202101beta1.ShakeTaskDefinition shake = 14 [json_name = "shake"];
inline bool Task::has_shake() const {
  return definition_case() == kShake;
}
inline bool Task::_internal_has_shake() const {
  return definition_case() == kShake;
}
inline void Task::set_has_shake() {
  _impl_._oneof_case_[0] = kShake;
}
inline void Task::clear_shake() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kShake) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.shake_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.shake_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* Task::release_shake() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Task.shake)
  if (definition_case() == kShake) {
    clear_has_definition();
    auto* temp = _impl_.definition_.shake_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.shake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::ShakeTaskDefinition& Task::_internal_shake() const {
  return definition_case() == kShake ? *_impl_.definition_.shake_ : reinterpret_cast<::kentik::synthetics::v202101beta1::ShakeTaskDefinition&>(::kentik::synthetics::v202101beta1::_ShakeTaskDefinition_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::ShakeTaskDefinition& Task::shake() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Task.shake)
  return _internal_shake();
}
inline ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* Task::unsafe_arena_release_shake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.Task.shake)
  if (definition_case() == kShake) {
    clear_has_definition();
    auto* temp = _impl_.definition_.shake_;
    _impl_.definition_.shake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Task::unsafe_arena_set_allocated_shake(::kentik::synthetics::v202101beta1::ShakeTaskDefinition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_shake();
    _impl_.definition_.shake_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Task.shake)
}
inline ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* Task::_internal_mutable_shake() {
  if (definition_case() != kShake) {
    clear_definition();
    set_has_shake();
    _impl_.definition_.shake_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::ShakeTaskDefinition>(GetArena());
  }
  return _impl_.definition_.shake_;
}
inline ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* Task::mutable_shake() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::ShakeTaskDefinition* _msg = _internal_mutable_shake();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Task.shake)
  return _msg;
}

inline bool Task::has_definition() const {
  return definition_case() != DEFINITION_NOT_SET;
}
inline void Task::clear_has_definition() {
  _impl_._oneof_case_[0] = DEFINITION_NOT_SET;
}
inline Task::DefinitionCase Task::definition_case() const {
  return Task::DefinitionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// KnockTaskDefinition

// string target = 1 [json_name = "target"];
inline void KnockTaskDefinition::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& KnockTaskDefinition::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.KnockTaskDefinition.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KnockTaskDefinition::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.KnockTaskDefinition.target)
}
inline std::string* KnockTaskDefinition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.KnockTaskDefinition.target)
  return _s;
}
inline const std::string& KnockTaskDefinition::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void KnockTaskDefinition::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* KnockTaskDefinition::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* KnockTaskDefinition::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.KnockTaskDefinition.target)
  return _impl_.target_.Release();
}
inline void KnockTaskDefinition::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.KnockTaskDefinition.target)
}

// uint32 period = 2 [json_name = "period"];
inline void KnockTaskDefinition::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t KnockTaskDefinition::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.KnockTaskDefinition.period)
  return _internal_period();
}
inline void KnockTaskDefinition::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.KnockTaskDefinition.period)
}
inline ::uint32_t KnockTaskDefinition::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void KnockTaskDefinition::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 3 [json_name = "expiry"];
inline void KnockTaskDefinition::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t KnockTaskDefinition::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.KnockTaskDefinition.expiry)
  return _internal_expiry();
}
inline void KnockTaskDefinition::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.KnockTaskDefinition.expiry)
}
inline ::uint32_t KnockTaskDefinition::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void KnockTaskDefinition::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// uint32 count = 4 [json_name = "count"];
inline void KnockTaskDefinition::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t KnockTaskDefinition::count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.KnockTaskDefinition.count)
  return _internal_count();
}
inline void KnockTaskDefinition::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.KnockTaskDefinition.count)
}
inline ::uint32_t KnockTaskDefinition::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void KnockTaskDefinition::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// uint32 port = 5 [json_name = "port"];
inline void KnockTaskDefinition::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0u;
}
inline ::uint32_t KnockTaskDefinition::port() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.KnockTaskDefinition.port)
  return _internal_port();
}
inline void KnockTaskDefinition::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.KnockTaskDefinition.port)
}
inline ::uint32_t KnockTaskDefinition::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void KnockTaskDefinition::_internal_set_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// DNSTaskDefinition

// string target = 1 [json_name = "target"];
inline void DNSTaskDefinition::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& DNSTaskDefinition::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DNSTaskDefinition::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.target)
}
inline std::string* DNSTaskDefinition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DNSTaskDefinition.target)
  return _s;
}
inline const std::string& DNSTaskDefinition::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void DNSTaskDefinition::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* DNSTaskDefinition::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* DNSTaskDefinition::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DNSTaskDefinition.target)
  return _impl_.target_.Release();
}
inline void DNSTaskDefinition::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DNSTaskDefinition.target)
}

// uint32 period = 2 [json_name = "period"];
inline void DNSTaskDefinition::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t DNSTaskDefinition::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.period)
  return _internal_period();
}
inline void DNSTaskDefinition::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.period)
}
inline ::uint32_t DNSTaskDefinition::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void DNSTaskDefinition::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 3 [json_name = "expiry"];
inline void DNSTaskDefinition::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t DNSTaskDefinition::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.expiry)
  return _internal_expiry();
}
inline void DNSTaskDefinition::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.expiry)
}
inline ::uint32_t DNSTaskDefinition::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void DNSTaskDefinition::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// uint32 count = 4 [json_name = "count"];
inline void DNSTaskDefinition::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t DNSTaskDefinition::count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.count)
  return _internal_count();
}
inline void DNSTaskDefinition::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.count)
}
inline ::uint32_t DNSTaskDefinition::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void DNSTaskDefinition::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// uint32 port = 5 [json_name = "port"];
inline void DNSTaskDefinition::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0u;
}
inline ::uint32_t DNSTaskDefinition::port() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.port)
  return _internal_port();
}
inline void DNSTaskDefinition::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.port)
}
inline ::uint32_t DNSTaskDefinition::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void DNSTaskDefinition::_internal_set_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// string type = 6 [json_name = "type"];
inline void DNSTaskDefinition::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& DNSTaskDefinition::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DNSTaskDefinition::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.type)
}
inline std::string* DNSTaskDefinition::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DNSTaskDefinition.type)
  return _s;
}
inline const std::string& DNSTaskDefinition::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void DNSTaskDefinition::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* DNSTaskDefinition::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* DNSTaskDefinition::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DNSTaskDefinition.type)
  return _impl_.type_.Release();
}
inline void DNSTaskDefinition::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DNSTaskDefinition.type)
}

// string resolver = 7 [json_name = "resolver"];
inline void DNSTaskDefinition::clear_resolver() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolver_.ClearToEmpty();
}
inline const std::string& DNSTaskDefinition::resolver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNSTaskDefinition.resolver)
  return _internal_resolver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DNSTaskDefinition::set_resolver(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNSTaskDefinition.resolver)
}
inline std::string* DNSTaskDefinition::mutable_resolver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolver();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DNSTaskDefinition.resolver)
  return _s;
}
inline const std::string& DNSTaskDefinition::_internal_resolver() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolver_.Get();
}
inline void DNSTaskDefinition::_internal_set_resolver(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolver_.Set(value, GetArena());
}
inline std::string* DNSTaskDefinition::_internal_mutable_resolver() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolver_.Mutable( GetArena());
}
inline std::string* DNSTaskDefinition::release_resolver() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DNSTaskDefinition.resolver)
  return _impl_.resolver_.Release();
}
inline void DNSTaskDefinition::set_allocated_resolver(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolver_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolver_.IsDefault()) {
    _impl_.resolver_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DNSTaskDefinition.resolver)
}

// -------------------------------------------------------------------

// ShakeTaskDefinition

// string target = 1 [json_name = "target"];
inline void ShakeTaskDefinition::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& ShakeTaskDefinition::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ShakeTaskDefinition.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShakeTaskDefinition::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ShakeTaskDefinition.target)
}
inline std::string* ShakeTaskDefinition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.ShakeTaskDefinition.target)
  return _s;
}
inline const std::string& ShakeTaskDefinition::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void ShakeTaskDefinition::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* ShakeTaskDefinition::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* ShakeTaskDefinition::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.ShakeTaskDefinition.target)
  return _impl_.target_.Release();
}
inline void ShakeTaskDefinition::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.ShakeTaskDefinition.target)
}

// uint32 port = 2 [json_name = "port"];
inline void ShakeTaskDefinition::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0u;
}
inline ::uint32_t ShakeTaskDefinition::port() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ShakeTaskDefinition.port)
  return _internal_port();
}
inline void ShakeTaskDefinition::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ShakeTaskDefinition.port)
}
inline ::uint32_t ShakeTaskDefinition::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void ShakeTaskDefinition::_internal_set_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// uint32 period = 3 [json_name = "period"];
inline void ShakeTaskDefinition::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t ShakeTaskDefinition::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ShakeTaskDefinition.period)
  return _internal_period();
}
inline void ShakeTaskDefinition::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ShakeTaskDefinition.period)
}
inline ::uint32_t ShakeTaskDefinition::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void ShakeTaskDefinition::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 4 [json_name = "expiry"];
inline void ShakeTaskDefinition::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t ShakeTaskDefinition::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ShakeTaskDefinition.expiry)
  return _internal_expiry();
}
inline void ShakeTaskDefinition::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ShakeTaskDefinition.expiry)
}
inline ::uint32_t ShakeTaskDefinition::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void ShakeTaskDefinition::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// string id = 1 [json_name = "id"];
inline void UserInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UserInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.UserInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.UserInfo.id)
}
inline std::string* UserInfo::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.UserInfo.id)
  return _s;
}
inline const std::string& UserInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void UserInfo::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* UserInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.UserInfo.id)
  return _impl_.id_.Release();
}
inline void UserInfo::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.UserInfo.id)
}

// string email = 2 [json_name = "email"];
inline void UserInfo::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserInfo::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.UserInfo.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.UserInfo.email)
}
inline std::string* UserInfo::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.UserInfo.email)
  return _s;
}
inline const std::string& UserInfo::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void UserInfo::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserInfo::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.UserInfo.email)
  return _impl_.email_.Release();
}
inline void UserInfo::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.UserInfo.email)
}

// string full_name = 3 [json_name = "fullName"];
inline void UserInfo::clear_full_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_name_.ClearToEmpty();
}
inline const std::string& UserInfo::full_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.UserInfo.full_name)
  return _internal_full_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_full_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.UserInfo.full_name)
}
inline std::string* UserInfo::mutable_full_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.UserInfo.full_name)
  return _s;
}
inline const std::string& UserInfo::_internal_full_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.full_name_.Get();
}
inline void UserInfo::_internal_set_full_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_name_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_full_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.full_name_.Mutable( GetArena());
}
inline std::string* UserInfo::release_full_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.UserInfo.full_name)
  return _impl_.full_name_.Release();
}
inline void UserInfo::set_allocated_full_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.full_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.UserInfo.full_name)
}

// -------------------------------------------------------------------

// Test

// string id = 1 [json_name = "id"];
inline void Test::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Test::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Test::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Test.id)
}
inline std::string* Test::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.id)
  return _s;
}
inline const std::string& Test::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Test::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Test::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Test::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.id)
  return _impl_.id_.Release();
}
inline void Test::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.id)
}

// string name = 2 [json_name = "name"];
inline void Test::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Test::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Test::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Test.name)
}
inline std::string* Test::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.name)
  return _s;
}
inline const std::string& Test::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Test::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Test::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Test::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.name)
  return _impl_.name_.Release();
}
inline void Test::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.name)
}

// string type = 3 [json_name = "type"];
inline void Test::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Test::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Test::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Test.type)
}
inline std::string* Test::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.type)
  return _s;
}
inline const std::string& Test::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Test::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Test::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Test::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.type)
  return _impl_.type_.Release();
}
inline void Test::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.type)
}

// string device_id = 4 [json_name = "deviceId"];
inline void Test::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& Test::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Test::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Test.device_id)
}
inline std::string* Test::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.device_id)
  return _s;
}
inline const std::string& Test::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_.Get();
}
inline void Test::_internal_set_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* Test::_internal_mutable_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* Test::release_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.device_id)
  return _impl_.device_id_.Release();
}
inline void Test::set_allocated_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.device_id)
}

// .kentik.synthetics.v202101beta1.TestStatus status = 5 [json_name = "status"];
inline void Test::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::kentik::synthetics::v202101beta1::TestStatus Test::status() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.status)
  return _internal_status();
}
inline void Test::set_status(::kentik::synthetics::v202101beta1::TestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Test.status)
}
inline ::kentik::synthetics::v202101beta1::TestStatus Test::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::TestStatus>(_impl_.status_);
}
inline void Test::_internal_set_status(::kentik::synthetics::v202101beta1::TestStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .kentik.synthetics.v202101beta1.TestSettings settings = 6 [json_name = "settings"];
inline bool Test::has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline void Test::clear_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::TestSettings& Test::_internal_settings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::TestSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::TestSettings&>(::kentik::synthetics::v202101beta1::_TestSettings_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TestSettings& Test::settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.settings)
  return _internal_settings();
}
inline void Test::unsafe_arena_set_allocated_settings(::kentik::synthetics::v202101beta1::TestSettings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Test.settings)
}
inline ::kentik::synthetics::v202101beta1::TestSettings* Test::release_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::TestSettings* released = _impl_.settings_;
  _impl_.settings_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::TestSettings* Test::unsafe_arena_release_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::TestSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::TestSettings* Test::_internal_mutable_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.settings_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TestSettings>(GetArena());
    _impl_.settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestSettings*>(p);
  }
  return _impl_.settings_;
}
inline ::kentik::synthetics::v202101beta1::TestSettings* Test::mutable_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::TestSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.settings)
  return _msg;
}
inline void Test::set_allocated_settings(::kentik::synthetics::v202101beta1::TestSettings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.settings)
}

// .google.protobuf.Timestamp expires_on = 7 [json_name = "expiresOn"];
inline bool Test::has_expires_on() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expires_on_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Test::_internal_expires_on() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.expires_on_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Test::expires_on() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.expires_on)
  return _internal_expires_on();
}
inline void Test::unsafe_arena_set_allocated_expires_on(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expires_on_);
  }
  _impl_.expires_on_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Test.expires_on)
}
inline ::google::protobuf::Timestamp* Test::release_expires_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.expires_on_;
  _impl_.expires_on_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Test::unsafe_arena_release_expires_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.expires_on)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.expires_on_;
  _impl_.expires_on_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Test::_internal_mutable_expires_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expires_on_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.expires_on_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expires_on_;
}
inline ::google::protobuf::Timestamp* Test::mutable_expires_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expires_on();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.expires_on)
  return _msg;
}
inline void Test::set_allocated_expires_on(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expires_on_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.expires_on_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.expires_on)
}

// .google.protobuf.Timestamp cdate = 8 [json_name = "cdate"];
inline bool Test::has_cdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cdate_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Test::_internal_cdate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.cdate_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Test::cdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.cdate)
  return _internal_cdate();
}
inline void Test::unsafe_arena_set_allocated_cdate(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cdate_);
  }
  _impl_.cdate_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Test.cdate)
}
inline ::google::protobuf::Timestamp* Test::release_cdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.cdate_;
  _impl_.cdate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Test::unsafe_arena_release_cdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.cdate)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.cdate_;
  _impl_.cdate_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Test::_internal_mutable_cdate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cdate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.cdate_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.cdate_;
}
inline ::google::protobuf::Timestamp* Test::mutable_cdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_cdate();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.cdate)
  return _msg;
}
inline void Test::set_allocated_cdate(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cdate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.cdate_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.cdate)
}

// .google.protobuf.Timestamp edate = 9 [json_name = "edate"];
inline bool Test::has_edate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.edate_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Test::_internal_edate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.edate_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Test::edate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.edate)
  return _internal_edate();
}
inline void Test::unsafe_arena_set_allocated_edate(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.edate_);
  }
  _impl_.edate_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Test.edate)
}
inline ::google::protobuf::Timestamp* Test::release_edate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* released = _impl_.edate_;
  _impl_.edate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Test::unsafe_arena_release_edate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.edate)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* temp = _impl_.edate_;
  _impl_.edate_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Test::_internal_mutable_edate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.edate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.edate_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.edate_;
}
inline ::google::protobuf::Timestamp* Test::mutable_edate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_edate();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.edate)
  return _msg;
}
inline void Test::set_allocated_edate(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.edate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.edate_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.edate)
}

// .kentik.synthetics.v202101beta1.UserInfo created_by = 10 [json_name = "createdBy"];
inline bool Test::has_created_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_by_ != nullptr);
  return value;
}
inline void Test::clear_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_by_ != nullptr) _impl_.created_by_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::kentik::synthetics::v202101beta1::UserInfo& Test::_internal_created_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::UserInfo* p = _impl_.created_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::UserInfo&>(::kentik::synthetics::v202101beta1::_UserInfo_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::UserInfo& Test::created_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.created_by)
  return _internal_created_by();
}
inline void Test::unsafe_arena_set_allocated_created_by(::kentik::synthetics::v202101beta1::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_by_);
  }
  _impl_.created_by_ = reinterpret_cast<::kentik::synthetics::v202101beta1::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Test.created_by)
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::kentik::synthetics::v202101beta1::UserInfo* released = _impl_.created_by_;
  _impl_.created_by_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::unsafe_arena_release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.created_by)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::kentik::synthetics::v202101beta1::UserInfo* temp = _impl_.created_by_;
  _impl_.created_by_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::_internal_mutable_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_by_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::UserInfo>(GetArena());
    _impl_.created_by_ = reinterpret_cast<::kentik::synthetics::v202101beta1::UserInfo*>(p);
  }
  return _impl_.created_by_;
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::mutable_created_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::kentik::synthetics::v202101beta1::UserInfo* _msg = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.created_by)
  return _msg;
}
inline void Test::set_allocated_created_by(::kentik::synthetics::v202101beta1::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.created_by_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.created_by_ = reinterpret_cast<::kentik::synthetics::v202101beta1::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.created_by)
}

// .kentik.synthetics.v202101beta1.UserInfo last_updated_by = 11 [json_name = "lastUpdatedBy"];
inline bool Test::has_last_updated_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_updated_by_ != nullptr);
  return value;
}
inline void Test::clear_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_updated_by_ != nullptr) _impl_.last_updated_by_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::kentik::synthetics::v202101beta1::UserInfo& Test::_internal_last_updated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::UserInfo* p = _impl_.last_updated_by_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::UserInfo&>(::kentik::synthetics::v202101beta1::_UserInfo_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::UserInfo& Test::last_updated_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Test.last_updated_by)
  return _internal_last_updated_by();
}
inline void Test::unsafe_arena_set_allocated_last_updated_by(::kentik::synthetics::v202101beta1::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_updated_by_);
  }
  _impl_.last_updated_by_ = reinterpret_cast<::kentik::synthetics::v202101beta1::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Test.last_updated_by)
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::release_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::kentik::synthetics::v202101beta1::UserInfo* released = _impl_.last_updated_by_;
  _impl_.last_updated_by_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::unsafe_arena_release_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Test.last_updated_by)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::kentik::synthetics::v202101beta1::UserInfo* temp = _impl_.last_updated_by_;
  _impl_.last_updated_by_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::_internal_mutable_last_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.last_updated_by_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::UserInfo>(GetArena());
    _impl_.last_updated_by_ = reinterpret_cast<::kentik::synthetics::v202101beta1::UserInfo*>(p);
  }
  return _impl_.last_updated_by_;
}
inline ::kentik::synthetics::v202101beta1::UserInfo* Test::mutable_last_updated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::kentik::synthetics::v202101beta1::UserInfo* _msg = _internal_mutable_last_updated_by();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Test.last_updated_by)
  return _msg;
}
inline void Test::set_allocated_last_updated_by(::kentik::synthetics::v202101beta1::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.last_updated_by_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.last_updated_by_ = reinterpret_cast<::kentik::synthetics::v202101beta1::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Test.last_updated_by)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HTTPConfig

// uint32 period = 1 [json_name = "period"];
inline void HTTPConfig::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t HTTPConfig::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPConfig.period)
  return _internal_period();
}
inline void HTTPConfig::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPConfig.period)
}
inline ::uint32_t HTTPConfig::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void HTTPConfig::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 expiry = 2 [json_name = "expiry"];
inline void HTTPConfig::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t HTTPConfig::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPConfig.expiry)
  return _internal_expiry();
}
inline void HTTPConfig::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPConfig.expiry)
}
inline ::uint32_t HTTPConfig::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void HTTPConfig::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// string method = 3 [json_name = "method"];
inline void HTTPConfig::clear_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.ClearToEmpty();
}
inline const std::string& HTTPConfig::method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPConfig.method)
  return _internal_method();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HTTPConfig::set_method(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPConfig.method)
}
inline std::string* HTTPConfig::mutable_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HTTPConfig.method)
  return _s;
}
inline const std::string& HTTPConfig::_internal_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.method_.Get();
}
inline void HTTPConfig::_internal_set_method(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.Set(value, GetArena());
}
inline std::string* HTTPConfig::_internal_mutable_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.method_.Mutable( GetArena());
}
inline std::string* HTTPConfig::release_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HTTPConfig.method)
  return _impl_.method_.Release();
}
inline void HTTPConfig::set_allocated_method(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HTTPConfig.method)
}

// map<string, string> headers = 4 [json_name = "headers"];
inline int HTTPConfig::_internal_headers_size() const {
  return _internal_headers().size();
}
inline int HTTPConfig::headers_size() const {
  return _internal_headers_size();
}
inline void HTTPConfig::clear_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.headers_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HTTPConfig::_internal_headers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.headers_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HTTPConfig::headers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:kentik.synthetics.v202101beta1.HTTPConfig.headers)
  return _internal_headers();
}
inline ::google::protobuf::Map<std::string, std::string>* HTTPConfig::_internal_mutable_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.headers_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HTTPConfig::mutable_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:kentik.synthetics.v202101beta1.HTTPConfig.headers)
  return _internal_mutable_headers();
}

// string body = 5 [json_name = "body"];
inline void HTTPConfig::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& HTTPConfig::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPConfig.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HTTPConfig::set_body(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPConfig.body)
}
inline std::string* HTTPConfig::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HTTPConfig.body)
  return _s;
}
inline const std::string& HTTPConfig::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.body_.Get();
}
inline void HTTPConfig::_internal_set_body(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* HTTPConfig::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* HTTPConfig::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HTTPConfig.body)
  return _impl_.body_.Release();
}
inline void HTTPConfig::set_allocated_body(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HTTPConfig.body)
}

// bool ignore_tls_errors = 6 [json_name = "ignoreTlsErrors"];
inline void HTTPConfig::clear_ignore_tls_errors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_tls_errors_ = false;
}
inline bool HTTPConfig::ignore_tls_errors() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HTTPConfig.ignore_tls_errors)
  return _internal_ignore_tls_errors();
}
inline void HTTPConfig::set_ignore_tls_errors(bool value) {
  _internal_set_ignore_tls_errors(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HTTPConfig.ignore_tls_errors)
}
inline bool HTTPConfig::_internal_ignore_tls_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_tls_errors_;
}
inline void HTTPConfig::_internal_set_ignore_tls_errors(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_tls_errors_ = value;
}

// map<string, string> css_selectors = 7 [json_name = "cssSelectors"];
inline int HTTPConfig::_internal_css_selectors_size() const {
  return _internal_css_selectors().size();
}
inline int HTTPConfig::css_selectors_size() const {
  return _internal_css_selectors_size();
}
inline void HTTPConfig::clear_css_selectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.css_selectors_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HTTPConfig::_internal_css_selectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.css_selectors_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HTTPConfig::css_selectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:kentik.synthetics.v202101beta1.HTTPConfig.css_selectors)
  return _internal_css_selectors();
}
inline ::google::protobuf::Map<std::string, std::string>* HTTPConfig::_internal_mutable_css_selectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.css_selectors_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HTTPConfig::mutable_css_selectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:kentik.synthetics.v202101beta1.HTTPConfig.css_selectors)
  return _internal_mutable_css_selectors();
}

// -------------------------------------------------------------------

// TestSettings

// .kentik.synthetics.v202101beta1.HostnameTest hostname = 4 [json_name = "hostname"];
inline bool TestSettings::has_hostname() const {
  return definition_case() == kHostname;
}
inline bool TestSettings::_internal_has_hostname() const {
  return definition_case() == kHostname;
}
inline void TestSettings::set_has_hostname() {
  _impl_._oneof_case_[0] = kHostname;
}
inline void TestSettings::clear_hostname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kHostname) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.hostname_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.hostname_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::HostnameTest* TestSettings::release_hostname() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.hostname)
  if (definition_case() == kHostname) {
    clear_has_definition();
    auto* temp = _impl_.definition_.hostname_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.hostname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::HostnameTest& TestSettings::_internal_hostname() const {
  return definition_case() == kHostname ? *_impl_.definition_.hostname_ : reinterpret_cast<::kentik::synthetics::v202101beta1::HostnameTest&>(::kentik::synthetics::v202101beta1::_HostnameTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::HostnameTest& TestSettings::hostname() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.hostname)
  return _internal_hostname();
}
inline ::kentik::synthetics::v202101beta1::HostnameTest* TestSettings::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.hostname)
  if (definition_case() == kHostname) {
    clear_has_definition();
    auto* temp = _impl_.definition_.hostname_;
    _impl_.definition_.hostname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_hostname(::kentik::synthetics::v202101beta1::HostnameTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_hostname();
    _impl_.definition_.hostname_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.hostname)
}
inline ::kentik::synthetics::v202101beta1::HostnameTest* TestSettings::_internal_mutable_hostname() {
  if (definition_case() != kHostname) {
    clear_definition();
    set_has_hostname();
    _impl_.definition_.hostname_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::HostnameTest>(GetArena());
  }
  return _impl_.definition_.hostname_;
}
inline ::kentik::synthetics::v202101beta1::HostnameTest* TestSettings::mutable_hostname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::HostnameTest* _msg = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.hostname)
  return _msg;
}

// .kentik.synthetics.v202101beta1.IpTest ip = 5 [json_name = "ip"];
inline bool TestSettings::has_ip() const {
  return definition_case() == kIp;
}
inline bool TestSettings::_internal_has_ip() const {
  return definition_case() == kIp;
}
inline void TestSettings::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void TestSettings::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kIp) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.ip_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.ip_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::IpTest* TestSettings::release_ip() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.ip)
  if (definition_case() == kIp) {
    clear_has_definition();
    auto* temp = _impl_.definition_.ip_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.ip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::IpTest& TestSettings::_internal_ip() const {
  return definition_case() == kIp ? *_impl_.definition_.ip_ : reinterpret_cast<::kentik::synthetics::v202101beta1::IpTest&>(::kentik::synthetics::v202101beta1::_IpTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::IpTest& TestSettings::ip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.ip)
  return _internal_ip();
}
inline ::kentik::synthetics::v202101beta1::IpTest* TestSettings::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.ip)
  if (definition_case() == kIp) {
    clear_has_definition();
    auto* temp = _impl_.definition_.ip_;
    _impl_.definition_.ip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_ip(::kentik::synthetics::v202101beta1::IpTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_ip();
    _impl_.definition_.ip_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.ip)
}
inline ::kentik::synthetics::v202101beta1::IpTest* TestSettings::_internal_mutable_ip() {
  if (definition_case() != kIp) {
    clear_definition();
    set_has_ip();
    _impl_.definition_.ip_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::IpTest>(GetArena());
  }
  return _impl_.definition_.ip_;
}
inline ::kentik::synthetics::v202101beta1::IpTest* TestSettings::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::IpTest* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.ip)
  return _msg;
}

// .kentik.synthetics.v202101beta1.AgentTest agent = 6 [json_name = "agent"];
inline bool TestSettings::has_agent() const {
  return definition_case() == kAgent;
}
inline bool TestSettings::_internal_has_agent() const {
  return definition_case() == kAgent;
}
inline void TestSettings::set_has_agent() {
  _impl_._oneof_case_[0] = kAgent;
}
inline void TestSettings::clear_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kAgent) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.agent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.agent_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::AgentTest* TestSettings::release_agent() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.agent)
  if (definition_case() == kAgent) {
    clear_has_definition();
    auto* temp = _impl_.definition_.agent_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.agent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::AgentTest& TestSettings::_internal_agent() const {
  return definition_case() == kAgent ? *_impl_.definition_.agent_ : reinterpret_cast<::kentik::synthetics::v202101beta1::AgentTest&>(::kentik::synthetics::v202101beta1::_AgentTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::AgentTest& TestSettings::agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.agent)
  return _internal_agent();
}
inline ::kentik::synthetics::v202101beta1::AgentTest* TestSettings::unsafe_arena_release_agent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.agent)
  if (definition_case() == kAgent) {
    clear_has_definition();
    auto* temp = _impl_.definition_.agent_;
    _impl_.definition_.agent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::AgentTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_agent();
    _impl_.definition_.agent_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.agent)
}
inline ::kentik::synthetics::v202101beta1::AgentTest* TestSettings::_internal_mutable_agent() {
  if (definition_case() != kAgent) {
    clear_definition();
    set_has_agent();
    _impl_.definition_.agent_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::AgentTest>(GetArena());
  }
  return _impl_.definition_.agent_;
}
inline ::kentik::synthetics::v202101beta1::AgentTest* TestSettings::mutable_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::AgentTest* _msg = _internal_mutable_agent();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.agent)
  return _msg;
}

// .kentik.synthetics.v202101beta1.FlowTest flow = 7 [json_name = "flow"];
inline bool TestSettings::has_flow() const {
  return definition_case() == kFlow;
}
inline bool TestSettings::_internal_has_flow() const {
  return definition_case() == kFlow;
}
inline void TestSettings::set_has_flow() {
  _impl_._oneof_case_[0] = kFlow;
}
inline void TestSettings::clear_flow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kFlow) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.flow_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.flow_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::FlowTest* TestSettings::release_flow() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.flow)
  if (definition_case() == kFlow) {
    clear_has_definition();
    auto* temp = _impl_.definition_.flow_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::FlowTest& TestSettings::_internal_flow() const {
  return definition_case() == kFlow ? *_impl_.definition_.flow_ : reinterpret_cast<::kentik::synthetics::v202101beta1::FlowTest&>(::kentik::synthetics::v202101beta1::_FlowTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::FlowTest& TestSettings::flow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.flow)
  return _internal_flow();
}
inline ::kentik::synthetics::v202101beta1::FlowTest* TestSettings::unsafe_arena_release_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.flow)
  if (definition_case() == kFlow) {
    clear_has_definition();
    auto* temp = _impl_.definition_.flow_;
    _impl_.definition_.flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_flow(::kentik::synthetics::v202101beta1::FlowTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_flow();
    _impl_.definition_.flow_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.flow)
}
inline ::kentik::synthetics::v202101beta1::FlowTest* TestSettings::_internal_mutable_flow() {
  if (definition_case() != kFlow) {
    clear_definition();
    set_has_flow();
    _impl_.definition_.flow_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::FlowTest>(GetArena());
  }
  return _impl_.definition_.flow_;
}
inline ::kentik::synthetics::v202101beta1::FlowTest* TestSettings::mutable_flow() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::FlowTest* _msg = _internal_mutable_flow();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.flow)
  return _msg;
}

// .kentik.synthetics.v202101beta1.SiteTest site = 8 [json_name = "site"];
inline bool TestSettings::has_site() const {
  return definition_case() == kSite;
}
inline bool TestSettings::_internal_has_site() const {
  return definition_case() == kSite;
}
inline void TestSettings::set_has_site() {
  _impl_._oneof_case_[0] = kSite;
}
inline void TestSettings::clear_site() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kSite) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.site_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.site_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::SiteTest* TestSettings::release_site() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.site)
  if (definition_case() == kSite) {
    clear_has_definition();
    auto* temp = _impl_.definition_.site_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.site_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::SiteTest& TestSettings::_internal_site() const {
  return definition_case() == kSite ? *_impl_.definition_.site_ : reinterpret_cast<::kentik::synthetics::v202101beta1::SiteTest&>(::kentik::synthetics::v202101beta1::_SiteTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::SiteTest& TestSettings::site() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.site)
  return _internal_site();
}
inline ::kentik::synthetics::v202101beta1::SiteTest* TestSettings::unsafe_arena_release_site() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.site)
  if (definition_case() == kSite) {
    clear_has_definition();
    auto* temp = _impl_.definition_.site_;
    _impl_.definition_.site_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_site(::kentik::synthetics::v202101beta1::SiteTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_site();
    _impl_.definition_.site_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.site)
}
inline ::kentik::synthetics::v202101beta1::SiteTest* TestSettings::_internal_mutable_site() {
  if (definition_case() != kSite) {
    clear_definition();
    set_has_site();
    _impl_.definition_.site_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::SiteTest>(GetArena());
  }
  return _impl_.definition_.site_;
}
inline ::kentik::synthetics::v202101beta1::SiteTest* TestSettings::mutable_site() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::SiteTest* _msg = _internal_mutable_site();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.site)
  return _msg;
}

// .kentik.synthetics.v202101beta1.TagTest tag = 9 [json_name = "tag"];
inline bool TestSettings::has_tag() const {
  return definition_case() == kTag;
}
inline bool TestSettings::_internal_has_tag() const {
  return definition_case() == kTag;
}
inline void TestSettings::set_has_tag() {
  _impl_._oneof_case_[0] = kTag;
}
inline void TestSettings::clear_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kTag) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.tag_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.tag_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::TagTest* TestSettings::release_tag() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.tag)
  if (definition_case() == kTag) {
    clear_has_definition();
    auto* temp = _impl_.definition_.tag_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.tag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::TagTest& TestSettings::_internal_tag() const {
  return definition_case() == kTag ? *_impl_.definition_.tag_ : reinterpret_cast<::kentik::synthetics::v202101beta1::TagTest&>(::kentik::synthetics::v202101beta1::_TagTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TagTest& TestSettings::tag() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.tag)
  return _internal_tag();
}
inline ::kentik::synthetics::v202101beta1::TagTest* TestSettings::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.tag)
  if (definition_case() == kTag) {
    clear_has_definition();
    auto* temp = _impl_.definition_.tag_;
    _impl_.definition_.tag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_tag(::kentik::synthetics::v202101beta1::TagTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_tag();
    _impl_.definition_.tag_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.tag)
}
inline ::kentik::synthetics::v202101beta1::TagTest* TestSettings::_internal_mutable_tag() {
  if (definition_case() != kTag) {
    clear_definition();
    set_has_tag();
    _impl_.definition_.tag_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TagTest>(GetArena());
  }
  return _impl_.definition_.tag_;
}
inline ::kentik::synthetics::v202101beta1::TagTest* TestSettings::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::TagTest* _msg = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.tag)
  return _msg;
}

// .kentik.synthetics.v202101beta1.DnsTest dns = 10 [json_name = "dns"];
inline bool TestSettings::has_dns() const {
  return definition_case() == kDns;
}
inline bool TestSettings::_internal_has_dns() const {
  return definition_case() == kDns;
}
inline void TestSettings::set_has_dns() {
  _impl_._oneof_case_[0] = kDns;
}
inline void TestSettings::clear_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kDns) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.dns_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.dns_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::DnsTest* TestSettings::release_dns() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.dns)
  if (definition_case() == kDns) {
    clear_has_definition();
    auto* temp = _impl_.definition_.dns_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.dns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::DnsTest& TestSettings::_internal_dns() const {
  return definition_case() == kDns ? *_impl_.definition_.dns_ : reinterpret_cast<::kentik::synthetics::v202101beta1::DnsTest&>(::kentik::synthetics::v202101beta1::_DnsTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::DnsTest& TestSettings::dns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.dns)
  return _internal_dns();
}
inline ::kentik::synthetics::v202101beta1::DnsTest* TestSettings::unsafe_arena_release_dns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.dns)
  if (definition_case() == kDns) {
    clear_has_definition();
    auto* temp = _impl_.definition_.dns_;
    _impl_.definition_.dns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_dns(::kentik::synthetics::v202101beta1::DnsTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_dns();
    _impl_.definition_.dns_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.dns)
}
inline ::kentik::synthetics::v202101beta1::DnsTest* TestSettings::_internal_mutable_dns() {
  if (definition_case() != kDns) {
    clear_definition();
    set_has_dns();
    _impl_.definition_.dns_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::DnsTest>(GetArena());
  }
  return _impl_.definition_.dns_;
}
inline ::kentik::synthetics::v202101beta1::DnsTest* TestSettings::mutable_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::DnsTest* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.dns)
  return _msg;
}

// .kentik.synthetics.v202101beta1.UrlTest url = 11 [json_name = "url"];
inline bool TestSettings::has_url() const {
  return definition_case() == kUrl;
}
inline bool TestSettings::_internal_has_url() const {
  return definition_case() == kUrl;
}
inline void TestSettings::set_has_url() {
  _impl_._oneof_case_[0] = kUrl;
}
inline void TestSettings::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kUrl) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.url_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.url_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::release_url() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.url)
  if (definition_case() == kUrl) {
    clear_has_definition();
    auto* temp = _impl_.definition_.url_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.url_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::UrlTest& TestSettings::_internal_url() const {
  return definition_case() == kUrl ? *_impl_.definition_.url_ : reinterpret_cast<::kentik::synthetics::v202101beta1::UrlTest&>(::kentik::synthetics::v202101beta1::_UrlTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::UrlTest& TestSettings::url() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.url)
  return _internal_url();
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.url)
  if (definition_case() == kUrl) {
    clear_has_definition();
    auto* temp = _impl_.definition_.url_;
    _impl_.definition_.url_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_url(::kentik::synthetics::v202101beta1::UrlTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_url();
    _impl_.definition_.url_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.url)
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::_internal_mutable_url() {
  if (definition_case() != kUrl) {
    clear_definition();
    set_has_url();
    _impl_.definition_.url_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::UrlTest>(GetArena());
  }
  return _impl_.definition_.url_;
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::UrlTest* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.url)
  return _msg;
}

// .kentik.synthetics.v202101beta1.GridTest network_grid = 35 [json_name = "networkGrid"];
inline bool TestSettings::has_network_grid() const {
  return definition_case() == kNetworkGrid;
}
inline bool TestSettings::_internal_has_network_grid() const {
  return definition_case() == kNetworkGrid;
}
inline void TestSettings::set_has_network_grid() {
  _impl_._oneof_case_[0] = kNetworkGrid;
}
inline void TestSettings::clear_network_grid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kNetworkGrid) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.network_grid_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.network_grid_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::GridTest* TestSettings::release_network_grid() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.network_grid)
  if (definition_case() == kNetworkGrid) {
    clear_has_definition();
    auto* temp = _impl_.definition_.network_grid_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.network_grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::GridTest& TestSettings::_internal_network_grid() const {
  return definition_case() == kNetworkGrid ? *_impl_.definition_.network_grid_ : reinterpret_cast<::kentik::synthetics::v202101beta1::GridTest&>(::kentik::synthetics::v202101beta1::_GridTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::GridTest& TestSettings::network_grid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.network_grid)
  return _internal_network_grid();
}
inline ::kentik::synthetics::v202101beta1::GridTest* TestSettings::unsafe_arena_release_network_grid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.network_grid)
  if (definition_case() == kNetworkGrid) {
    clear_has_definition();
    auto* temp = _impl_.definition_.network_grid_;
    _impl_.definition_.network_grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_network_grid(::kentik::synthetics::v202101beta1::GridTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_network_grid();
    _impl_.definition_.network_grid_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.network_grid)
}
inline ::kentik::synthetics::v202101beta1::GridTest* TestSettings::_internal_mutable_network_grid() {
  if (definition_case() != kNetworkGrid) {
    clear_definition();
    set_has_network_grid();
    _impl_.definition_.network_grid_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::GridTest>(GetArena());
  }
  return _impl_.definition_.network_grid_;
}
inline ::kentik::synthetics::v202101beta1::GridTest* TestSettings::mutable_network_grid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::GridTest* _msg = _internal_mutable_network_grid();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.network_grid)
  return _msg;
}

// .kentik.synthetics.v202101beta1.UrlTest page_load = 36 [json_name = "pageLoad"];
inline bool TestSettings::has_page_load() const {
  return definition_case() == kPageLoad;
}
inline bool TestSettings::_internal_has_page_load() const {
  return definition_case() == kPageLoad;
}
inline void TestSettings::set_has_page_load() {
  _impl_._oneof_case_[0] = kPageLoad;
}
inline void TestSettings::clear_page_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kPageLoad) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.page_load_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.page_load_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::release_page_load() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.page_load)
  if (definition_case() == kPageLoad) {
    clear_has_definition();
    auto* temp = _impl_.definition_.page_load_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.page_load_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::UrlTest& TestSettings::_internal_page_load() const {
  return definition_case() == kPageLoad ? *_impl_.definition_.page_load_ : reinterpret_cast<::kentik::synthetics::v202101beta1::UrlTest&>(::kentik::synthetics::v202101beta1::_UrlTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::UrlTest& TestSettings::page_load() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.page_load)
  return _internal_page_load();
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::unsafe_arena_release_page_load() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.page_load)
  if (definition_case() == kPageLoad) {
    clear_has_definition();
    auto* temp = _impl_.definition_.page_load_;
    _impl_.definition_.page_load_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_page_load(::kentik::synthetics::v202101beta1::UrlTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_page_load();
    _impl_.definition_.page_load_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.page_load)
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::_internal_mutable_page_load() {
  if (definition_case() != kPageLoad) {
    clear_definition();
    set_has_page_load();
    _impl_.definition_.page_load_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::UrlTest>(GetArena());
  }
  return _impl_.definition_.page_load_;
}
inline ::kentik::synthetics::v202101beta1::UrlTest* TestSettings::mutable_page_load() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::UrlTest* _msg = _internal_mutable_page_load();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.page_load)
  return _msg;
}

// .kentik.synthetics.v202101beta1.DnsGridTest dns_grid = 37 [json_name = "dnsGrid"];
inline bool TestSettings::has_dns_grid() const {
  return definition_case() == kDnsGrid;
}
inline bool TestSettings::_internal_has_dns_grid() const {
  return definition_case() == kDnsGrid;
}
inline void TestSettings::set_has_dns_grid() {
  _impl_._oneof_case_[0] = kDnsGrid;
}
inline void TestSettings::clear_dns_grid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kDnsGrid) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.dns_grid_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.dns_grid_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::DnsGridTest* TestSettings::release_dns_grid() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.dns_grid)
  if (definition_case() == kDnsGrid) {
    clear_has_definition();
    auto* temp = _impl_.definition_.dns_grid_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.dns_grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::DnsGridTest& TestSettings::_internal_dns_grid() const {
  return definition_case() == kDnsGrid ? *_impl_.definition_.dns_grid_ : reinterpret_cast<::kentik::synthetics::v202101beta1::DnsGridTest&>(::kentik::synthetics::v202101beta1::_DnsGridTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::DnsGridTest& TestSettings::dns_grid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.dns_grid)
  return _internal_dns_grid();
}
inline ::kentik::synthetics::v202101beta1::DnsGridTest* TestSettings::unsafe_arena_release_dns_grid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.dns_grid)
  if (definition_case() == kDnsGrid) {
    clear_has_definition();
    auto* temp = _impl_.definition_.dns_grid_;
    _impl_.definition_.dns_grid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_dns_grid(::kentik::synthetics::v202101beta1::DnsGridTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_dns_grid();
    _impl_.definition_.dns_grid_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.dns_grid)
}
inline ::kentik::synthetics::v202101beta1::DnsGridTest* TestSettings::_internal_mutable_dns_grid() {
  if (definition_case() != kDnsGrid) {
    clear_definition();
    set_has_dns_grid();
    _impl_.definition_.dns_grid_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::DnsGridTest>(GetArena());
  }
  return _impl_.definition_.dns_grid_;
}
inline ::kentik::synthetics::v202101beta1::DnsGridTest* TestSettings::mutable_dns_grid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::DnsGridTest* _msg = _internal_mutable_dns_grid();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.dns_grid)
  return _msg;
}

// .kentik.synthetics.v202101beta1.ApplicationMeshTest application_mesh = 38 [json_name = "applicationMesh"];
inline bool TestSettings::has_application_mesh() const {
  return definition_case() == kApplicationMesh;
}
inline bool TestSettings::_internal_has_application_mesh() const {
  return definition_case() == kApplicationMesh;
}
inline void TestSettings::set_has_application_mesh() {
  _impl_._oneof_case_[0] = kApplicationMesh;
}
inline void TestSettings::clear_application_mesh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (definition_case() == kApplicationMesh) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.application_mesh_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.definition_.application_mesh_);
    }
    clear_has_definition();
  }
}
inline ::kentik::synthetics::v202101beta1::ApplicationMeshTest* TestSettings::release_application_mesh() {
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.application_mesh)
  if (definition_case() == kApplicationMesh) {
    clear_has_definition();
    auto* temp = _impl_.definition_.application_mesh_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.application_mesh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::synthetics::v202101beta1::ApplicationMeshTest& TestSettings::_internal_application_mesh() const {
  return definition_case() == kApplicationMesh ? *_impl_.definition_.application_mesh_ : reinterpret_cast<::kentik::synthetics::v202101beta1::ApplicationMeshTest&>(::kentik::synthetics::v202101beta1::_ApplicationMeshTest_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::ApplicationMeshTest& TestSettings::application_mesh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.application_mesh)
  return _internal_application_mesh();
}
inline ::kentik::synthetics::v202101beta1::ApplicationMeshTest* TestSettings::unsafe_arena_release_application_mesh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.synthetics.v202101beta1.TestSettings.application_mesh)
  if (definition_case() == kApplicationMesh) {
    clear_has_definition();
    auto* temp = _impl_.definition_.application_mesh_;
    _impl_.definition_.application_mesh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestSettings::unsafe_arena_set_allocated_application_mesh(::kentik::synthetics::v202101beta1::ApplicationMeshTest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_application_mesh();
    _impl_.definition_.application_mesh_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.application_mesh)
}
inline ::kentik::synthetics::v202101beta1::ApplicationMeshTest* TestSettings::_internal_mutable_application_mesh() {
  if (definition_case() != kApplicationMesh) {
    clear_definition();
    set_has_application_mesh();
    _impl_.definition_.application_mesh_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::ApplicationMeshTest>(GetArena());
  }
  return _impl_.definition_.application_mesh_;
}
inline ::kentik::synthetics::v202101beta1::ApplicationMeshTest* TestSettings::mutable_application_mesh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::synthetics::v202101beta1::ApplicationMeshTest* _msg = _internal_mutable_application_mesh();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.application_mesh)
  return _msg;
}

// repeated string agent_ids = 14 [json_name = "agentIds"];
inline int TestSettings::_internal_agent_ids_size() const {
  return _internal_agent_ids().size();
}
inline int TestSettings::agent_ids_size() const {
  return _internal_agent_ids_size();
}
inline void TestSettings::clear_agent_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ids_.Clear();
}
inline std::string* TestSettings::add_agent_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_agent_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
  return _s;
}
inline const std::string& TestSettings::agent_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
  return _internal_agent_ids().Get(index);
}
inline std::string* TestSettings::mutable_agent_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
  return _internal_mutable_agent_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TestSettings::set_agent_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_agent_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
}
template <typename Arg_, typename... Args_>
inline void TestSettings::add_agent_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_agent_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestSettings::agent_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
  return _internal_agent_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestSettings::mutable_agent_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestSettings.agent_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agent_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestSettings::_internal_agent_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestSettings::_internal_mutable_agent_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agent_ids_;
}

// uint32 period = 15 [json_name = "period"];
inline void TestSettings::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0u;
}
inline ::uint32_t TestSettings::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.period)
  return _internal_period();
}
inline void TestSettings::set_period(::uint32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.period)
}
inline ::uint32_t TestSettings::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void TestSettings::_internal_set_period(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// uint32 count = 16 [json_name = "count"];
inline void TestSettings::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
}
inline ::uint32_t TestSettings::count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.count)
  return _internal_count();
}
inline void TestSettings::set_count(::uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.count)
}
inline ::uint32_t TestSettings::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void TestSettings::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// uint32 expiry = 17 [json_name = "expiry"];
inline void TestSettings::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0u;
}
inline ::uint32_t TestSettings::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.expiry)
  return _internal_expiry();
}
inline void TestSettings::set_expiry(::uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.expiry)
}
inline ::uint32_t TestSettings::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void TestSettings::_internal_set_expiry(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// uint32 limit = 18 [json_name = "limit"];
inline void TestSettings::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0u;
}
inline ::uint32_t TestSettings::limit() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.limit)
  return _internal_limit();
}
inline void TestSettings::set_limit(::uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.limit)
}
inline ::uint32_t TestSettings::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void TestSettings::_internal_set_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// repeated string tasks = 19 [json_name = "tasks"];
inline int TestSettings::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int TestSettings::tasks_size() const {
  return _internal_tasks_size();
}
inline void TestSettings::clear_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tasks_.Clear();
}
inline std::string* TestSettings::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.TestSettings.tasks)
  return _s;
}
inline const std::string& TestSettings::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.tasks)
  return _internal_tasks().Get(index);
}
inline std::string* TestSettings::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TestSettings::set_tasks(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_tasks()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.tasks)
}
template <typename Arg_, typename... Args_>
inline void TestSettings::add_tasks(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_tasks(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestSettings.tasks)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestSettings::tasks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestSettings.tasks)
  return _internal_tasks();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestSettings::mutable_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestSettings.tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestSettings::_internal_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestSettings::_internal_mutable_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tasks_;
}

// .kentik.synthetics.v202101beta1.HealthSettings health_settings = 22 [json_name = "healthSettings"];
inline bool TestSettings::has_health_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.health_settings_ != nullptr);
  return value;
}
inline void TestSettings::clear_health_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.health_settings_ != nullptr) _impl_.health_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::HealthSettings& TestSettings::_internal_health_settings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::HealthSettings* p = _impl_.health_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::HealthSettings&>(::kentik::synthetics::v202101beta1::_HealthSettings_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::HealthSettings& TestSettings::health_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.health_settings)
  return _internal_health_settings();
}
inline void TestSettings::unsafe_arena_set_allocated_health_settings(::kentik::synthetics::v202101beta1::HealthSettings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.health_settings_);
  }
  _impl_.health_settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::HealthSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.health_settings)
}
inline ::kentik::synthetics::v202101beta1::HealthSettings* TestSettings::release_health_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::HealthSettings* released = _impl_.health_settings_;
  _impl_.health_settings_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::HealthSettings* TestSettings::unsafe_arena_release_health_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.health_settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::HealthSettings* temp = _impl_.health_settings_;
  _impl_.health_settings_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::HealthSettings* TestSettings::_internal_mutable_health_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.health_settings_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::HealthSettings>(GetArena());
    _impl_.health_settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::HealthSettings*>(p);
  }
  return _impl_.health_settings_;
}
inline ::kentik::synthetics::v202101beta1::HealthSettings* TestSettings::mutable_health_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::HealthSettings* _msg = _internal_mutable_health_settings();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.health_settings)
  return _msg;
}
inline void TestSettings::set_allocated_health_settings(::kentik::synthetics::v202101beta1::HealthSettings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.health_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.health_settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::HealthSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestSettings.health_settings)
}

// .kentik.synthetics.v202101beta1.TestMonitoringSettings monitoring_settings = 24 [json_name = "monitoringSettings"];
inline bool TestSettings::has_monitoring_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.monitoring_settings_ != nullptr);
  return value;
}
inline void TestSettings::clear_monitoring_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.monitoring_settings_ != nullptr) _impl_.monitoring_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::TestMonitoringSettings& TestSettings::_internal_monitoring_settings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::TestMonitoringSettings* p = _impl_.monitoring_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::TestMonitoringSettings&>(::kentik::synthetics::v202101beta1::_TestMonitoringSettings_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TestMonitoringSettings& TestSettings::monitoring_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.monitoring_settings)
  return _internal_monitoring_settings();
}
inline void TestSettings::unsafe_arena_set_allocated_monitoring_settings(::kentik::synthetics::v202101beta1::TestMonitoringSettings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.monitoring_settings_);
  }
  _impl_.monitoring_settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestMonitoringSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.monitoring_settings)
}
inline ::kentik::synthetics::v202101beta1::TestMonitoringSettings* TestSettings::release_monitoring_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::TestMonitoringSettings* released = _impl_.monitoring_settings_;
  _impl_.monitoring_settings_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::TestMonitoringSettings* TestSettings::unsafe_arena_release_monitoring_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.monitoring_settings)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::TestMonitoringSettings* temp = _impl_.monitoring_settings_;
  _impl_.monitoring_settings_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::TestMonitoringSettings* TestSettings::_internal_mutable_monitoring_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.monitoring_settings_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TestMonitoringSettings>(GetArena());
    _impl_.monitoring_settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestMonitoringSettings*>(p);
  }
  return _impl_.monitoring_settings_;
}
inline ::kentik::synthetics::v202101beta1::TestMonitoringSettings* TestSettings::mutable_monitoring_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::TestMonitoringSettings* _msg = _internal_mutable_monitoring_settings();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.monitoring_settings)
  return _msg;
}
inline void TestSettings::set_allocated_monitoring_settings(::kentik::synthetics::v202101beta1::TestMonitoringSettings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.monitoring_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.monitoring_settings_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestMonitoringSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestSettings.monitoring_settings)
}

// .kentik.synthetics.v202101beta1.TestPingSettings ping = 28 [json_name = "ping"];
inline bool TestSettings::has_ping() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ping_ != nullptr);
  return value;
}
inline void TestSettings::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ping_ != nullptr) _impl_.ping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::synthetics::v202101beta1::TestPingSettings& TestSettings::_internal_ping() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::TestPingSettings* p = _impl_.ping_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::TestPingSettings&>(::kentik::synthetics::v202101beta1::_TestPingSettings_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TestPingSettings& TestSettings::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.ping)
  return _internal_ping();
}
inline void TestSettings::unsafe_arena_set_allocated_ping(::kentik::synthetics::v202101beta1::TestPingSettings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ping_);
  }
  _impl_.ping_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestPingSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.ping)
}
inline ::kentik::synthetics::v202101beta1::TestPingSettings* TestSettings::release_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::TestPingSettings* released = _impl_.ping_;
  _impl_.ping_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::TestPingSettings* TestSettings::unsafe_arena_release_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.ping)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::TestPingSettings* temp = _impl_.ping_;
  _impl_.ping_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::TestPingSettings* TestSettings::_internal_mutable_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ping_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TestPingSettings>(GetArena());
    _impl_.ping_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestPingSettings*>(p);
  }
  return _impl_.ping_;
}
inline ::kentik::synthetics::v202101beta1::TestPingSettings* TestSettings::mutable_ping() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::synthetics::v202101beta1::TestPingSettings* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.ping)
  return _msg;
}
inline void TestSettings::set_allocated_ping(::kentik::synthetics::v202101beta1::TestPingSettings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ping_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ping_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestPingSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestSettings.ping)
}

// .kentik.synthetics.v202101beta1.TestTraceSettings trace = 29 [json_name = "trace"];
inline bool TestSettings::has_trace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trace_ != nullptr);
  return value;
}
inline void TestSettings::clear_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trace_ != nullptr) _impl_.trace_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::kentik::synthetics::v202101beta1::TestTraceSettings& TestSettings::_internal_trace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::TestTraceSettings* p = _impl_.trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::TestTraceSettings&>(::kentik::synthetics::v202101beta1::_TestTraceSettings_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TestTraceSettings& TestSettings::trace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.trace)
  return _internal_trace();
}
inline void TestSettings::unsafe_arena_set_allocated_trace(::kentik::synthetics::v202101beta1::TestTraceSettings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trace_);
  }
  _impl_.trace_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestTraceSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.trace)
}
inline ::kentik::synthetics::v202101beta1::TestTraceSettings* TestSettings::release_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kentik::synthetics::v202101beta1::TestTraceSettings* released = _impl_.trace_;
  _impl_.trace_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::TestTraceSettings* TestSettings::unsafe_arena_release_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.trace)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kentik::synthetics::v202101beta1::TestTraceSettings* temp = _impl_.trace_;
  _impl_.trace_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::TestTraceSettings* TestSettings::_internal_mutable_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trace_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TestTraceSettings>(GetArena());
    _impl_.trace_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestTraceSettings*>(p);
  }
  return _impl_.trace_;
}
inline ::kentik::synthetics::v202101beta1::TestTraceSettings* TestSettings::mutable_trace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::kentik::synthetics::v202101beta1::TestTraceSettings* _msg = _internal_mutable_trace();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.trace)
  return _msg;
}
inline void TestSettings::set_allocated_trace(::kentik::synthetics::v202101beta1::TestTraceSettings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trace_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.trace_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TestTraceSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestSettings.trace)
}

// uint32 port = 23 [json_name = "port"];
inline void TestSettings::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0u;
}
inline ::uint32_t TestSettings::port() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.port)
  return _internal_port();
}
inline void TestSettings::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.port)
}
inline ::uint32_t TestSettings::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void TestSettings::_internal_set_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// string protocol = 26 [json_name = "protocol"];
inline void TestSettings::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& TestSettings::protocol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.protocol)
  return _internal_protocol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestSettings::set_protocol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.protocol)
}
inline std::string* TestSettings::mutable_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.protocol)
  return _s;
}
inline const std::string& TestSettings::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_.Get();
}
inline void TestSettings::_internal_set_protocol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(value, GetArena());
}
inline std::string* TestSettings::_internal_mutable_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.protocol_.Mutable( GetArena());
}
inline std::string* TestSettings::release_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.protocol)
  return _impl_.protocol_.Release();
}
inline void TestSettings::set_allocated_protocol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.protocol_.IsDefault()) {
    _impl_.protocol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestSettings.protocol)
}

// .kentik.synthetics.v202101beta1.IPFamily family = 27 [json_name = "family"];
inline void TestSettings::clear_family() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.family_ = 0;
}
inline ::kentik::synthetics::v202101beta1::IPFamily TestSettings::family() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.family)
  return _internal_family();
}
inline void TestSettings::set_family(::kentik::synthetics::v202101beta1::IPFamily value) {
  _internal_set_family(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.family)
}
inline ::kentik::synthetics::v202101beta1::IPFamily TestSettings::_internal_family() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::IPFamily>(_impl_.family_);
}
inline void TestSettings::_internal_set_family(::kentik::synthetics::v202101beta1::IPFamily value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.family_ = value;
}

// repeated string servers = 30 [json_name = "servers"];
inline int TestSettings::_internal_servers_size() const {
  return _internal_servers().size();
}
inline int TestSettings::servers_size() const {
  return _internal_servers_size();
}
inline void TestSettings::clear_servers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.servers_.Clear();
}
inline std::string* TestSettings::add_servers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_servers()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.TestSettings.servers)
  return _s;
}
inline const std::string& TestSettings::servers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.servers)
  return _internal_servers().Get(index);
}
inline std::string* TestSettings::mutable_servers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.servers)
  return _internal_mutable_servers()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TestSettings::set_servers(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_servers()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.servers)
}
template <typename Arg_, typename... Args_>
inline void TestSettings::add_servers(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_servers(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestSettings.servers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestSettings::servers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestSettings.servers)
  return _internal_servers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestSettings::mutable_servers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestSettings.servers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_servers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestSettings::_internal_servers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.servers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestSettings::_internal_mutable_servers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.servers_;
}

// bool use_local_ip = 31 [json_name = "useLocalIp"];
inline void TestSettings::clear_use_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_local_ip_ = false;
}
inline bool TestSettings::use_local_ip() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.use_local_ip)
  return _internal_use_local_ip();
}
inline void TestSettings::set_use_local_ip(bool value) {
  _internal_set_use_local_ip(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.use_local_ip)
}
inline bool TestSettings::_internal_use_local_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_local_ip_;
}
inline void TestSettings::_internal_set_use_local_ip(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_local_ip_ = value;
}

// bool reciprocal = 32 [json_name = "reciprocal"];
inline void TestSettings::clear_reciprocal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reciprocal_ = false;
}
inline bool TestSettings::reciprocal() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.reciprocal)
  return _internal_reciprocal();
}
inline void TestSettings::set_reciprocal(bool value) {
  _internal_set_reciprocal(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.reciprocal)
}
inline bool TestSettings::_internal_reciprocal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reciprocal_;
}
inline void TestSettings::_internal_set_reciprocal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reciprocal_ = value;
}

// uint32 rollup_level = 33 [json_name = "rollupLevel"];
inline void TestSettings::clear_rollup_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rollup_level_ = 0u;
}
inline ::uint32_t TestSettings::rollup_level() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.rollup_level)
  return _internal_rollup_level();
}
inline void TestSettings::set_rollup_level(::uint32_t value) {
  _internal_set_rollup_level(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestSettings.rollup_level)
}
inline ::uint32_t TestSettings::_internal_rollup_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rollup_level_;
}
inline void TestSettings::_internal_set_rollup_level(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rollup_level_ = value;
}

// .kentik.synthetics.v202101beta1.HTTPConfig http = 34 [json_name = "http"];
inline bool TestSettings::has_http() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.http_ != nullptr);
  return value;
}
inline void TestSettings::clear_http() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.http_ != nullptr) _impl_.http_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::kentik::synthetics::v202101beta1::HTTPConfig& TestSettings::_internal_http() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::HTTPConfig* p = _impl_.http_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::HTTPConfig&>(::kentik::synthetics::v202101beta1::_HTTPConfig_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::HTTPConfig& TestSettings::http() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestSettings.http)
  return _internal_http();
}
inline void TestSettings::unsafe_arena_set_allocated_http(::kentik::synthetics::v202101beta1::HTTPConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.http_);
  }
  _impl_.http_ = reinterpret_cast<::kentik::synthetics::v202101beta1::HTTPConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TestSettings.http)
}
inline ::kentik::synthetics::v202101beta1::HTTPConfig* TestSettings::release_http() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::kentik::synthetics::v202101beta1::HTTPConfig* released = _impl_.http_;
  _impl_.http_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::HTTPConfig* TestSettings::unsafe_arena_release_http() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestSettings.http)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::kentik::synthetics::v202101beta1::HTTPConfig* temp = _impl_.http_;
  _impl_.http_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::HTTPConfig* TestSettings::_internal_mutable_http() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.http_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::HTTPConfig>(GetArena());
    _impl_.http_ = reinterpret_cast<::kentik::synthetics::v202101beta1::HTTPConfig*>(p);
  }
  return _impl_.http_;
}
inline ::kentik::synthetics::v202101beta1::HTTPConfig* TestSettings::mutable_http() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::kentik::synthetics::v202101beta1::HTTPConfig* _msg = _internal_mutable_http();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestSettings.http)
  return _msg;
}
inline void TestSettings::set_allocated_http(::kentik::synthetics::v202101beta1::HTTPConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.http_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.http_ = reinterpret_cast<::kentik::synthetics::v202101beta1::HTTPConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestSettings.http)
}

inline bool TestSettings::has_definition() const {
  return definition_case() != DEFINITION_NOT_SET;
}
inline void TestSettings::clear_has_definition() {
  _impl_._oneof_case_[0] = DEFINITION_NOT_SET;
}
inline TestSettings::DefinitionCase TestSettings::definition_case() const {
  return TestSettings::DefinitionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestTraceSettings

// float period = 1 [json_name = "period"];
inline void TestTraceSettings::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0;
}
inline float TestTraceSettings::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.period)
  return _internal_period();
}
inline void TestTraceSettings::set_period(float value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.period)
}
inline float TestTraceSettings::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void TestTraceSettings::_internal_set_period(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// float count = 2 [json_name = "count"];
inline void TestTraceSettings::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0;
}
inline float TestTraceSettings::count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.count)
  return _internal_count();
}
inline void TestTraceSettings::set_count(float value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.count)
}
inline float TestTraceSettings::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void TestTraceSettings::_internal_set_count(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// string protocol = 3 [json_name = "protocol"];
inline void TestTraceSettings::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& TestTraceSettings::protocol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.protocol)
  return _internal_protocol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestTraceSettings::set_protocol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.protocol)
}
inline std::string* TestTraceSettings::mutable_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestTraceSettings.protocol)
  return _s;
}
inline const std::string& TestTraceSettings::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_.Get();
}
inline void TestTraceSettings::_internal_set_protocol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(value, GetArena());
}
inline std::string* TestTraceSettings::_internal_mutable_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.protocol_.Mutable( GetArena());
}
inline std::string* TestTraceSettings::release_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestTraceSettings.protocol)
  return _impl_.protocol_.Release();
}
inline void TestTraceSettings::set_allocated_protocol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.protocol_.IsDefault()) {
    _impl_.protocol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestTraceSettings.protocol)
}

// float port = 4 [json_name = "port"];
inline void TestTraceSettings::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline float TestTraceSettings::port() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.port)
  return _internal_port();
}
inline void TestTraceSettings::set_port(float value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.port)
}
inline float TestTraceSettings::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void TestTraceSettings::_internal_set_port(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// float expiry = 5 [json_name = "expiry"];
inline void TestTraceSettings::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0;
}
inline float TestTraceSettings::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.expiry)
  return _internal_expiry();
}
inline void TestTraceSettings::set_expiry(float value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.expiry)
}
inline float TestTraceSettings::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void TestTraceSettings::_internal_set_expiry(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// float limit = 6 [json_name = "limit"];
inline void TestTraceSettings::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0;
}
inline float TestTraceSettings::limit() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.limit)
  return _internal_limit();
}
inline void TestTraceSettings::set_limit(float value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.limit)
}
inline float TestTraceSettings::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void TestTraceSettings::_internal_set_limit(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// float delay = 7 [json_name = "delay"];
inline void TestTraceSettings::clear_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = 0;
}
inline float TestTraceSettings::delay() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestTraceSettings.delay)
  return _internal_delay();
}
inline void TestTraceSettings::set_delay(float value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestTraceSettings.delay)
}
inline float TestTraceSettings::_internal_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_;
}
inline void TestTraceSettings::_internal_set_delay(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = value;
}

// -------------------------------------------------------------------

// TestPingSettings

// float period = 1 [json_name = "period"];
inline void TestPingSettings::clear_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = 0;
}
inline float TestPingSettings::period() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestPingSettings.period)
  return _internal_period();
}
inline void TestPingSettings::set_period(float value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestPingSettings.period)
}
inline float TestPingSettings::_internal_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.period_;
}
inline void TestPingSettings::_internal_set_period(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.period_ = value;
}

// float count = 2 [json_name = "count"];
inline void TestPingSettings::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0;
}
inline float TestPingSettings::count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestPingSettings.count)
  return _internal_count();
}
inline void TestPingSettings::set_count(float value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestPingSettings.count)
}
inline float TestPingSettings::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void TestPingSettings::_internal_set_count(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// float expiry = 3 [json_name = "expiry"];
inline void TestPingSettings::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = 0;
}
inline float TestPingSettings::expiry() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestPingSettings.expiry)
  return _internal_expiry();
}
inline void TestPingSettings::set_expiry(float value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestPingSettings.expiry)
}
inline float TestPingSettings::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_;
}
inline void TestPingSettings::_internal_set_expiry(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_ = value;
}

// float delay = 4 [json_name = "delay"];
inline void TestPingSettings::clear_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = 0;
}
inline float TestPingSettings::delay() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestPingSettings.delay)
  return _internal_delay();
}
inline void TestPingSettings::set_delay(float value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestPingSettings.delay)
}
inline float TestPingSettings::_internal_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_;
}
inline void TestPingSettings::_internal_set_delay(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = value;
}

// -------------------------------------------------------------------

// TestMonitoringSettings

// string activation_grace_period = 1 [json_name = "activationGracePeriod"];
inline void TestMonitoringSettings::clear_activation_grace_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_grace_period_.ClearToEmpty();
}
inline const std::string& TestMonitoringSettings::activation_grace_period() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_grace_period)
  return _internal_activation_grace_period();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMonitoringSettings::set_activation_grace_period(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_grace_period_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_grace_period)
}
inline std::string* TestMonitoringSettings::mutable_activation_grace_period() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_activation_grace_period();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_grace_period)
  return _s;
}
inline const std::string& TestMonitoringSettings::_internal_activation_grace_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.activation_grace_period_.Get();
}
inline void TestMonitoringSettings::_internal_set_activation_grace_period(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_grace_period_.Set(value, GetArena());
}
inline std::string* TestMonitoringSettings::_internal_mutable_activation_grace_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.activation_grace_period_.Mutable( GetArena());
}
inline std::string* TestMonitoringSettings::release_activation_grace_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_grace_period)
  return _impl_.activation_grace_period_.Release();
}
inline void TestMonitoringSettings::set_allocated_activation_grace_period(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_grace_period_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.activation_grace_period_.IsDefault()) {
    _impl_.activation_grace_period_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_grace_period)
}

// string activation_time_unit = 2 [json_name = "activationTimeUnit"];
inline void TestMonitoringSettings::clear_activation_time_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_unit_.ClearToEmpty();
}
inline const std::string& TestMonitoringSettings::activation_time_unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_unit)
  return _internal_activation_time_unit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMonitoringSettings::set_activation_time_unit(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_unit)
}
inline std::string* TestMonitoringSettings::mutable_activation_time_unit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_activation_time_unit();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_unit)
  return _s;
}
inline const std::string& TestMonitoringSettings::_internal_activation_time_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.activation_time_unit_.Get();
}
inline void TestMonitoringSettings::_internal_set_activation_time_unit(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_unit_.Set(value, GetArena());
}
inline std::string* TestMonitoringSettings::_internal_mutable_activation_time_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.activation_time_unit_.Mutable( GetArena());
}
inline std::string* TestMonitoringSettings::release_activation_time_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_unit)
  return _impl_.activation_time_unit_.Release();
}
inline void TestMonitoringSettings::set_allocated_activation_time_unit(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_unit_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.activation_time_unit_.IsDefault()) {
    _impl_.activation_time_unit_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_unit)
}

// string activation_time_window = 3 [json_name = "activationTimeWindow"];
inline void TestMonitoringSettings::clear_activation_time_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_window_.ClearToEmpty();
}
inline const std::string& TestMonitoringSettings::activation_time_window() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_window)
  return _internal_activation_time_window();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMonitoringSettings::set_activation_time_window(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_window_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_window)
}
inline std::string* TestMonitoringSettings::mutable_activation_time_window() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_activation_time_window();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_window)
  return _s;
}
inline const std::string& TestMonitoringSettings::_internal_activation_time_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.activation_time_window_.Get();
}
inline void TestMonitoringSettings::_internal_set_activation_time_window(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_window_.Set(value, GetArena());
}
inline std::string* TestMonitoringSettings::_internal_mutable_activation_time_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.activation_time_window_.Mutable( GetArena());
}
inline std::string* TestMonitoringSettings::release_activation_time_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_window)
  return _impl_.activation_time_window_.Release();
}
inline void TestMonitoringSettings::set_allocated_activation_time_window(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_time_window_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.activation_time_window_.IsDefault()) {
    _impl_.activation_time_window_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_time_window)
}

// string activation_times = 4 [json_name = "activationTimes"];
inline void TestMonitoringSettings::clear_activation_times() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_times_.ClearToEmpty();
}
inline const std::string& TestMonitoringSettings::activation_times() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_times)
  return _internal_activation_times();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestMonitoringSettings::set_activation_times(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_times_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_times)
}
inline std::string* TestMonitoringSettings::mutable_activation_times() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_activation_times();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_times)
  return _s;
}
inline const std::string& TestMonitoringSettings::_internal_activation_times() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.activation_times_.Get();
}
inline void TestMonitoringSettings::_internal_set_activation_times(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_times_.Set(value, GetArena());
}
inline std::string* TestMonitoringSettings::_internal_mutable_activation_times() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.activation_times_.Mutable( GetArena());
}
inline std::string* TestMonitoringSettings::release_activation_times() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_times)
  return _impl_.activation_times_.Release();
}
inline void TestMonitoringSettings::set_allocated_activation_times(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_times_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.activation_times_.IsDefault()) {
    _impl_.activation_times_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TestMonitoringSettings.activation_times)
}

// repeated string notification_channels = 5 [json_name = "notificationChannels"];
inline int TestMonitoringSettings::_internal_notification_channels_size() const {
  return _internal_notification_channels().size();
}
inline int TestMonitoringSettings::notification_channels_size() const {
  return _internal_notification_channels_size();
}
inline void TestMonitoringSettings::clear_notification_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notification_channels_.Clear();
}
inline std::string* TestMonitoringSettings::add_notification_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_notification_channels()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
  return _s;
}
inline const std::string& TestMonitoringSettings::notification_channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
  return _internal_notification_channels().Get(index);
}
inline std::string* TestMonitoringSettings::mutable_notification_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
  return _internal_mutable_notification_channels()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TestMonitoringSettings::set_notification_channels(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_notification_channels()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
}
template <typename Arg_, typename... Args_>
inline void TestMonitoringSettings::add_notification_channels(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_notification_channels(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestMonitoringSettings::notification_channels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
  return _internal_notification_channels();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestMonitoringSettings::mutable_notification_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TestMonitoringSettings.notification_channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_notification_channels();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TestMonitoringSettings::_internal_notification_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notification_channels_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TestMonitoringSettings::_internal_mutable_notification_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.notification_channels_;
}

// -------------------------------------------------------------------

// HealthSettings

// float latency_critical = 1 [json_name = "latencyCritical"];
inline void HealthSettings::clear_latency_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_critical_ = 0;
}
inline float HealthSettings::latency_critical() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.latency_critical)
  return _internal_latency_critical();
}
inline void HealthSettings::set_latency_critical(float value) {
  _internal_set_latency_critical(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.latency_critical)
}
inline float HealthSettings::_internal_latency_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latency_critical_;
}
inline void HealthSettings::_internal_set_latency_critical(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_critical_ = value;
}

// float latency_warning = 2 [json_name = "latencyWarning"];
inline void HealthSettings::clear_latency_warning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_warning_ = 0;
}
inline float HealthSettings::latency_warning() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.latency_warning)
  return _internal_latency_warning();
}
inline void HealthSettings::set_latency_warning(float value) {
  _internal_set_latency_warning(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.latency_warning)
}
inline float HealthSettings::_internal_latency_warning() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latency_warning_;
}
inline void HealthSettings::_internal_set_latency_warning(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_warning_ = value;
}

// float packet_loss_critical = 3 [json_name = "packetLossCritical"];
inline void HealthSettings::clear_packet_loss_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_critical_ = 0;
}
inline float HealthSettings::packet_loss_critical() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.packet_loss_critical)
  return _internal_packet_loss_critical();
}
inline void HealthSettings::set_packet_loss_critical(float value) {
  _internal_set_packet_loss_critical(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.packet_loss_critical)
}
inline float HealthSettings::_internal_packet_loss_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packet_loss_critical_;
}
inline void HealthSettings::_internal_set_packet_loss_critical(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_critical_ = value;
}

// float packet_loss_warning = 4 [json_name = "packetLossWarning"];
inline void HealthSettings::clear_packet_loss_warning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_warning_ = 0;
}
inline float HealthSettings::packet_loss_warning() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.packet_loss_warning)
  return _internal_packet_loss_warning();
}
inline void HealthSettings::set_packet_loss_warning(float value) {
  _internal_set_packet_loss_warning(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.packet_loss_warning)
}
inline float HealthSettings::_internal_packet_loss_warning() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.packet_loss_warning_;
}
inline void HealthSettings::_internal_set_packet_loss_warning(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_loss_warning_ = value;
}

// float jitter_critical = 5 [json_name = "jitterCritical"];
inline void HealthSettings::clear_jitter_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_critical_ = 0;
}
inline float HealthSettings::jitter_critical() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.jitter_critical)
  return _internal_jitter_critical();
}
inline void HealthSettings::set_jitter_critical(float value) {
  _internal_set_jitter_critical(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.jitter_critical)
}
inline float HealthSettings::_internal_jitter_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jitter_critical_;
}
inline void HealthSettings::_internal_set_jitter_critical(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_critical_ = value;
}

// float jitter_warning = 6 [json_name = "jitterWarning"];
inline void HealthSettings::clear_jitter_warning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_warning_ = 0;
}
inline float HealthSettings::jitter_warning() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.jitter_warning)
  return _internal_jitter_warning();
}
inline void HealthSettings::set_jitter_warning(float value) {
  _internal_set_jitter_warning(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.jitter_warning)
}
inline float HealthSettings::_internal_jitter_warning() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jitter_warning_;
}
inline void HealthSettings::_internal_set_jitter_warning(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_warning_ = value;
}

// float http_latency_critical = 7 [json_name = "httpLatencyCritical"];
inline void HealthSettings::clear_http_latency_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_critical_ = 0;
}
inline float HealthSettings::http_latency_critical() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.http_latency_critical)
  return _internal_http_latency_critical();
}
inline void HealthSettings::set_http_latency_critical(float value) {
  _internal_set_http_latency_critical(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.http_latency_critical)
}
inline float HealthSettings::_internal_http_latency_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_latency_critical_;
}
inline void HealthSettings::_internal_set_http_latency_critical(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_critical_ = value;
}

// float http_latency_warning = 8 [json_name = "httpLatencyWarning"];
inline void HealthSettings::clear_http_latency_warning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_warning_ = 0;
}
inline float HealthSettings::http_latency_warning() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.http_latency_warning)
  return _internal_http_latency_warning();
}
inline void HealthSettings::set_http_latency_warning(float value) {
  _internal_set_http_latency_warning(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.http_latency_warning)
}
inline float HealthSettings::_internal_http_latency_warning() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_latency_warning_;
}
inline void HealthSettings::_internal_set_http_latency_warning(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_warning_ = value;
}

// repeated uint32 http_valid_codes = 9 [json_name = "httpValidCodes"];
inline int HealthSettings::_internal_http_valid_codes_size() const {
  return _internal_http_valid_codes().size();
}
inline int HealthSettings::http_valid_codes_size() const {
  return _internal_http_valid_codes_size();
}
inline void HealthSettings::clear_http_valid_codes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_valid_codes_.Clear();
}
inline ::uint32_t HealthSettings::http_valid_codes(int index) const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.http_valid_codes)
  return _internal_http_valid_codes().Get(index);
}
inline void HealthSettings::set_http_valid_codes(int index, ::uint32_t value) {
  _internal_mutable_http_valid_codes()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.http_valid_codes)
}
inline void HealthSettings::add_http_valid_codes(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_http_valid_codes()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.HealthSettings.http_valid_codes)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& HealthSettings::http_valid_codes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.HealthSettings.http_valid_codes)
  return _internal_http_valid_codes();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* HealthSettings::mutable_http_valid_codes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.HealthSettings.http_valid_codes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_http_valid_codes();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
HealthSettings::_internal_http_valid_codes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_valid_codes_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* HealthSettings::_internal_mutable_http_valid_codes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.http_valid_codes_;
}

// repeated uint32 dns_valid_codes = 10 [json_name = "dnsValidCodes"];
inline int HealthSettings::_internal_dns_valid_codes_size() const {
  return _internal_dns_valid_codes().size();
}
inline int HealthSettings::dns_valid_codes_size() const {
  return _internal_dns_valid_codes_size();
}
inline void HealthSettings::clear_dns_valid_codes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dns_valid_codes_.Clear();
}
inline ::uint32_t HealthSettings::dns_valid_codes(int index) const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.dns_valid_codes)
  return _internal_dns_valid_codes().Get(index);
}
inline void HealthSettings::set_dns_valid_codes(int index, ::uint32_t value) {
  _internal_mutable_dns_valid_codes()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.dns_valid_codes)
}
inline void HealthSettings::add_dns_valid_codes(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_dns_valid_codes()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.HealthSettings.dns_valid_codes)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& HealthSettings::dns_valid_codes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.HealthSettings.dns_valid_codes)
  return _internal_dns_valid_codes();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* HealthSettings::mutable_dns_valid_codes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.HealthSettings.dns_valid_codes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dns_valid_codes();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
HealthSettings::_internal_dns_valid_codes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dns_valid_codes_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* HealthSettings::_internal_mutable_dns_valid_codes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dns_valid_codes_;
}

// float latency_critical_stddev = 11 [json_name = "latencyCriticalStddev"];
inline void HealthSettings::clear_latency_critical_stddev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_critical_stddev_ = 0;
}
inline float HealthSettings::latency_critical_stddev() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.latency_critical_stddev)
  return _internal_latency_critical_stddev();
}
inline void HealthSettings::set_latency_critical_stddev(float value) {
  _internal_set_latency_critical_stddev(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.latency_critical_stddev)
}
inline float HealthSettings::_internal_latency_critical_stddev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latency_critical_stddev_;
}
inline void HealthSettings::_internal_set_latency_critical_stddev(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_critical_stddev_ = value;
}

// float latency_warning_stddev = 12 [json_name = "latencyWarningStddev"];
inline void HealthSettings::clear_latency_warning_stddev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_warning_stddev_ = 0;
}
inline float HealthSettings::latency_warning_stddev() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.latency_warning_stddev)
  return _internal_latency_warning_stddev();
}
inline void HealthSettings::set_latency_warning_stddev(float value) {
  _internal_set_latency_warning_stddev(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.latency_warning_stddev)
}
inline float HealthSettings::_internal_latency_warning_stddev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latency_warning_stddev_;
}
inline void HealthSettings::_internal_set_latency_warning_stddev(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_warning_stddev_ = value;
}

// float jitter_critical_stddev = 13 [json_name = "jitterCriticalStddev"];
inline void HealthSettings::clear_jitter_critical_stddev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_critical_stddev_ = 0;
}
inline float HealthSettings::jitter_critical_stddev() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.jitter_critical_stddev)
  return _internal_jitter_critical_stddev();
}
inline void HealthSettings::set_jitter_critical_stddev(float value) {
  _internal_set_jitter_critical_stddev(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.jitter_critical_stddev)
}
inline float HealthSettings::_internal_jitter_critical_stddev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jitter_critical_stddev_;
}
inline void HealthSettings::_internal_set_jitter_critical_stddev(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_critical_stddev_ = value;
}

// float jitter_warning_stddev = 14 [json_name = "jitterWarningStddev"];
inline void HealthSettings::clear_jitter_warning_stddev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_warning_stddev_ = 0;
}
inline float HealthSettings::jitter_warning_stddev() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.jitter_warning_stddev)
  return _internal_jitter_warning_stddev();
}
inline void HealthSettings::set_jitter_warning_stddev(float value) {
  _internal_set_jitter_warning_stddev(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.jitter_warning_stddev)
}
inline float HealthSettings::_internal_jitter_warning_stddev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jitter_warning_stddev_;
}
inline void HealthSettings::_internal_set_jitter_warning_stddev(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jitter_warning_stddev_ = value;
}

// float http_latency_critical_stddev = 15 [json_name = "httpLatencyCriticalStddev"];
inline void HealthSettings::clear_http_latency_critical_stddev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_critical_stddev_ = 0;
}
inline float HealthSettings::http_latency_critical_stddev() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.http_latency_critical_stddev)
  return _internal_http_latency_critical_stddev();
}
inline void HealthSettings::set_http_latency_critical_stddev(float value) {
  _internal_set_http_latency_critical_stddev(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.http_latency_critical_stddev)
}
inline float HealthSettings::_internal_http_latency_critical_stddev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_latency_critical_stddev_;
}
inline void HealthSettings::_internal_set_http_latency_critical_stddev(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_critical_stddev_ = value;
}

// float http_latency_warning_stddev = 16 [json_name = "httpLatencyWarningStddev"];
inline void HealthSettings::clear_http_latency_warning_stddev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_warning_stddev_ = 0;
}
inline float HealthSettings::http_latency_warning_stddev() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HealthSettings.http_latency_warning_stddev)
  return _internal_http_latency_warning_stddev();
}
inline void HealthSettings::set_http_latency_warning_stddev(float value) {
  _internal_set_http_latency_warning_stddev(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HealthSettings.http_latency_warning_stddev)
}
inline float HealthSettings::_internal_http_latency_warning_stddev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_latency_warning_stddev_;
}
inline void HealthSettings::_internal_set_http_latency_warning_stddev(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_latency_warning_stddev_ = value;
}

// -------------------------------------------------------------------

// HostnameTest

// string target = 1 [json_name = "target"];
inline void HostnameTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& HostnameTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.HostnameTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HostnameTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.HostnameTest.target)
}
inline std::string* HostnameTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.HostnameTest.target)
  return _s;
}
inline const std::string& HostnameTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void HostnameTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* HostnameTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* HostnameTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.HostnameTest.target)
  return _impl_.target_.Release();
}
inline void HostnameTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.HostnameTest.target)
}

// -------------------------------------------------------------------

// IpTest

// repeated string targets = 1 [json_name = "targets"];
inline int IpTest::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int IpTest::targets_size() const {
  return _internal_targets_size();
}
inline void IpTest::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline std::string* IpTest::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.IpTest.targets)
  return _s;
}
inline const std::string& IpTest::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IpTest.targets)
  return _internal_targets().Get(index);
}
inline std::string* IpTest::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IpTest.targets)
  return _internal_mutable_targets()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void IpTest::set_targets(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_targets()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IpTest.targets)
}
template <typename Arg_, typename... Args_>
inline void IpTest::add_targets(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_targets(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.IpTest.targets)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
IpTest::targets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.IpTest.targets)
  return _internal_targets();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
IpTest::mutable_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.IpTest.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
IpTest::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
IpTest::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// AgentTest

// string target = 1 [json_name = "target"];
inline void AgentTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& AgentTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.AgentTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AgentTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.AgentTest.target)
}
inline std::string* AgentTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.AgentTest.target)
  return _s;
}
inline const std::string& AgentTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void AgentTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* AgentTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* AgentTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.AgentTest.target)
  return _impl_.target_.Release();
}
inline void AgentTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.AgentTest.target)
}

// -------------------------------------------------------------------

// FlowTest

// string target = 1 [json_name = "target"];
inline void FlowTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& FlowTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.FlowTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.FlowTest.target)
}
inline std::string* FlowTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.FlowTest.target)
  return _s;
}
inline const std::string& FlowTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void FlowTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* FlowTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* FlowTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.FlowTest.target)
  return _impl_.target_.Release();
}
inline void FlowTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.FlowTest.target)
}

// uint32 target_refresh_interval_millis = 2 [json_name = "targetRefreshIntervalMillis"];
inline void FlowTest::clear_target_refresh_interval_millis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_refresh_interval_millis_ = 0u;
}
inline ::uint32_t FlowTest::target_refresh_interval_millis() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.FlowTest.target_refresh_interval_millis)
  return _internal_target_refresh_interval_millis();
}
inline void FlowTest::set_target_refresh_interval_millis(::uint32_t value) {
  _internal_set_target_refresh_interval_millis(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.FlowTest.target_refresh_interval_millis)
}
inline ::uint32_t FlowTest::_internal_target_refresh_interval_millis() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_refresh_interval_millis_;
}
inline void FlowTest::_internal_set_target_refresh_interval_millis(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_refresh_interval_millis_ = value;
}

// uint32 max_tasks = 3 [json_name = "maxTasks"];
inline void FlowTest::clear_max_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_tasks_ = 0u;
}
inline ::uint32_t FlowTest::max_tasks() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.FlowTest.max_tasks)
  return _internal_max_tasks();
}
inline void FlowTest::set_max_tasks(::uint32_t value) {
  _internal_set_max_tasks(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.FlowTest.max_tasks)
}
inline ::uint32_t FlowTest::_internal_max_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_tasks_;
}
inline void FlowTest::_internal_set_max_tasks(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_tasks_ = value;
}

// string type = 4 [json_name = "type"];
inline void FlowTest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& FlowTest::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.FlowTest.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowTest::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.FlowTest.type)
}
inline std::string* FlowTest::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.FlowTest.type)
  return _s;
}
inline const std::string& FlowTest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void FlowTest::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* FlowTest::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* FlowTest::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.FlowTest.type)
  return _impl_.type_.Release();
}
inline void FlowTest::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.FlowTest.type)
}

// string inet_direction = 5 [json_name = "inetDirection"];
inline void FlowTest::clear_inet_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_direction_.ClearToEmpty();
}
inline const std::string& FlowTest::inet_direction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.FlowTest.inet_direction)
  return _internal_inet_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowTest::set_inet_direction(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_direction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.FlowTest.inet_direction)
}
inline std::string* FlowTest::mutable_inet_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_inet_direction();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.FlowTest.inet_direction)
  return _s;
}
inline const std::string& FlowTest::_internal_inet_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inet_direction_.Get();
}
inline void FlowTest::_internal_set_inet_direction(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_direction_.Set(value, GetArena());
}
inline std::string* FlowTest::_internal_mutable_inet_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.inet_direction_.Mutable( GetArena());
}
inline std::string* FlowTest::release_inet_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.FlowTest.inet_direction)
  return _impl_.inet_direction_.Release();
}
inline void FlowTest::set_allocated_inet_direction(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_direction_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.inet_direction_.IsDefault()) {
    _impl_.inet_direction_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.FlowTest.inet_direction)
}

// string direction = 6 [json_name = "direction"];
inline void FlowTest::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& FlowTest::direction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.FlowTest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowTest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.FlowTest.direction)
}
inline std::string* FlowTest::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.FlowTest.direction)
  return _s;
}
inline const std::string& FlowTest::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.direction_.Get();
}
inline void FlowTest::_internal_set_direction(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_.Set(value, GetArena());
}
inline std::string* FlowTest::_internal_mutable_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.direction_.Mutable( GetArena());
}
inline std::string* FlowTest::release_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.FlowTest.direction)
  return _impl_.direction_.Release();
}
inline void FlowTest::set_allocated_direction(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.direction_.IsDefault()) {
    _impl_.direction_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.FlowTest.direction)
}

// -------------------------------------------------------------------

// SiteTest

// string target = 1 [json_name = "target"];
inline void SiteTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& SiteTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.SiteTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SiteTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.SiteTest.target)
}
inline std::string* SiteTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.SiteTest.target)
  return _s;
}
inline const std::string& SiteTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void SiteTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* SiteTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* SiteTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.SiteTest.target)
  return _impl_.target_.Release();
}
inline void SiteTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.SiteTest.target)
}

// -------------------------------------------------------------------

// TagTest

// string target = 1 [json_name = "target"];
inline void TagTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& TagTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TagTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TagTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TagTest.target)
}
inline std::string* TagTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TagTest.target)
  return _s;
}
inline const std::string& TagTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void TagTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* TagTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* TagTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TagTest.target)
  return _impl_.target_.Release();
}
inline void TagTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TagTest.target)
}

// -------------------------------------------------------------------

// DnsTest

// string target = 1 [json_name = "target"];
inline void DnsTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& DnsTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DnsTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DnsTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DnsTest.target)
}
inline std::string* DnsTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DnsTest.target)
  return _s;
}
inline const std::string& DnsTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void DnsTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* DnsTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* DnsTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DnsTest.target)
  return _impl_.target_.Release();
}
inline void DnsTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DnsTest.target)
}

// .kentik.synthetics.v202101beta1.DNSRecord type = 2 [json_name = "type"];
inline void DnsTest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::kentik::synthetics::v202101beta1::DNSRecord DnsTest::type() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DnsTest.type)
  return _internal_type();
}
inline void DnsTest::set_type(::kentik::synthetics::v202101beta1::DNSRecord value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DnsTest.type)
}
inline ::kentik::synthetics::v202101beta1::DNSRecord DnsTest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::DNSRecord>(_impl_.type_);
}
inline void DnsTest::_internal_set_type(::kentik::synthetics::v202101beta1::DNSRecord value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// UrlTest

// string target = 1 [json_name = "target"];
inline void UrlTest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& UrlTest::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.UrlTest.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UrlTest::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.UrlTest.target)
}
inline std::string* UrlTest::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.UrlTest.target)
  return _s;
}
inline const std::string& UrlTest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void UrlTest::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* UrlTest::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* UrlTest::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.UrlTest.target)
  return _impl_.target_.Release();
}
inline void UrlTest::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.UrlTest.target)
}

// -------------------------------------------------------------------

// GridTest

// repeated string targets = 1 [json_name = "targets"];
inline int GridTest::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int GridTest::targets_size() const {
  return _internal_targets_size();
}
inline void GridTest::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline std::string* GridTest::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.GridTest.targets)
  return _s;
}
inline const std::string& GridTest::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GridTest.targets)
  return _internal_targets().Get(index);
}
inline std::string* GridTest::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GridTest.targets)
  return _internal_mutable_targets()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GridTest::set_targets(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_targets()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GridTest.targets)
}
template <typename Arg_, typename... Args_>
inline void GridTest::add_targets(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_targets(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GridTest.targets)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GridTest::targets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GridTest.targets)
  return _internal_targets();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GridTest::mutable_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GridTest.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GridTest::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GridTest::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// DnsGridTest

// repeated string targets = 1 [json_name = "targets"];
inline int DnsGridTest::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int DnsGridTest::targets_size() const {
  return _internal_targets_size();
}
inline void DnsGridTest::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline std::string* DnsGridTest::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.DnsGridTest.targets)
  return _s;
}
inline const std::string& DnsGridTest::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DnsGridTest.targets)
  return _internal_targets().Get(index);
}
inline std::string* DnsGridTest::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DnsGridTest.targets)
  return _internal_mutable_targets()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DnsGridTest::set_targets(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_targets()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DnsGridTest.targets)
}
template <typename Arg_, typename... Args_>
inline void DnsGridTest::add_targets(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_targets(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.DnsGridTest.targets)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DnsGridTest::targets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.DnsGridTest.targets)
  return _internal_targets();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DnsGridTest::mutable_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.DnsGridTest.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DnsGridTest::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DnsGridTest::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// .kentik.synthetics.v202101beta1.DNSRecord type = 2 [json_name = "type"];
inline void DnsGridTest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::kentik::synthetics::v202101beta1::DNSRecord DnsGridTest::type() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DnsGridTest.type)
  return _internal_type();
}
inline void DnsGridTest::set_type(::kentik::synthetics::v202101beta1::DNSRecord value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DnsGridTest.type)
}
inline ::kentik::synthetics::v202101beta1::DNSRecord DnsGridTest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::DNSRecord>(_impl_.type_);
}
inline void DnsGridTest::_internal_set_type(::kentik::synthetics::v202101beta1::DNSRecord value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// ApplicationMeshTest

// -------------------------------------------------------------------

// MeshResponse

// string id = 1 [json_name = "id"];
inline void MeshResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& MeshResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshResponse.id)
}
inline std::string* MeshResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshResponse.id)
  return _s;
}
inline const std::string& MeshResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void MeshResponse::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* MeshResponse::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* MeshResponse::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshResponse.id)
  return _impl_.id_.Release();
}
inline void MeshResponse::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshResponse.id)
}

// string name = 2 [json_name = "name"];
inline void MeshResponse::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MeshResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshResponse.name)
}
inline std::string* MeshResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshResponse.name)
  return _s;
}
inline const std::string& MeshResponse::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MeshResponse::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MeshResponse::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MeshResponse::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshResponse.name)
  return _impl_.name_.Release();
}
inline void MeshResponse::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshResponse.name)
}

// string local_ip = 3 [json_name = "localIp"];
inline void MeshResponse::clear_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.ClearToEmpty();
}
inline const std::string& MeshResponse::local_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshResponse.local_ip)
  return _internal_local_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshResponse::set_local_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshResponse.local_ip)
}
inline std::string* MeshResponse::mutable_local_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshResponse.local_ip)
  return _s;
}
inline const std::string& MeshResponse::_internal_local_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_ip_.Get();
}
inline void MeshResponse::_internal_set_local_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.Set(value, GetArena());
}
inline std::string* MeshResponse::_internal_mutable_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_ip_.Mutable( GetArena());
}
inline std::string* MeshResponse::release_local_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshResponse.local_ip)
  return _impl_.local_ip_.Release();
}
inline void MeshResponse::set_allocated_local_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.local_ip_.IsDefault()) {
    _impl_.local_ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshResponse.local_ip)
}

// string ip = 4 [json_name = "ip"];
inline void MeshResponse::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& MeshResponse::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshResponse.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshResponse::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshResponse.ip)
}
inline std::string* MeshResponse::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshResponse.ip)
  return _s;
}
inline const std::string& MeshResponse::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_.Get();
}
inline void MeshResponse::_internal_set_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* MeshResponse::_internal_mutable_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* MeshResponse::release_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshResponse.ip)
  return _impl_.ip_.Release();
}
inline void MeshResponse::set_allocated_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshResponse.ip)
}

// string alias = 5 [json_name = "alias"];
inline void MeshResponse::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& MeshResponse::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshResponse.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshResponse::set_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshResponse.alias)
}
inline std::string* MeshResponse::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshResponse.alias)
  return _s;
}
inline const std::string& MeshResponse::_internal_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_.Get();
}
inline void MeshResponse::_internal_set_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* MeshResponse::_internal_mutable_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* MeshResponse::release_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshResponse.alias)
  return _impl_.alias_.Release();
}
inline void MeshResponse::set_allocated_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshResponse.alias)
}

// repeated .kentik.synthetics.v202101beta1.MeshColumn columns = 6 [json_name = "columns"];
inline int MeshResponse::_internal_columns_size() const {
  return _internal_columns().size();
}
inline int MeshResponse::columns_size() const {
  return _internal_columns_size();
}
inline void MeshResponse::clear_columns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.columns_.Clear();
}
inline ::kentik::synthetics::v202101beta1::MeshColumn* MeshResponse::mutable_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshResponse.columns)
  return _internal_mutable_columns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>* MeshResponse::mutable_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.MeshResponse.columns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_columns();
}
inline const ::kentik::synthetics::v202101beta1::MeshColumn& MeshResponse::columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshResponse.columns)
  return _internal_columns().Get(index);
}
inline ::kentik::synthetics::v202101beta1::MeshColumn* MeshResponse::add_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::MeshColumn* _add = _internal_mutable_columns()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.MeshResponse.columns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>& MeshResponse::columns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.MeshResponse.columns)
  return _internal_columns();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>&
MeshResponse::_internal_columns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.columns_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshColumn>*
MeshResponse::_internal_mutable_columns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.columns_;
}

// -------------------------------------------------------------------

// MeshColumn

// string id = 1 [json_name = "id"];
inline void MeshColumn::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& MeshColumn::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshColumn.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshColumn::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshColumn.id)
}
inline std::string* MeshColumn::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshColumn.id)
  return _s;
}
inline const std::string& MeshColumn::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void MeshColumn::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* MeshColumn::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* MeshColumn::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshColumn.id)
  return _impl_.id_.Release();
}
inline void MeshColumn::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshColumn.id)
}

// string name = 2 [json_name = "name"];
inline void MeshColumn::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MeshColumn::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshColumn.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshColumn::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshColumn.name)
}
inline std::string* MeshColumn::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshColumn.name)
  return _s;
}
inline const std::string& MeshColumn::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MeshColumn::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MeshColumn::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MeshColumn::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshColumn.name)
  return _impl_.name_.Release();
}
inline void MeshColumn::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshColumn.name)
}

// string alias = 3 [json_name = "alias"];
inline void MeshColumn::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& MeshColumn::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshColumn.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshColumn::set_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshColumn.alias)
}
inline std::string* MeshColumn::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshColumn.alias)
  return _s;
}
inline const std::string& MeshColumn::_internal_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_.Get();
}
inline void MeshColumn::_internal_set_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* MeshColumn::_internal_mutable_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* MeshColumn::release_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshColumn.alias)
  return _impl_.alias_.Release();
}
inline void MeshColumn::set_allocated_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshColumn.alias)
}

// string target = 4 [json_name = "target"];
inline void MeshColumn::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.ClearToEmpty();
}
inline const std::string& MeshColumn::target() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshColumn.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshColumn::set_target(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshColumn.target)
}
inline std::string* MeshColumn::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshColumn.target)
  return _s;
}
inline const std::string& MeshColumn::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_.Get();
}
inline void MeshColumn::_internal_set_target(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.Set(value, GetArena());
}
inline std::string* MeshColumn::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_.Mutable( GetArena());
}
inline std::string* MeshColumn::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshColumn.target)
  return _impl_.target_.Release();
}
inline void MeshColumn::set_allocated_target(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshColumn.target)
}

// .kentik.synthetics.v202101beta1.MeshMetrics metrics = 5 [json_name = "metrics"];
inline bool MeshColumn::has_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metrics_ != nullptr);
  return value;
}
inline void MeshColumn::clear_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metrics_ != nullptr) _impl_.metrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::MeshMetrics& MeshColumn::_internal_metrics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::MeshMetrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::MeshMetrics&>(::kentik::synthetics::v202101beta1::_MeshMetrics_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::MeshMetrics& MeshColumn::metrics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshColumn.metrics)
  return _internal_metrics();
}
inline void MeshColumn::unsafe_arena_set_allocated_metrics(::kentik::synthetics::v202101beta1::MeshMetrics* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetrics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.MeshColumn.metrics)
}
inline ::kentik::synthetics::v202101beta1::MeshMetrics* MeshColumn::release_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::MeshMetrics* released = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::MeshMetrics* MeshColumn::unsafe_arena_release_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshColumn.metrics)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::MeshMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::MeshMetrics* MeshColumn::_internal_mutable_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metrics_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::MeshMetrics>(GetArena());
    _impl_.metrics_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetrics*>(p);
  }
  return _impl_.metrics_;
}
inline ::kentik::synthetics::v202101beta1::MeshMetrics* MeshColumn::mutable_metrics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::MeshMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshColumn.metrics)
  return _msg;
}
inline void MeshColumn::set_allocated_metrics(::kentik::synthetics::v202101beta1::MeshMetrics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.metrics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metrics_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetrics*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshColumn.metrics)
}

// repeated .kentik.synthetics.v202101beta1.MeshMetrics health = 6 [json_name = "health"];
inline int MeshColumn::_internal_health_size() const {
  return _internal_health().size();
}
inline int MeshColumn::health_size() const {
  return _internal_health_size();
}
inline void MeshColumn::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Clear();
}
inline ::kentik::synthetics::v202101beta1::MeshMetrics* MeshColumn::mutable_health(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshColumn.health)
  return _internal_mutable_health()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>* MeshColumn::mutable_health()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.MeshColumn.health)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_health();
}
inline const ::kentik::synthetics::v202101beta1::MeshMetrics& MeshColumn::health(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshColumn.health)
  return _internal_health().Get(index);
}
inline ::kentik::synthetics::v202101beta1::MeshMetrics* MeshColumn::add_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::MeshMetrics* _add = _internal_mutable_health()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.MeshColumn.health)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>& MeshColumn::health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.MeshColumn.health)
  return _internal_health();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>&
MeshColumn::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::MeshMetrics>*
MeshColumn::_internal_mutable_health() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.health_;
}

// -------------------------------------------------------------------

// MeshMetric

// string name = 1 [json_name = "name"];
inline void MeshMetric::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MeshMetric::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetric.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshMetric::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshMetric.name)
}
inline std::string* MeshMetric::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshMetric.name)
  return _s;
}
inline const std::string& MeshMetric::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MeshMetric::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MeshMetric::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MeshMetric::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshMetric.name)
  return _impl_.name_.Release();
}
inline void MeshMetric::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshMetric.name)
}

// string health = 2 [json_name = "health"];
inline void MeshMetric::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.ClearToEmpty();
}
inline const std::string& MeshMetric::health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetric.health)
  return _internal_health();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MeshMetric::set_health(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshMetric.health)
}
inline std::string* MeshMetric::mutable_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_health();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshMetric.health)
  return _s;
}
inline const std::string& MeshMetric::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_.Get();
}
inline void MeshMetric::_internal_set_health(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Set(value, GetArena());
}
inline std::string* MeshMetric::_internal_mutable_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.health_.Mutable( GetArena());
}
inline std::string* MeshMetric::release_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshMetric.health)
  return _impl_.health_.Release();
}
inline void MeshMetric::set_allocated_health(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.health_.IsDefault()) {
    _impl_.health_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshMetric.health)
}

// int64 value = 3 [json_name = "value"];
inline void MeshMetric::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = ::int64_t{0};
}
inline ::int64_t MeshMetric::value() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetric.value)
  return _internal_value();
}
inline void MeshMetric::set_value(::int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.MeshMetric.value)
}
inline ::int64_t MeshMetric::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void MeshMetric::_internal_set_value(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// MeshMetrics

// .google.protobuf.Timestamp time = 1 [json_name = "time"];
inline bool MeshMetrics::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& MeshMetrics::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& MeshMetrics::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetrics.time)
  return _internal_time();
}
inline void MeshMetrics::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.time)
}
inline ::google::protobuf::Timestamp* MeshMetrics::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* MeshMetrics::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshMetrics.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* MeshMetrics::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* MeshMetrics::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshMetrics.time)
  return _msg;
}
inline void MeshMetrics::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.time)
}

// .kentik.synthetics.v202101beta1.MeshMetric latency = 2 [json_name = "latency"];
inline bool MeshMetrics::has_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latency_ != nullptr);
  return value;
}
inline void MeshMetrics::clear_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.latency_ != nullptr) _impl_.latency_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::MeshMetric& MeshMetrics::_internal_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::MeshMetric* p = _impl_.latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::MeshMetric&>(::kentik::synthetics::v202101beta1::_MeshMetric_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::MeshMetric& MeshMetrics::latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetrics.latency)
  return _internal_latency();
}
inline void MeshMetrics::unsafe_arena_set_allocated_latency(::kentik::synthetics::v202101beta1::MeshMetric* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latency_);
  }
  _impl_.latency_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.latency)
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::release_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::MeshMetric* released = _impl_.latency_;
  _impl_.latency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::unsafe_arena_release_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshMetrics.latency)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::MeshMetric* temp = _impl_.latency_;
  _impl_.latency_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::_internal_mutable_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::MeshMetric>(GetArena());
    _impl_.latency_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(p);
  }
  return _impl_.latency_;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::mutable_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::MeshMetric* _msg = _internal_mutable_latency();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshMetrics.latency)
  return _msg;
}
inline void MeshMetrics::set_allocated_latency(::kentik::synthetics::v202101beta1::MeshMetric* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.latency_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.latency)
}

// .kentik.synthetics.v202101beta1.MeshMetric packet_loss = 3 [json_name = "packetLoss"];
inline bool MeshMetrics::has_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_loss_ != nullptr);
  return value;
}
inline void MeshMetrics::clear_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.packet_loss_ != nullptr) _impl_.packet_loss_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::synthetics::v202101beta1::MeshMetric& MeshMetrics::_internal_packet_loss() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::MeshMetric* p = _impl_.packet_loss_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::MeshMetric&>(::kentik::synthetics::v202101beta1::_MeshMetric_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::MeshMetric& MeshMetrics::packet_loss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetrics.packet_loss)
  return _internal_packet_loss();
}
inline void MeshMetrics::unsafe_arena_set_allocated_packet_loss(::kentik::synthetics::v202101beta1::MeshMetric* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_loss_);
  }
  _impl_.packet_loss_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.packet_loss)
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::release_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::MeshMetric* released = _impl_.packet_loss_;
  _impl_.packet_loss_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::unsafe_arena_release_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshMetrics.packet_loss)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::MeshMetric* temp = _impl_.packet_loss_;
  _impl_.packet_loss_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::_internal_mutable_packet_loss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.packet_loss_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::MeshMetric>(GetArena());
    _impl_.packet_loss_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(p);
  }
  return _impl_.packet_loss_;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::mutable_packet_loss() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::synthetics::v202101beta1::MeshMetric* _msg = _internal_mutable_packet_loss();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshMetrics.packet_loss)
  return _msg;
}
inline void MeshMetrics::set_allocated_packet_loss(::kentik::synthetics::v202101beta1::MeshMetric* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.packet_loss_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.packet_loss_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.packet_loss)
}

// .kentik.synthetics.v202101beta1.MeshMetric jitter = 4 [json_name = "jitter"];
inline bool MeshMetrics::has_jitter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.jitter_ != nullptr);
  return value;
}
inline void MeshMetrics::clear_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.jitter_ != nullptr) _impl_.jitter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::kentik::synthetics::v202101beta1::MeshMetric& MeshMetrics::_internal_jitter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::MeshMetric* p = _impl_.jitter_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::MeshMetric&>(::kentik::synthetics::v202101beta1::_MeshMetric_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::MeshMetric& MeshMetrics::jitter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.MeshMetrics.jitter)
  return _internal_jitter();
}
inline void MeshMetrics::unsafe_arena_set_allocated_jitter(::kentik::synthetics::v202101beta1::MeshMetric* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.jitter_);
  }
  _impl_.jitter_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.jitter)
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::release_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kentik::synthetics::v202101beta1::MeshMetric* released = _impl_.jitter_;
  _impl_.jitter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::unsafe_arena_release_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.MeshMetrics.jitter)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kentik::synthetics::v202101beta1::MeshMetric* temp = _impl_.jitter_;
  _impl_.jitter_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::_internal_mutable_jitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.jitter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::MeshMetric>(GetArena());
    _impl_.jitter_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(p);
  }
  return _impl_.jitter_;
}
inline ::kentik::synthetics::v202101beta1::MeshMetric* MeshMetrics::mutable_jitter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::kentik::synthetics::v202101beta1::MeshMetric* _msg = _internal_mutable_jitter();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.MeshMetrics.jitter)
  return _msg;
}
inline void MeshMetrics::set_allocated_jitter(::kentik::synthetics::v202101beta1::MeshMetric* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.jitter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.jitter_ = reinterpret_cast<::kentik::synthetics::v202101beta1::MeshMetric*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.MeshMetrics.jitter)
}

// -------------------------------------------------------------------

// ASN

// uint32 id = 1 [json_name = "id"];
inline void ASN::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t ASN::id() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ASN.id)
  return _internal_id();
}
inline void ASN::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ASN.id)
}
inline ::uint32_t ASN::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void ASN::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string name = 2 [json_name = "name"];
inline void ASN::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ASN::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ASN.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ASN::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ASN.name)
}
inline std::string* ASN::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.ASN.name)
  return _s;
}
inline const std::string& ASN::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ASN::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ASN::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ASN::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.ASN.name)
  return _impl_.name_.Release();
}
inline void ASN::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.ASN.name)
}

// -------------------------------------------------------------------

// Country

// string code = 1 [json_name = "code"];
inline void Country::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
}
inline const std::string& Country::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Country.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Country::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Country.code)
}
inline std::string* Country::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Country.code)
  return _s;
}
inline const std::string& Country::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void Country::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(value, GetArena());
}
inline std::string* Country::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* Country::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Country.code)
  return _impl_.code_.Release();
}
inline void Country::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Country.code)
}

// string name = 2 [json_name = "name"];
inline void Country::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Country::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Country.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Country::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Country.name)
}
inline std::string* Country::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Country.name)
  return _s;
}
inline const std::string& Country::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Country::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Country::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Country::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Country.name)
  return _impl_.name_.Release();
}
inline void Country::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Country.name)
}

// -------------------------------------------------------------------

// Region

// int64 id = 1 [json_name = "id"];
inline void Region::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t Region::id() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Region.id)
  return _internal_id();
}
inline void Region::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Region.id)
}
inline ::int64_t Region::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Region::_internal_set_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string name = 2 [json_name = "name"];
inline void Region::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Region::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Region.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Region::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Region.name)
}
inline std::string* Region::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Region.name)
  return _s;
}
inline const std::string& Region::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Region::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Region::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Region::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Region.name)
  return _impl_.name_.Release();
}
inline void Region::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Region.name)
}

// -------------------------------------------------------------------

// City

// string id = 1 [json_name = "id"];
inline void City::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& City::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.City.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void City::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.City.id)
}
inline std::string* City::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.City.id)
  return _s;
}
inline const std::string& City::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void City::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* City::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* City::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.City.id)
  return _impl_.id_.Release();
}
inline void City::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.City.id)
}

// string name = 2 [json_name = "name"];
inline void City::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& City::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.City.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void City::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.City.name)
}
inline std::string* City::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.City.name)
  return _s;
}
inline const std::string& City::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void City::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* City::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* City::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.City.name)
  return _impl_.name_.Release();
}
inline void City::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.City.name)
}

// double latitude = 8 [json_name = "latitude"];
inline void City::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = 0;
}
inline double City::latitude() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.City.latitude)
  return _internal_latitude();
}
inline void City::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.City.latitude)
}
inline double City::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_;
}
inline void City::_internal_set_latitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = value;
}

// double longitude = 9 [json_name = "longitude"];
inline void City::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = 0;
}
inline double City::longitude() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.City.longitude)
  return _internal_longitude();
}
inline void City::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.City.longitude)
}
inline double City::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_;
}
inline void City::_internal_set_longitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = value;
}

// -------------------------------------------------------------------

// Geo

// .kentik.synthetics.v202101beta1.Country country = 1 [json_name = "country"];
inline bool Geo::has_country() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.country_ != nullptr);
  return value;
}
inline void Geo::clear_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.country_ != nullptr) _impl_.country_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Country& Geo::_internal_country() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Country* p = _impl_.country_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Country&>(::kentik::synthetics::v202101beta1::_Country_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Country& Geo::country() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Geo.country)
  return _internal_country();
}
inline void Geo::unsafe_arena_set_allocated_country(::kentik::synthetics::v202101beta1::Country* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.country_);
  }
  _impl_.country_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Country*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Geo.country)
}
inline ::kentik::synthetics::v202101beta1::Country* Geo::release_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Country* released = _impl_.country_;
  _impl_.country_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Country* Geo::unsafe_arena_release_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Geo.country)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Country* temp = _impl_.country_;
  _impl_.country_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Country* Geo::_internal_mutable_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.country_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Country>(GetArena());
    _impl_.country_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Country*>(p);
  }
  return _impl_.country_;
}
inline ::kentik::synthetics::v202101beta1::Country* Geo::mutable_country() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Country* _msg = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Geo.country)
  return _msg;
}
inline void Geo::set_allocated_country(::kentik::synthetics::v202101beta1::Country* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.country_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.country_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Country*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Geo.country)
}

// .kentik.synthetics.v202101beta1.Region region = 2 [json_name = "region"];
inline bool Geo::has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.region_ != nullptr);
  return value;
}
inline void Geo::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.region_ != nullptr) _impl_.region_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::Region& Geo::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Region* p = _impl_.region_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Region&>(::kentik::synthetics::v202101beta1::_Region_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Region& Geo::region() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Geo.region)
  return _internal_region();
}
inline void Geo::unsafe_arena_set_allocated_region(::kentik::synthetics::v202101beta1::Region* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.region_);
  }
  _impl_.region_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Region*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Geo.region)
}
inline ::kentik::synthetics::v202101beta1::Region* Geo::release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Region* released = _impl_.region_;
  _impl_.region_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Region* Geo::unsafe_arena_release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Geo.region)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Region* Geo::_internal_mutable_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.region_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Region>(GetArena());
    _impl_.region_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Region*>(p);
  }
  return _impl_.region_;
}
inline ::kentik::synthetics::v202101beta1::Region* Geo::mutable_region() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::Region* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Geo.region)
  return _msg;
}
inline void Geo::set_allocated_region(::kentik::synthetics::v202101beta1::Region* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.region_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.region_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Region*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Geo.region)
}

// .kentik.synthetics.v202101beta1.City city = 3 [json_name = "city"];
inline bool Geo::has_city() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.city_ != nullptr);
  return value;
}
inline void Geo::clear_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.city_ != nullptr) _impl_.city_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::synthetics::v202101beta1::City& Geo::_internal_city() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::City* p = _impl_.city_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::City&>(::kentik::synthetics::v202101beta1::_City_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::City& Geo::city() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Geo.city)
  return _internal_city();
}
inline void Geo::unsafe_arena_set_allocated_city(::kentik::synthetics::v202101beta1::City* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.city_);
  }
  _impl_.city_ = reinterpret_cast<::kentik::synthetics::v202101beta1::City*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.Geo.city)
}
inline ::kentik::synthetics::v202101beta1::City* Geo::release_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::City* released = _impl_.city_;
  _impl_.city_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::City* Geo::unsafe_arena_release_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Geo.city)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::City* temp = _impl_.city_;
  _impl_.city_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::City* Geo::_internal_mutable_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.city_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::City>(GetArena());
    _impl_.city_ = reinterpret_cast<::kentik::synthetics::v202101beta1::City*>(p);
  }
  return _impl_.city_;
}
inline ::kentik::synthetics::v202101beta1::City* Geo::mutable_city() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::synthetics::v202101beta1::City* _msg = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Geo.city)
  return _msg;
}
inline void Geo::set_allocated_city(::kentik::synthetics::v202101beta1::City* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.city_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.city_ = reinterpret_cast<::kentik::synthetics::v202101beta1::City*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Geo.city)
}

// -------------------------------------------------------------------

// DNS

// string name = 1 [json_name = "name"];
inline void DNS::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DNS::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DNS.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DNS::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DNS.name)
}
inline std::string* DNS::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DNS.name)
  return _s;
}
inline const std::string& DNS::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void DNS::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DNS::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DNS::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DNS.name)
  return _impl_.name_.Release();
}
inline void DNS::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DNS.name)
}

// -------------------------------------------------------------------

// IPInfo

// string ip = 1 [json_name = "ip"];
inline void IPInfo::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& IPInfo::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPInfo::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IPInfo.ip)
}
inline std::string* IPInfo::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.ip)
  return _s;
}
inline const std::string& IPInfo::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_.Get();
}
inline void IPInfo::_internal_set_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* IPInfo::_internal_mutable_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* IPInfo::release_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.ip)
  return _impl_.ip_.Release();
}
inline void IPInfo::set_allocated_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.ip)
}

// .kentik.synthetics.v202101beta1.ASN asn = 2 [json_name = "asn"];
inline bool IPInfo::has_asn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.asn_ != nullptr);
  return value;
}
inline void IPInfo::clear_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asn_ != nullptr) _impl_.asn_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::ASN& IPInfo::_internal_asn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::ASN* p = _impl_.asn_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::ASN&>(::kentik::synthetics::v202101beta1::_ASN_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::ASN& IPInfo::asn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.asn)
  return _internal_asn();
}
inline void IPInfo::unsafe_arena_set_allocated_asn(::kentik::synthetics::v202101beta1::ASN* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.asn_);
  }
  _impl_.asn_ = reinterpret_cast<::kentik::synthetics::v202101beta1::ASN*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.IPInfo.asn)
}
inline ::kentik::synthetics::v202101beta1::ASN* IPInfo::release_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::ASN* released = _impl_.asn_;
  _impl_.asn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::ASN* IPInfo::unsafe_arena_release_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.asn)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::ASN* temp = _impl_.asn_;
  _impl_.asn_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::ASN* IPInfo::_internal_mutable_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::ASN>(GetArena());
    _impl_.asn_ = reinterpret_cast<::kentik::synthetics::v202101beta1::ASN*>(p);
  }
  return _impl_.asn_;
}
inline ::kentik::synthetics::v202101beta1::ASN* IPInfo::mutable_asn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::ASN* _msg = _internal_mutable_asn();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.asn)
  return _msg;
}
inline void IPInfo::set_allocated_asn(::kentik::synthetics::v202101beta1::ASN* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.asn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.asn_ = reinterpret_cast<::kentik::synthetics::v202101beta1::ASN*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.asn)
}

// .kentik.synthetics.v202101beta1.Geo geo = 3 [json_name = "geo"];
inline bool IPInfo::has_geo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geo_ != nullptr);
  return value;
}
inline void IPInfo::clear_geo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_ != nullptr) _impl_.geo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::Geo& IPInfo::_internal_geo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Geo* p = _impl_.geo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Geo&>(::kentik::synthetics::v202101beta1::_Geo_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Geo& IPInfo::geo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.geo)
  return _internal_geo();
}
inline void IPInfo::unsafe_arena_set_allocated_geo(::kentik::synthetics::v202101beta1::Geo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geo_);
  }
  _impl_.geo_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Geo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.IPInfo.geo)
}
inline ::kentik::synthetics::v202101beta1::Geo* IPInfo::release_geo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Geo* released = _impl_.geo_;
  _impl_.geo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Geo* IPInfo::unsafe_arena_release_geo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.geo)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Geo* temp = _impl_.geo_;
  _impl_.geo_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Geo* IPInfo::_internal_mutable_geo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.geo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Geo>(GetArena());
    _impl_.geo_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Geo*>(p);
  }
  return _impl_.geo_;
}
inline ::kentik::synthetics::v202101beta1::Geo* IPInfo::mutable_geo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::Geo* _msg = _internal_mutable_geo();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.geo)
  return _msg;
}
inline void IPInfo::set_allocated_geo(::kentik::synthetics::v202101beta1::Geo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.geo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.geo_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Geo*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.geo)
}

// .kentik.synthetics.v202101beta1.DNS dns = 4 [json_name = "dns"];
inline bool IPInfo::has_dns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dns_ != nullptr);
  return value;
}
inline void IPInfo::clear_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dns_ != nullptr) _impl_.dns_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::synthetics::v202101beta1::DNS& IPInfo::_internal_dns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::DNS* p = _impl_.dns_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::DNS&>(::kentik::synthetics::v202101beta1::_DNS_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::DNS& IPInfo::dns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.dns)
  return _internal_dns();
}
inline void IPInfo::unsafe_arena_set_allocated_dns(::kentik::synthetics::v202101beta1::DNS* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dns_);
  }
  _impl_.dns_ = reinterpret_cast<::kentik::synthetics::v202101beta1::DNS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.IPInfo.dns)
}
inline ::kentik::synthetics::v202101beta1::DNS* IPInfo::release_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::DNS* released = _impl_.dns_;
  _impl_.dns_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::DNS* IPInfo::unsafe_arena_release_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.dns)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::DNS* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::DNS* IPInfo::_internal_mutable_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dns_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::DNS>(GetArena());
    _impl_.dns_ = reinterpret_cast<::kentik::synthetics::v202101beta1::DNS*>(p);
  }
  return _impl_.dns_;
}
inline ::kentik::synthetics::v202101beta1::DNS* IPInfo::mutable_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::synthetics::v202101beta1::DNS* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.dns)
  return _msg;
}
inline void IPInfo::set_allocated_dns(::kentik::synthetics::v202101beta1::DNS* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dns_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dns_ = reinterpret_cast<::kentik::synthetics::v202101beta1::DNS*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.dns)
}

// string device_id = 5 [json_name = "deviceId"];
inline void IPInfo::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& IPInfo::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPInfo::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IPInfo.device_id)
}
inline std::string* IPInfo::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.device_id)
  return _s;
}
inline const std::string& IPInfo::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_.Get();
}
inline void IPInfo::_internal_set_device_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* IPInfo::_internal_mutable_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* IPInfo::release_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.device_id)
  return _impl_.device_id_.Release();
}
inline void IPInfo::set_allocated_device_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.device_id)
}

// string site_id = 6 [json_name = "siteId"];
inline void IPInfo::clear_site_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.ClearToEmpty();
}
inline const std::string& IPInfo::site_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.site_id)
  return _internal_site_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPInfo::set_site_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IPInfo.site_id)
}
inline std::string* IPInfo::mutable_site_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_site_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.site_id)
  return _s;
}
inline const std::string& IPInfo::_internal_site_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.site_id_.Get();
}
inline void IPInfo::_internal_set_site_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.Set(value, GetArena());
}
inline std::string* IPInfo::_internal_mutable_site_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.site_id_.Mutable( GetArena());
}
inline std::string* IPInfo::release_site_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.site_id)
  return _impl_.site_id_.Release();
}
inline void IPInfo::set_allocated_site_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.site_id_.IsDefault()) {
    _impl_.site_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.site_id)
}

// string egress = 7 [json_name = "egress"];
inline void IPInfo::clear_egress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_.ClearToEmpty();
}
inline const std::string& IPInfo::egress() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IPInfo.egress)
  return _internal_egress();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IPInfo::set_egress(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IPInfo.egress)
}
inline std::string* IPInfo::mutable_egress() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_egress();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IPInfo.egress)
  return _s;
}
inline const std::string& IPInfo::_internal_egress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.egress_.Get();
}
inline void IPInfo::_internal_set_egress(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_.Set(value, GetArena());
}
inline std::string* IPInfo::_internal_mutable_egress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.egress_.Mutable( GetArena());
}
inline std::string* IPInfo::release_egress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IPInfo.egress)
  return _impl_.egress_.Release();
}
inline void IPInfo::set_allocated_egress(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.egress_.IsDefault()) {
    _impl_.egress_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IPInfo.egress)
}

// -------------------------------------------------------------------

// IDByIP

// string id = 1 [json_name = "id"];
inline void IDByIP::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& IDByIP::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IDByIP.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IDByIP::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IDByIP.id)
}
inline std::string* IDByIP::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IDByIP.id)
  return _s;
}
inline const std::string& IDByIP::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void IDByIP::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* IDByIP::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* IDByIP::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IDByIP.id)
  return _impl_.id_.Release();
}
inline void IDByIP::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IDByIP.id)
}

// string ip = 2 [json_name = "ip"];
inline void IDByIP::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& IDByIP::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.IDByIP.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IDByIP::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.IDByIP.ip)
}
inline std::string* IDByIP::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.IDByIP.ip)
  return _s;
}
inline const std::string& IDByIP::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_.Get();
}
inline void IDByIP::_internal_set_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* IDByIP::_internal_mutable_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* IDByIP::release_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.IDByIP.ip)
  return _impl_.ip_.Release();
}
inline void IDByIP::set_allocated_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.IDByIP.ip)
}

// -------------------------------------------------------------------

// TracerouteLookup

// repeated .kentik.synthetics.v202101beta1.IDByIP agent_id_by_ip = 1 [json_name = "agentIdByIp"];
inline int TracerouteLookup::_internal_agent_id_by_ip_size() const {
  return _internal_agent_id_by_ip().size();
}
inline int TracerouteLookup::agent_id_by_ip_size() const {
  return _internal_agent_id_by_ip_size();
}
inline void TracerouteLookup::clear_agent_id_by_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_by_ip_.Clear();
}
inline ::kentik::synthetics::v202101beta1::IDByIP* TracerouteLookup::mutable_agent_id_by_ip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteLookup.agent_id_by_ip)
  return _internal_mutable_agent_id_by_ip()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* TracerouteLookup::mutable_agent_id_by_ip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteLookup.agent_id_by_ip)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agent_id_by_ip();
}
inline const ::kentik::synthetics::v202101beta1::IDByIP& TracerouteLookup::agent_id_by_ip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteLookup.agent_id_by_ip)
  return _internal_agent_id_by_ip().Get(index);
}
inline ::kentik::synthetics::v202101beta1::IDByIP* TracerouteLookup::add_agent_id_by_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::IDByIP* _add = _internal_mutable_agent_id_by_ip()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteLookup.agent_id_by_ip)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& TracerouteLookup::agent_id_by_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteLookup.agent_id_by_ip)
  return _internal_agent_id_by_ip();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>&
TracerouteLookup::_internal_agent_id_by_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_by_ip_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>*
TracerouteLookup::_internal_mutable_agent_id_by_ip() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agent_id_by_ip_;
}

// repeated .kentik.synthetics.v202101beta1.Agent agents = 2 [json_name = "agents"];
inline int TracerouteLookup::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int TracerouteLookup::agents_size() const {
  return _internal_agents_size();
}
inline void TracerouteLookup::clear_agents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agents_.Clear();
}
inline ::kentik::synthetics::v202101beta1::Agent* TracerouteLookup::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteLookup.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>* TracerouteLookup::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteLookup.agents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agents();
}
inline const ::kentik::synthetics::v202101beta1::Agent& TracerouteLookup::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteLookup.agents)
  return _internal_agents().Get(index);
}
inline ::kentik::synthetics::v202101beta1::Agent* TracerouteLookup::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::Agent* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteLookup.agents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>& TracerouteLookup::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteLookup.agents)
  return _internal_agents();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>&
TracerouteLookup::_internal_agents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agents_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>*
TracerouteLookup::_internal_mutable_agents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agents_;
}

// repeated .kentik.synthetics.v202101beta1.ASN asns = 3 [json_name = "asns"];
inline int TracerouteLookup::_internal_asns_size() const {
  return _internal_asns().size();
}
inline int TracerouteLookup::asns_size() const {
  return _internal_asns_size();
}
inline void TracerouteLookup::clear_asns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asns_.Clear();
}
inline ::kentik::synthetics::v202101beta1::ASN* TracerouteLookup::mutable_asns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteLookup.asns)
  return _internal_mutable_asns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>* TracerouteLookup::mutable_asns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteLookup.asns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_asns();
}
inline const ::kentik::synthetics::v202101beta1::ASN& TracerouteLookup::asns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteLookup.asns)
  return _internal_asns().Get(index);
}
inline ::kentik::synthetics::v202101beta1::ASN* TracerouteLookup::add_asns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::ASN* _add = _internal_mutable_asns()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteLookup.asns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>& TracerouteLookup::asns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteLookup.asns)
  return _internal_asns();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>&
TracerouteLookup::_internal_asns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asns_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::ASN>*
TracerouteLookup::_internal_mutable_asns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.asns_;
}

// repeated .kentik.synthetics.v202101beta1.IDByIP device_id_by_ip = 4 [json_name = "deviceIdByIp"];
inline int TracerouteLookup::_internal_device_id_by_ip_size() const {
  return _internal_device_id_by_ip().size();
}
inline int TracerouteLookup::device_id_by_ip_size() const {
  return _internal_device_id_by_ip_size();
}
inline void TracerouteLookup::clear_device_id_by_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_by_ip_.Clear();
}
inline ::kentik::synthetics::v202101beta1::IDByIP* TracerouteLookup::mutable_device_id_by_ip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteLookup.device_id_by_ip)
  return _internal_mutable_device_id_by_ip()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* TracerouteLookup::mutable_device_id_by_ip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteLookup.device_id_by_ip)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_id_by_ip();
}
inline const ::kentik::synthetics::v202101beta1::IDByIP& TracerouteLookup::device_id_by_ip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteLookup.device_id_by_ip)
  return _internal_device_id_by_ip().Get(index);
}
inline ::kentik::synthetics::v202101beta1::IDByIP* TracerouteLookup::add_device_id_by_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::IDByIP* _add = _internal_mutable_device_id_by_ip()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteLookup.device_id_by_ip)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& TracerouteLookup::device_id_by_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteLookup.device_id_by_ip)
  return _internal_device_id_by_ip();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>&
TracerouteLookup::_internal_device_id_by_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_by_ip_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>*
TracerouteLookup::_internal_mutable_device_id_by_ip() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_id_by_ip_;
}

// repeated .kentik.synthetics.v202101beta1.IDByIP site_id_by_ip = 5 [json_name = "siteIdByIp"];
inline int TracerouteLookup::_internal_site_id_by_ip_size() const {
  return _internal_site_id_by_ip().size();
}
inline int TracerouteLookup::site_id_by_ip_size() const {
  return _internal_site_id_by_ip_size();
}
inline void TracerouteLookup::clear_site_id_by_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_id_by_ip_.Clear();
}
inline ::kentik::synthetics::v202101beta1::IDByIP* TracerouteLookup::mutable_site_id_by_ip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteLookup.site_id_by_ip)
  return _internal_mutable_site_id_by_ip()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>* TracerouteLookup::mutable_site_id_by_ip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteLookup.site_id_by_ip)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_site_id_by_ip();
}
inline const ::kentik::synthetics::v202101beta1::IDByIP& TracerouteLookup::site_id_by_ip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteLookup.site_id_by_ip)
  return _internal_site_id_by_ip().Get(index);
}
inline ::kentik::synthetics::v202101beta1::IDByIP* TracerouteLookup::add_site_id_by_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::IDByIP* _add = _internal_mutable_site_id_by_ip()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteLookup.site_id_by_ip)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>& TracerouteLookup::site_id_by_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteLookup.site_id_by_ip)
  return _internal_site_id_by_ip();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>&
TracerouteLookup::_internal_site_id_by_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.site_id_by_ip_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IDByIP>*
TracerouteLookup::_internal_mutable_site_id_by_ip() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.site_id_by_ip_;
}

// repeated .kentik.synthetics.v202101beta1.IPInfo ips = 6 [json_name = "ips"];
inline int TracerouteLookup::_internal_ips_size() const {
  return _internal_ips().size();
}
inline int TracerouteLookup::ips_size() const {
  return _internal_ips_size();
}
inline void TracerouteLookup::clear_ips() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ips_.Clear();
}
inline ::kentik::synthetics::v202101beta1::IPInfo* TracerouteLookup::mutable_ips(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteLookup.ips)
  return _internal_mutable_ips()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>* TracerouteLookup::mutable_ips()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteLookup.ips)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ips();
}
inline const ::kentik::synthetics::v202101beta1::IPInfo& TracerouteLookup::ips(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteLookup.ips)
  return _internal_ips().Get(index);
}
inline ::kentik::synthetics::v202101beta1::IPInfo* TracerouteLookup::add_ips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::IPInfo* _add = _internal_mutable_ips()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteLookup.ips)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>& TracerouteLookup::ips() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteLookup.ips)
  return _internal_ips();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>&
TracerouteLookup::_internal_ips() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ips_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::IPInfo>*
TracerouteLookup::_internal_mutable_ips() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ips_;
}

// -------------------------------------------------------------------

// TraceHop

// int32 ttl = 1 [json_name = "ttl"];
inline void TraceHop::clear_ttl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ttl_ = 0;
}
inline ::int32_t TraceHop::ttl() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.ttl)
  return _internal_ttl();
}
inline void TraceHop::set_ttl(::int32_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.ttl)
}
inline ::int32_t TraceHop::_internal_ttl() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ttl_;
}
inline void TraceHop::_internal_set_ttl(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ttl_ = value;
}

// string ip = 2 [json_name = "ip"];
inline void TraceHop::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& TraceHop::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TraceHop::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.ip)
}
inline std::string* TraceHop::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TraceHop.ip)
  return _s;
}
inline const std::string& TraceHop::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_.Get();
}
inline void TraceHop::_internal_set_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* TraceHop::_internal_mutable_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* TraceHop::release_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TraceHop.ip)
  return _impl_.ip_.Release();
}
inline void TraceHop::set_allocated_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TraceHop.ip)
}

// bool timeout = 3 [json_name = "timeout"];
inline void TraceHop::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = false;
}
inline bool TraceHop::timeout() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.timeout)
  return _internal_timeout();
}
inline void TraceHop::set_timeout(bool value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.timeout)
}
inline bool TraceHop::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void TraceHop::_internal_set_timeout(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// int32 latency = 4 [json_name = "latency"];
inline void TraceHop::clear_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_ = 0;
}
inline ::int32_t TraceHop::latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.latency)
  return _internal_latency();
}
inline void TraceHop::set_latency(::int32_t value) {
  _internal_set_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.latency)
}
inline ::int32_t TraceHop::_internal_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latency_;
}
inline void TraceHop::_internal_set_latency(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latency_ = value;
}

// int32 min_expected_latency = 5 [json_name = "minExpectedLatency"];
inline void TraceHop::clear_min_expected_latency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_expected_latency_ = 0;
}
inline ::int32_t TraceHop::min_expected_latency() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.min_expected_latency)
  return _internal_min_expected_latency();
}
inline void TraceHop::set_min_expected_latency(::int32_t value) {
  _internal_set_min_expected_latency(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.min_expected_latency)
}
inline ::int32_t TraceHop::_internal_min_expected_latency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_expected_latency_;
}
inline void TraceHop::_internal_set_min_expected_latency(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_expected_latency_ = value;
}

// int32 asn = 6 [json_name = "asn"];
inline void TraceHop::clear_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = 0;
}
inline ::int32_t TraceHop::asn() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.asn)
  return _internal_asn();
}
inline void TraceHop::set_asn(::int32_t value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.asn)
}
inline ::int32_t TraceHop::_internal_asn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn_;
}
inline void TraceHop::_internal_set_asn(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = value;
}

// int32 site = 7 [json_name = "site"];
inline void TraceHop::clear_site() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_ = 0;
}
inline ::int32_t TraceHop::site() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.site)
  return _internal_site();
}
inline void TraceHop::set_site(::int32_t value) {
  _internal_set_site(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.site)
}
inline ::int32_t TraceHop::_internal_site() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.site_;
}
inline void TraceHop::_internal_set_site(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_ = value;
}

// int32 region = 8 [json_name = "region"];
inline void TraceHop::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_ = 0;
}
inline ::int32_t TraceHop::region() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.region)
  return _internal_region();
}
inline void TraceHop::set_region(::int32_t value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.region)
}
inline ::int32_t TraceHop::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_;
}
inline void TraceHop::_internal_set_region(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_ = value;
}

// bool target = 9 [json_name = "target"];
inline void TraceHop::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = false;
}
inline bool TraceHop::target() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.target)
  return _internal_target();
}
inline void TraceHop::set_target(bool value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.target)
}
inline bool TraceHop::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline void TraceHop::_internal_set_target(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// bool trace_end = 10 [json_name = "traceEnd"];
inline void TraceHop::clear_trace_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_end_ = false;
}
inline bool TraceHop::trace_end() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceHop.trace_end)
  return _internal_trace_end();
}
inline void TraceHop::set_trace_end(bool value) {
  _internal_set_trace_end(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceHop.trace_end)
}
inline bool TraceHop::_internal_trace_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trace_end_;
}
inline void TraceHop::_internal_set_trace_end(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_end_ = value;
}

// -------------------------------------------------------------------

// TraceProbe

// repeated int32 as_path = 1 [json_name = "asPath"];
inline int TraceProbe::_internal_as_path_size() const {
  return _internal_as_path().size();
}
inline int TraceProbe::as_path_size() const {
  return _internal_as_path_size();
}
inline void TraceProbe::clear_as_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.as_path_.Clear();
}
inline ::int32_t TraceProbe::as_path(int index) const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceProbe.as_path)
  return _internal_as_path().Get(index);
}
inline void TraceProbe::set_as_path(int index, ::int32_t value) {
  _internal_mutable_as_path()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceProbe.as_path)
}
inline void TraceProbe::add_as_path(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_as_path()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TraceProbe.as_path)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TraceProbe::as_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TraceProbe.as_path)
  return _internal_as_path();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TraceProbe::mutable_as_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TraceProbe.as_path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_as_path();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
TraceProbe::_internal_as_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.as_path_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TraceProbe::_internal_mutable_as_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.as_path_;
}

// bool completed = 2 [json_name = "completed"];
inline void TraceProbe::clear_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_ = false;
}
inline bool TraceProbe::completed() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceProbe.completed)
  return _internal_completed();
}
inline void TraceProbe::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceProbe.completed)
}
inline bool TraceProbe::_internal_completed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.completed_;
}
inline void TraceProbe::_internal_set_completed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_ = value;
}

// int32 hop_count = 3 [json_name = "hopCount"];
inline void TraceProbe::clear_hop_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_count_ = 0;
}
inline ::int32_t TraceProbe::hop_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceProbe.hop_count)
  return _internal_hop_count();
}
inline void TraceProbe::set_hop_count(::int32_t value) {
  _internal_set_hop_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceProbe.hop_count)
}
inline ::int32_t TraceProbe::_internal_hop_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_count_;
}
inline void TraceProbe::_internal_set_hop_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_count_ = value;
}

// repeated string region_path = 4 [json_name = "regionPath"];
inline int TraceProbe::_internal_region_path_size() const {
  return _internal_region_path().size();
}
inline int TraceProbe::region_path_size() const {
  return _internal_region_path_size();
}
inline void TraceProbe::clear_region_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_path_.Clear();
}
inline std::string* TraceProbe::add_region_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_region_path()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.TraceProbe.region_path)
  return _s;
}
inline const std::string& TraceProbe::region_path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceProbe.region_path)
  return _internal_region_path().Get(index);
}
inline std::string* TraceProbe::mutable_region_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TraceProbe.region_path)
  return _internal_mutable_region_path()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TraceProbe::set_region_path(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_region_path()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceProbe.region_path)
}
template <typename Arg_, typename... Args_>
inline void TraceProbe::add_region_path(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_region_path(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TraceProbe.region_path)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TraceProbe::region_path() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TraceProbe.region_path)
  return _internal_region_path();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TraceProbe::mutable_region_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TraceProbe.region_path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_region_path();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TraceProbe::_internal_region_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_path_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TraceProbe::_internal_mutable_region_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.region_path_;
}

// repeated int32 site_path = 5 [json_name = "sitePath"];
inline int TraceProbe::_internal_site_path_size() const {
  return _internal_site_path().size();
}
inline int TraceProbe::site_path_size() const {
  return _internal_site_path_size();
}
inline void TraceProbe::clear_site_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.site_path_.Clear();
}
inline ::int32_t TraceProbe::site_path(int index) const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceProbe.site_path)
  return _internal_site_path().Get(index);
}
inline void TraceProbe::set_site_path(int index, ::int32_t value) {
  _internal_mutable_site_path()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TraceProbe.site_path)
}
inline void TraceProbe::add_site_path(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_site_path()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TraceProbe.site_path)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TraceProbe::site_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TraceProbe.site_path)
  return _internal_site_path();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TraceProbe::mutable_site_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TraceProbe.site_path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_site_path();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
TraceProbe::_internal_site_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.site_path_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TraceProbe::_internal_mutable_site_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.site_path_;
}

// repeated .kentik.synthetics.v202101beta1.TraceHop hops = 6 [json_name = "hops"];
inline int TraceProbe::_internal_hops_size() const {
  return _internal_hops().size();
}
inline int TraceProbe::hops_size() const {
  return _internal_hops_size();
}
inline void TraceProbe::clear_hops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hops_.Clear();
}
inline ::kentik::synthetics::v202101beta1::TraceHop* TraceProbe::mutable_hops(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TraceProbe.hops)
  return _internal_mutable_hops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>* TraceProbe::mutable_hops()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TraceProbe.hops)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hops();
}
inline const ::kentik::synthetics::v202101beta1::TraceHop& TraceProbe::hops(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TraceProbe.hops)
  return _internal_hops().Get(index);
}
inline ::kentik::synthetics::v202101beta1::TraceHop* TraceProbe::add_hops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::TraceHop* _add = _internal_mutable_hops()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TraceProbe.hops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>& TraceProbe::hops() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TraceProbe.hops)
  return _internal_hops();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>&
TraceProbe::_internal_hops() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hops_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceHop>*
TraceProbe::_internal_mutable_hops() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hops_;
}

// -------------------------------------------------------------------

// Trace

// string agent_id = 1 [json_name = "agentId"];
inline void Trace::clear_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& Trace::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Trace.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Trace::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Trace.agent_id)
}
inline std::string* Trace::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Trace.agent_id)
  return _s;
}
inline const std::string& Trace::_internal_agent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_id_.Get();
}
inline void Trace::_internal_set_agent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* Trace::_internal_mutable_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* Trace::release_agent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Trace.agent_id)
  return _impl_.agent_id_.Release();
}
inline void Trace::set_allocated_agent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Trace.agent_id)
}

// string agent_ip = 2 [json_name = "agentIp"];
inline void Trace::clear_agent_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ip_.ClearToEmpty();
}
inline const std::string& Trace::agent_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Trace.agent_ip)
  return _internal_agent_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Trace::set_agent_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Trace.agent_ip)
}
inline std::string* Trace::mutable_agent_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Trace.agent_ip)
  return _s;
}
inline const std::string& Trace::_internal_agent_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_ip_.Get();
}
inline void Trace::_internal_set_agent_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ip_.Set(value, GetArena());
}
inline std::string* Trace::_internal_mutable_agent_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.agent_ip_.Mutable( GetArena());
}
inline std::string* Trace::release_agent_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Trace.agent_ip)
  return _impl_.agent_ip_.Release();
}
inline void Trace::set_allocated_agent_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_ip_.IsDefault()) {
    _impl_.agent_ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Trace.agent_ip)
}

// string target_ip = 3 [json_name = "targetIp"];
inline void Trace::clear_target_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ip_.ClearToEmpty();
}
inline const std::string& Trace::target_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Trace.target_ip)
  return _internal_target_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Trace::set_target_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Trace.target_ip)
}
inline std::string* Trace::mutable_target_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_ip();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Trace.target_ip)
  return _s;
}
inline const std::string& Trace::_internal_target_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_ip_.Get();
}
inline void Trace::_internal_set_target_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ip_.Set(value, GetArena());
}
inline std::string* Trace::_internal_mutable_target_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_ip_.Mutable( GetArena());
}
inline std::string* Trace::release_target_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.Trace.target_ip)
  return _impl_.target_ip_.Release();
}
inline void Trace::set_allocated_target_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ip_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_ip_.IsDefault()) {
    _impl_.target_ip_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.Trace.target_ip)
}

// int32 hop_count = 4 [json_name = "hopCount"];
inline void Trace::clear_hop_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_count_ = 0;
}
inline ::int32_t Trace::hop_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Trace.hop_count)
  return _internal_hop_count();
}
inline void Trace::set_hop_count(::int32_t value) {
  _internal_set_hop_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Trace.hop_count)
}
inline ::int32_t Trace::_internal_hop_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_count_;
}
inline void Trace::_internal_set_hop_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_count_ = value;
}

// repeated .kentik.synthetics.v202101beta1.TraceProbe probes = 5 [json_name = "probes"];
inline int Trace::_internal_probes_size() const {
  return _internal_probes().size();
}
inline int Trace::probes_size() const {
  return _internal_probes_size();
}
inline void Trace::clear_probes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.probes_.Clear();
}
inline ::kentik::synthetics::v202101beta1::TraceProbe* Trace::mutable_probes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.Trace.probes)
  return _internal_mutable_probes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>* Trace::mutable_probes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.Trace.probes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_probes();
}
inline const ::kentik::synthetics::v202101beta1::TraceProbe& Trace::probes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Trace.probes)
  return _internal_probes().Get(index);
}
inline ::kentik::synthetics::v202101beta1::TraceProbe* Trace::add_probes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::TraceProbe* _add = _internal_mutable_probes()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.Trace.probes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>& Trace::probes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.Trace.probes)
  return _internal_probes();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>&
Trace::_internal_probes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.probes_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TraceProbe>*
Trace::_internal_mutable_probes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.probes_;
}

// -------------------------------------------------------------------

// Stats

// int32 average = 1 [json_name = "average"];
inline void Stats::clear_average() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_ = 0;
}
inline ::int32_t Stats::average() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Stats.average)
  return _internal_average();
}
inline void Stats::set_average(::int32_t value) {
  _internal_set_average(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Stats.average)
}
inline ::int32_t Stats::_internal_average() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_;
}
inline void Stats::_internal_set_average(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_ = value;
}

// int32 max = 2 [json_name = "max"];
inline void Stats::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = 0;
}
inline ::int32_t Stats::max() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Stats.max)
  return _internal_max();
}
inline void Stats::set_max(::int32_t value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Stats.max)
}
inline ::int32_t Stats::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void Stats::_internal_set_max(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// int32 total = 3 [json_name = "total"];
inline void Stats::clear_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = 0;
}
inline ::int32_t Stats::total() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.Stats.total)
  return _internal_total();
}
inline void Stats::set_total(::int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.Stats.total)
}
inline ::int32_t Stats::_internal_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_;
}
inline void Stats::_internal_set_total(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// TracerouteResult

// .google.protobuf.Timestamp time = 1 [json_name = "time"];
inline bool TracerouteResult::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TracerouteResult::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TracerouteResult::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteResult.time)
  return _internal_time();
}
inline void TracerouteResult::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TracerouteResult.time)
}
inline ::google::protobuf::Timestamp* TracerouteResult::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* TracerouteResult::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TracerouteResult.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TracerouteResult::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* TracerouteResult::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteResult.time)
  return _msg;
}
inline void TracerouteResult::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TracerouteResult.time)
}

// repeated .kentik.synthetics.v202101beta1.Trace traces = 2 [json_name = "traces"];
inline int TracerouteResult::_internal_traces_size() const {
  return _internal_traces().size();
}
inline int TracerouteResult::traces_size() const {
  return _internal_traces_size();
}
inline void TracerouteResult::clear_traces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.traces_.Clear();
}
inline ::kentik::synthetics::v202101beta1::Trace* TracerouteResult::mutable_traces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteResult.traces)
  return _internal_mutable_traces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>* TracerouteResult::mutable_traces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.TracerouteResult.traces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_traces();
}
inline const ::kentik::synthetics::v202101beta1::Trace& TracerouteResult::traces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteResult.traces)
  return _internal_traces().Get(index);
}
inline ::kentik::synthetics::v202101beta1::Trace* TracerouteResult::add_traces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::Trace* _add = _internal_mutable_traces()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.TracerouteResult.traces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>& TracerouteResult::traces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.TracerouteResult.traces)
  return _internal_traces();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>&
TracerouteResult::_internal_traces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.traces_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Trace>*
TracerouteResult::_internal_mutable_traces() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.traces_;
}

// int32 hop_count = 3 [json_name = "hopCount"];
inline void TracerouteResult::clear_hop_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_count_ = 0;
}
inline ::int32_t TracerouteResult::hop_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteResult.hop_count)
  return _internal_hop_count();
}
inline void TracerouteResult::set_hop_count(::int32_t value) {
  _internal_set_hop_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TracerouteResult.hop_count)
}
inline ::int32_t TracerouteResult::_internal_hop_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_count_;
}
inline void TracerouteResult::_internal_set_hop_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_count_ = value;
}

// .kentik.synthetics.v202101beta1.Stats count = 4 [json_name = "count"];
inline bool TracerouteResult::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.count_ != nullptr);
  return value;
}
inline void TracerouteResult::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.count_ != nullptr) _impl_.count_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::Stats& TracerouteResult::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Stats* p = _impl_.count_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Stats&>(::kentik::synthetics::v202101beta1::_Stats_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Stats& TracerouteResult::count() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteResult.count)
  return _internal_count();
}
inline void TracerouteResult::unsafe_arena_set_allocated_count(::kentik::synthetics::v202101beta1::Stats* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.count_);
  }
  _impl_.count_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TracerouteResult.count)
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::release_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Stats* released = _impl_.count_;
  _impl_.count_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::unsafe_arena_release_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TracerouteResult.count)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::Stats* temp = _impl_.count_;
  _impl_.count_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::_internal_mutable_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.count_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Stats>(GetArena());
    _impl_.count_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Stats*>(p);
  }
  return _impl_.count_;
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::mutable_count() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::Stats* _msg = _internal_mutable_count();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteResult.count)
  return _msg;
}
inline void TracerouteResult::set_allocated_count(::kentik::synthetics::v202101beta1::Stats* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.count_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.count_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TracerouteResult.count)
}

// .kentik.synthetics.v202101beta1.Stats distance = 5 [json_name = "distance"];
inline bool TracerouteResult::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distance_ != nullptr);
  return value;
}
inline void TracerouteResult::clear_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distance_ != nullptr) _impl_.distance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::synthetics::v202101beta1::Stats& TracerouteResult::_internal_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Stats* p = _impl_.distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Stats&>(::kentik::synthetics::v202101beta1::_Stats_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Stats& TracerouteResult::distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteResult.distance)
  return _internal_distance();
}
inline void TracerouteResult::unsafe_arena_set_allocated_distance(::kentik::synthetics::v202101beta1::Stats* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_);
  }
  _impl_.distance_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.TracerouteResult.distance)
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::release_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::Stats* released = _impl_.distance_;
  _impl_.distance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::unsafe_arena_release_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.TracerouteResult.distance)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::synthetics::v202101beta1::Stats* temp = _impl_.distance_;
  _impl_.distance_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::_internal_mutable_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Stats>(GetArena());
    _impl_.distance_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Stats*>(p);
  }
  return _impl_.distance_;
}
inline ::kentik::synthetics::v202101beta1::Stats* TracerouteResult::mutable_distance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::synthetics::v202101beta1::Stats* _msg = _internal_mutable_distance();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.TracerouteResult.distance)
  return _msg;
}
inline void TracerouteResult::set_allocated_distance(::kentik::synthetics::v202101beta1::Stats* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.distance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.distance_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.TracerouteResult.distance)
}

// -------------------------------------------------------------------

// TracerouteInfo

// bool is_trace_routes_truncated = 1 [json_name = "isTraceRoutesTruncated"];
inline void TracerouteInfo::clear_is_trace_routes_truncated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_trace_routes_truncated_ = false;
}
inline bool TracerouteInfo::is_trace_routes_truncated() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteInfo.is_trace_routes_truncated)
  return _internal_is_trace_routes_truncated();
}
inline void TracerouteInfo::set_is_trace_routes_truncated(bool value) {
  _internal_set_is_trace_routes_truncated(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TracerouteInfo.is_trace_routes_truncated)
}
inline bool TracerouteInfo::_internal_is_trace_routes_truncated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_trace_routes_truncated_;
}
inline void TracerouteInfo::_internal_set_is_trace_routes_truncated(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_trace_routes_truncated_ = value;
}

// int32 max_asn_path_count = 2 [json_name = "maxAsnPathCount"];
inline void TracerouteInfo::clear_max_asn_path_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_asn_path_count_ = 0;
}
inline ::int32_t TracerouteInfo::max_asn_path_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteInfo.max_asn_path_count)
  return _internal_max_asn_path_count();
}
inline void TracerouteInfo::set_max_asn_path_count(::int32_t value) {
  _internal_set_max_asn_path_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TracerouteInfo.max_asn_path_count)
}
inline ::int32_t TracerouteInfo::_internal_max_asn_path_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_asn_path_count_;
}
inline void TracerouteInfo::_internal_set_max_asn_path_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_asn_path_count_ = value;
}

// int32 max_site_path_count = 3 [json_name = "maxSitePathCount"];
inline void TracerouteInfo::clear_max_site_path_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_site_path_count_ = 0;
}
inline ::int32_t TracerouteInfo::max_site_path_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteInfo.max_site_path_count)
  return _internal_max_site_path_count();
}
inline void TracerouteInfo::set_max_site_path_count(::int32_t value) {
  _internal_set_max_site_path_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TracerouteInfo.max_site_path_count)
}
inline ::int32_t TracerouteInfo::_internal_max_site_path_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_site_path_count_;
}
inline void TracerouteInfo::_internal_set_max_site_path_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_site_path_count_ = value;
}

// int32 max_region_path_count = 4 [json_name = "maxRegionPathCount"];
inline void TracerouteInfo::clear_max_region_path_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_region_path_count_ = 0;
}
inline ::int32_t TracerouteInfo::max_region_path_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.TracerouteInfo.max_region_path_count)
  return _internal_max_region_path_count();
}
inline void TracerouteInfo::set_max_region_path_count(::int32_t value) {
  _internal_set_max_region_path_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.TracerouteInfo.max_region_path_count)
}
inline ::int32_t TracerouteInfo::_internal_max_region_path_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_region_path_count_;
}
inline void TracerouteInfo::_internal_set_max_region_path_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_region_path_count_ = value;
}

// -------------------------------------------------------------------

// GetHealthForTestsRequest

// repeated string ids = 1 [json_name = "ids"];
inline int GetHealthForTestsRequest::_internal_ids_size() const {
  return _internal_ids().size();
}
inline int GetHealthForTestsRequest::ids_size() const {
  return _internal_ids_size();
}
inline void GetHealthForTestsRequest::clear_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ids_.Clear();
}
inline std::string* GetHealthForTestsRequest::add_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
  return _s;
}
inline const std::string& GetHealthForTestsRequest::ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
  return _internal_ids().Get(index);
}
inline std::string* GetHealthForTestsRequest::mutable_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
  return _internal_mutable_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetHealthForTestsRequest::set_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
}
template <typename Arg_, typename... Args_>
inline void GetHealthForTestsRequest::add_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetHealthForTestsRequest::ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
  return _internal_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetHealthForTestsRequest::mutable_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetHealthForTestsRequest::_internal_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetHealthForTestsRequest::_internal_mutable_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ids_;
}

// .google.protobuf.Timestamp start_time = 2 [json_name = "startTime"];
inline bool GetHealthForTestsRequest::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GetHealthForTestsRequest::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GetHealthForTestsRequest::start_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.start_time)
  return _internal_start_time();
}
inline void GetHealthForTestsRequest::unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.start_time)
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::unsafe_arena_release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.start_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.start_time_;
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.start_time)
  return _msg;
}
inline void GetHealthForTestsRequest::set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.start_time)
}

// .google.protobuf.Timestamp end_time = 3 [json_name = "endTime"];
inline bool GetHealthForTestsRequest::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GetHealthForTestsRequest::_internal_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GetHealthForTestsRequest::end_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.end_time)
  return _internal_end_time();
}
inline void GetHealthForTestsRequest::unsafe_arena_set_allocated_end_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.end_time)
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::release_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::unsafe_arena_release_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.end_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::_internal_mutable_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.end_time_;
}
inline ::google::protobuf::Timestamp* GetHealthForTestsRequest::mutable_end_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.end_time)
  return _msg;
}
inline void GetHealthForTestsRequest::set_allocated_end_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.end_time)
}

// repeated string agent_ids = 4 [json_name = "agentIds"];
inline int GetHealthForTestsRequest::_internal_agent_ids_size() const {
  return _internal_agent_ids().size();
}
inline int GetHealthForTestsRequest::agent_ids_size() const {
  return _internal_agent_ids_size();
}
inline void GetHealthForTestsRequest::clear_agent_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ids_.Clear();
}
inline std::string* GetHealthForTestsRequest::add_agent_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_agent_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
  return _s;
}
inline const std::string& GetHealthForTestsRequest::agent_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
  return _internal_agent_ids().Get(index);
}
inline std::string* GetHealthForTestsRequest::mutable_agent_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
  return _internal_mutable_agent_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetHealthForTestsRequest::set_agent_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_agent_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
}
template <typename Arg_, typename... Args_>
inline void GetHealthForTestsRequest::add_agent_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_agent_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetHealthForTestsRequest::agent_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
  return _internal_agent_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetHealthForTestsRequest::mutable_agent_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.agent_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agent_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetHealthForTestsRequest::_internal_agent_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetHealthForTestsRequest::_internal_mutable_agent_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agent_ids_;
}

// repeated string task_ids = 5 [json_name = "taskIds"];
inline int GetHealthForTestsRequest::_internal_task_ids_size() const {
  return _internal_task_ids().size();
}
inline int GetHealthForTestsRequest::task_ids_size() const {
  return _internal_task_ids_size();
}
inline void GetHealthForTestsRequest::clear_task_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_ids_.Clear();
}
inline std::string* GetHealthForTestsRequest::add_task_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_task_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
  return _s;
}
inline const std::string& GetHealthForTestsRequest::task_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
  return _internal_task_ids().Get(index);
}
inline std::string* GetHealthForTestsRequest::mutable_task_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
  return _internal_mutable_task_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetHealthForTestsRequest::set_task_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_task_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
}
template <typename Arg_, typename... Args_>
inline void GetHealthForTestsRequest::add_task_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_task_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetHealthForTestsRequest::task_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
  return _internal_task_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetHealthForTestsRequest::mutable_task_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.task_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_task_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetHealthForTestsRequest::_internal_task_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetHealthForTestsRequest::_internal_mutable_task_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.task_ids_;
}

// bool augment = 6 [json_name = "augment"];
inline void GetHealthForTestsRequest::clear_augment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.augment_ = false;
}
inline bool GetHealthForTestsRequest::augment() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.augment)
  return _internal_augment();
}
inline void GetHealthForTestsRequest::set_augment(bool value) {
  _internal_set_augment(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetHealthForTestsRequest.augment)
}
inline bool GetHealthForTestsRequest::_internal_augment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.augment_;
}
inline void GetHealthForTestsRequest::_internal_set_augment(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.augment_ = value;
}

// -------------------------------------------------------------------

// GetHealthForTestsResponse

// repeated .kentik.synthetics.v202101beta1.TestHealth health = 1 [json_name = "health"];
inline int GetHealthForTestsResponse::_internal_health_size() const {
  return _internal_health().size();
}
inline int GetHealthForTestsResponse::health_size() const {
  return _internal_health_size();
}
inline void GetHealthForTestsResponse::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_.Clear();
}
inline ::kentik::synthetics::v202101beta1::TestHealth* GetHealthForTestsResponse::mutable_health(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetHealthForTestsResponse.health)
  return _internal_mutable_health()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>* GetHealthForTestsResponse::mutable_health()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetHealthForTestsResponse.health)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_health();
}
inline const ::kentik::synthetics::v202101beta1::TestHealth& GetHealthForTestsResponse::health(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetHealthForTestsResponse.health)
  return _internal_health().Get(index);
}
inline ::kentik::synthetics::v202101beta1::TestHealth* GetHealthForTestsResponse::add_health() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::TestHealth* _add = _internal_mutable_health()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetHealthForTestsResponse.health)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>& GetHealthForTestsResponse::health() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetHealthForTestsResponse.health)
  return _internal_health();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>&
GetHealthForTestsResponse::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TestHealth>*
GetHealthForTestsResponse::_internal_mutable_health() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.health_;
}

// -------------------------------------------------------------------

// GetTraceForTestRequest

// string id = 1 [json_name = "id"];
inline void GetTraceForTestRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetTraceForTestRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTraceForTestRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetTraceForTestRequest.id)
}
inline std::string* GetTraceForTestRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.id)
  return _s;
}
inline const std::string& GetTraceForTestRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetTraceForTestRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetTraceForTestRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetTraceForTestRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTraceForTestRequest.id)
  return _impl_.id_.Release();
}
inline void GetTraceForTestRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestRequest.id)
}

// .google.protobuf.Timestamp start_time = 2 [json_name = "startTime"];
inline bool GetTraceForTestRequest::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GetTraceForTestRequest::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GetTraceForTestRequest::start_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestRequest.start_time)
  return _internal_start_time();
}
inline void GetTraceForTestRequest::unsafe_arena_set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestRequest.start_time)
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::unsafe_arena_release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTraceForTestRequest.start_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.start_time_;
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.start_time)
  return _msg;
}
inline void GetTraceForTestRequest::set_allocated_start_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestRequest.start_time)
}

// .google.protobuf.Timestamp end_time = 3 [json_name = "endTime"];
inline bool GetTraceForTestRequest::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GetTraceForTestRequest::_internal_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GetTraceForTestRequest::end_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestRequest.end_time)
  return _internal_end_time();
}
inline void GetTraceForTestRequest::unsafe_arena_set_allocated_end_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestRequest.end_time)
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::release_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::unsafe_arena_release_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTraceForTestRequest.end_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::_internal_mutable_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.end_time_;
}
inline ::google::protobuf::Timestamp* GetTraceForTestRequest::mutable_end_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.end_time)
  return _msg;
}
inline void GetTraceForTestRequest::set_allocated_end_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestRequest.end_time)
}

// repeated string agent_ids = 4 [json_name = "agentIds"];
inline int GetTraceForTestRequest::_internal_agent_ids_size() const {
  return _internal_agent_ids().size();
}
inline int GetTraceForTestRequest::agent_ids_size() const {
  return _internal_agent_ids_size();
}
inline void GetTraceForTestRequest::clear_agent_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_ids_.Clear();
}
inline std::string* GetTraceForTestRequest::add_agent_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_agent_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
  return _s;
}
inline const std::string& GetTraceForTestRequest::agent_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
  return _internal_agent_ids().Get(index);
}
inline std::string* GetTraceForTestRequest::mutable_agent_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
  return _internal_mutable_agent_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetTraceForTestRequest::set_agent_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_agent_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
}
template <typename Arg_, typename... Args_>
inline void GetTraceForTestRequest::add_agent_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_agent_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetTraceForTestRequest::agent_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
  return _internal_agent_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetTraceForTestRequest::mutable_agent_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetTraceForTestRequest.agent_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agent_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetTraceForTestRequest::_internal_agent_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetTraceForTestRequest::_internal_mutable_agent_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agent_ids_;
}

// repeated string target_ips = 5 [json_name = "targetIps"];
inline int GetTraceForTestRequest::_internal_target_ips_size() const {
  return _internal_target_ips().size();
}
inline int GetTraceForTestRequest::target_ips_size() const {
  return _internal_target_ips_size();
}
inline void GetTraceForTestRequest::clear_target_ips() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ips_.Clear();
}
inline std::string* GetTraceForTestRequest::add_target_ips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_target_ips()->Add();
  // @@protoc_insertion_point(field_add_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
  return _s;
}
inline const std::string& GetTraceForTestRequest::target_ips(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
  return _internal_target_ips().Get(index);
}
inline std::string* GetTraceForTestRequest::mutable_target_ips(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
  return _internal_mutable_target_ips()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetTraceForTestRequest::set_target_ips(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_target_ips()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
}
template <typename Arg_, typename... Args_>
inline void GetTraceForTestRequest::add_target_ips(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_target_ips(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetTraceForTestRequest::target_ips() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
  return _internal_target_ips();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetTraceForTestRequest::mutable_target_ips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetTraceForTestRequest.target_ips)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_target_ips();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetTraceForTestRequest::_internal_target_ips() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_ips_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetTraceForTestRequest::_internal_mutable_target_ips() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.target_ips_;
}

// -------------------------------------------------------------------

// GetTraceForTestResponse

// .kentik.synthetics.v202101beta1.TracerouteLookup lookups = 1 [json_name = "lookups"];
inline bool GetTraceForTestResponse::has_lookups() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lookups_ != nullptr);
  return value;
}
inline void GetTraceForTestResponse::clear_lookups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookups_ != nullptr) _impl_.lookups_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::TracerouteLookup& GetTraceForTestResponse::_internal_lookups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::TracerouteLookup* p = _impl_.lookups_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::TracerouteLookup&>(::kentik::synthetics::v202101beta1::_TracerouteLookup_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TracerouteLookup& GetTraceForTestResponse::lookups() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestResponse.lookups)
  return _internal_lookups();
}
inline void GetTraceForTestResponse::unsafe_arena_set_allocated_lookups(::kentik::synthetics::v202101beta1::TracerouteLookup* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookups_);
  }
  _impl_.lookups_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TracerouteLookup*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestResponse.lookups)
}
inline ::kentik::synthetics::v202101beta1::TracerouteLookup* GetTraceForTestResponse::release_lookups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::TracerouteLookup* released = _impl_.lookups_;
  _impl_.lookups_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::TracerouteLookup* GetTraceForTestResponse::unsafe_arena_release_lookups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTraceForTestResponse.lookups)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::TracerouteLookup* temp = _impl_.lookups_;
  _impl_.lookups_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::TracerouteLookup* GetTraceForTestResponse::_internal_mutable_lookups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lookups_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TracerouteLookup>(GetArena());
    _impl_.lookups_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TracerouteLookup*>(p);
  }
  return _impl_.lookups_;
}
inline ::kentik::synthetics::v202101beta1::TracerouteLookup* GetTraceForTestResponse::mutable_lookups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::TracerouteLookup* _msg = _internal_mutable_lookups();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestResponse.lookups)
  return _msg;
}
inline void GetTraceForTestResponse::set_allocated_lookups(::kentik::synthetics::v202101beta1::TracerouteLookup* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lookups_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lookups_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TracerouteLookup*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestResponse.lookups)
}

// repeated .kentik.synthetics.v202101beta1.TracerouteResult trace_routes = 2 [json_name = "traceRoutes"];
inline int GetTraceForTestResponse::_internal_trace_routes_size() const {
  return _internal_trace_routes().size();
}
inline int GetTraceForTestResponse::trace_routes_size() const {
  return _internal_trace_routes_size();
}
inline void GetTraceForTestResponse::clear_trace_routes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_routes_.Clear();
}
inline ::kentik::synthetics::v202101beta1::TracerouteResult* GetTraceForTestResponse::mutable_trace_routes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes)
  return _internal_mutable_trace_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>* GetTraceForTestResponse::mutable_trace_routes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_trace_routes();
}
inline const ::kentik::synthetics::v202101beta1::TracerouteResult& GetTraceForTestResponse::trace_routes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes)
  return _internal_trace_routes().Get(index);
}
inline ::kentik::synthetics::v202101beta1::TracerouteResult* GetTraceForTestResponse::add_trace_routes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::TracerouteResult* _add = _internal_mutable_trace_routes()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>& GetTraceForTestResponse::trace_routes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes)
  return _internal_trace_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>&
GetTraceForTestResponse::_internal_trace_routes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trace_routes_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::TracerouteResult>*
GetTraceForTestResponse::_internal_mutable_trace_routes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.trace_routes_;
}

// .kentik.synthetics.v202101beta1.TracerouteInfo trace_routes_info = 3 [json_name = "traceRoutesInfo"];
inline bool GetTraceForTestResponse::has_trace_routes_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trace_routes_info_ != nullptr);
  return value;
}
inline void GetTraceForTestResponse::clear_trace_routes_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trace_routes_info_ != nullptr) _impl_.trace_routes_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::synthetics::v202101beta1::TracerouteInfo& GetTraceForTestResponse::_internal_trace_routes_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::TracerouteInfo* p = _impl_.trace_routes_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::TracerouteInfo&>(::kentik::synthetics::v202101beta1::_TracerouteInfo_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::TracerouteInfo& GetTraceForTestResponse::trace_routes_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes_info)
  return _internal_trace_routes_info();
}
inline void GetTraceForTestResponse::unsafe_arena_set_allocated_trace_routes_info(::kentik::synthetics::v202101beta1::TracerouteInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trace_routes_info_);
  }
  _impl_.trace_routes_info_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TracerouteInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes_info)
}
inline ::kentik::synthetics::v202101beta1::TracerouteInfo* GetTraceForTestResponse::release_trace_routes_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::TracerouteInfo* released = _impl_.trace_routes_info_;
  _impl_.trace_routes_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::TracerouteInfo* GetTraceForTestResponse::unsafe_arena_release_trace_routes_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::synthetics::v202101beta1::TracerouteInfo* temp = _impl_.trace_routes_info_;
  _impl_.trace_routes_info_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::TracerouteInfo* GetTraceForTestResponse::_internal_mutable_trace_routes_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trace_routes_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::TracerouteInfo>(GetArena());
    _impl_.trace_routes_info_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TracerouteInfo*>(p);
  }
  return _impl_.trace_routes_info_;
}
inline ::kentik::synthetics::v202101beta1::TracerouteInfo* GetTraceForTestResponse::mutable_trace_routes_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::synthetics::v202101beta1::TracerouteInfo* _msg = _internal_mutable_trace_routes_info();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes_info)
  return _msg;
}
inline void GetTraceForTestResponse::set_allocated_trace_routes_info(::kentik::synthetics::v202101beta1::TracerouteInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trace_routes_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.trace_routes_info_ = reinterpret_cast<::kentik::synthetics::v202101beta1::TracerouteInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTraceForTestResponse.trace_routes_info)
}

// -------------------------------------------------------------------

// ListAgentsRequest

// -------------------------------------------------------------------

// ListAgentsResponse

// repeated .kentik.synthetics.v202101beta1.Agent agents = 1 [json_name = "agents"];
inline int ListAgentsResponse::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int ListAgentsResponse::agents_size() const {
  return _internal_agents_size();
}
inline void ListAgentsResponse::clear_agents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agents_.Clear();
}
inline ::kentik::synthetics::v202101beta1::Agent* ListAgentsResponse::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.ListAgentsResponse.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>* ListAgentsResponse::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.ListAgentsResponse.agents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_agents();
}
inline const ::kentik::synthetics::v202101beta1::Agent& ListAgentsResponse::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ListAgentsResponse.agents)
  return _internal_agents().Get(index);
}
inline ::kentik::synthetics::v202101beta1::Agent* ListAgentsResponse::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::Agent* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.ListAgentsResponse.agents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>& ListAgentsResponse::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.ListAgentsResponse.agents)
  return _internal_agents();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>&
ListAgentsResponse::_internal_agents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agents_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Agent>*
ListAgentsResponse::_internal_mutable_agents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.agents_;
}

// uint32 invalid_agents_count = 2 [json_name = "invalidAgentsCount"];
inline void ListAgentsResponse::clear_invalid_agents_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_agents_count_ = 0u;
}
inline ::uint32_t ListAgentsResponse::invalid_agents_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ListAgentsResponse.invalid_agents_count)
  return _internal_invalid_agents_count();
}
inline void ListAgentsResponse::set_invalid_agents_count(::uint32_t value) {
  _internal_set_invalid_agents_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ListAgentsResponse.invalid_agents_count)
}
inline ::uint32_t ListAgentsResponse::_internal_invalid_agents_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invalid_agents_count_;
}
inline void ListAgentsResponse::_internal_set_invalid_agents_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_agents_count_ = value;
}

// -------------------------------------------------------------------

// GetAgentRequest

// string id = 1 [json_name = "id"];
inline void GetAgentRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetAgentRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetAgentRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAgentRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetAgentRequest.id)
}
inline std::string* GetAgentRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetAgentRequest.id)
  return _s;
}
inline const std::string& GetAgentRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetAgentRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetAgentRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetAgentRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetAgentRequest.id)
  return _impl_.id_.Release();
}
inline void GetAgentRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetAgentRequest.id)
}

// -------------------------------------------------------------------

// GetAgentResponse

// .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
inline bool GetAgentResponse::has_agent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.agent_ != nullptr);
  return value;
}
inline void GetAgentResponse::clear_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ != nullptr) _impl_.agent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Agent& GetAgentResponse::_internal_agent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Agent* p = _impl_.agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Agent&>(::kentik::synthetics::v202101beta1::_Agent_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Agent& GetAgentResponse::agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetAgentResponse.agent)
  return _internal_agent();
}
inline void GetAgentResponse::unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.agent_);
  }
  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetAgentResponse.agent)
}
inline ::kentik::synthetics::v202101beta1::Agent* GetAgentResponse::release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* released = _impl_.agent_;
  _impl_.agent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Agent* GetAgentResponse::unsafe_arena_release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetAgentResponse.agent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* temp = _impl_.agent_;
  _impl_.agent_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Agent* GetAgentResponse::_internal_mutable_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Agent>(GetArena());
    _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(p);
  }
  return _impl_.agent_;
}
inline ::kentik::synthetics::v202101beta1::Agent* GetAgentResponse::mutable_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* _msg = _internal_mutable_agent();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetAgentResponse.agent)
  return _msg;
}
inline void GetAgentResponse::set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.agent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetAgentResponse.agent)
}

// -------------------------------------------------------------------

// PatchAgentRequest

// .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
inline bool PatchAgentRequest::has_agent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.agent_ != nullptr);
  return value;
}
inline void PatchAgentRequest::clear_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ != nullptr) _impl_.agent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Agent& PatchAgentRequest::_internal_agent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Agent* p = _impl_.agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Agent&>(::kentik::synthetics::v202101beta1::_Agent_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Agent& PatchAgentRequest::agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PatchAgentRequest.agent)
  return _internal_agent();
}
inline void PatchAgentRequest::unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.agent_);
  }
  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.PatchAgentRequest.agent)
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentRequest::release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* released = _impl_.agent_;
  _impl_.agent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentRequest::unsafe_arena_release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PatchAgentRequest.agent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* temp = _impl_.agent_;
  _impl_.agent_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentRequest::_internal_mutable_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Agent>(GetArena());
    _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(p);
  }
  return _impl_.agent_;
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentRequest::mutable_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* _msg = _internal_mutable_agent();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PatchAgentRequest.agent)
  return _msg;
}
inline void PatchAgentRequest::set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.agent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PatchAgentRequest.agent)
}

// .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
inline bool PatchAgentRequest::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& PatchAgentRequest::_internal_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FieldMask* p = _impl_.mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& PatchAgentRequest::mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PatchAgentRequest.mask)
  return _internal_mask();
}
inline void PatchAgentRequest::unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }
  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.PatchAgentRequest.mask)
}
inline ::google::protobuf::FieldMask* PatchAgentRequest::release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.mask_;
  _impl_.mask_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::FieldMask* PatchAgentRequest::unsafe_arena_release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PatchAgentRequest.mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* PatchAgentRequest::_internal_mutable_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FieldMask>(GetArena());
    _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.mask_;
}
inline ::google::protobuf::FieldMask* PatchAgentRequest::mutable_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FieldMask* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PatchAgentRequest.mask)
  return _msg;
}
inline void PatchAgentRequest::set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PatchAgentRequest.mask)
}

// -------------------------------------------------------------------

// PatchAgentResponse

// .kentik.synthetics.v202101beta1.Agent agent = 1 [json_name = "agent"];
inline bool PatchAgentResponse::has_agent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.agent_ != nullptr);
  return value;
}
inline void PatchAgentResponse::clear_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ != nullptr) _impl_.agent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Agent& PatchAgentResponse::_internal_agent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Agent* p = _impl_.agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Agent&>(::kentik::synthetics::v202101beta1::_Agent_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Agent& PatchAgentResponse::agent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PatchAgentResponse.agent)
  return _internal_agent();
}
inline void PatchAgentResponse::unsafe_arena_set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.agent_);
  }
  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.PatchAgentResponse.agent)
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentResponse::release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* released = _impl_.agent_;
  _impl_.agent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentResponse::unsafe_arena_release_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PatchAgentResponse.agent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* temp = _impl_.agent_;
  _impl_.agent_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentResponse::_internal_mutable_agent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.agent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Agent>(GetArena());
    _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(p);
  }
  return _impl_.agent_;
}
inline ::kentik::synthetics::v202101beta1::Agent* PatchAgentResponse::mutable_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Agent* _msg = _internal_mutable_agent();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PatchAgentResponse.agent)
  return _msg;
}
inline void PatchAgentResponse::set_allocated_agent(::kentik::synthetics::v202101beta1::Agent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.agent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.agent_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Agent*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PatchAgentResponse.agent)
}

// -------------------------------------------------------------------

// DeleteAgentRequest

// string id = 1 [json_name = "id"];
inline void DeleteAgentRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteAgentRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DeleteAgentRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteAgentRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DeleteAgentRequest.id)
}
inline std::string* DeleteAgentRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DeleteAgentRequest.id)
  return _s;
}
inline const std::string& DeleteAgentRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void DeleteAgentRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DeleteAgentRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DeleteAgentRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DeleteAgentRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteAgentRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DeleteAgentRequest.id)
}

// -------------------------------------------------------------------

// DeleteAgentResponse

// -------------------------------------------------------------------

// ListTestsRequest

// bool preset = 1 [json_name = "preset"];
inline void ListTestsRequest::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_ = false;
}
inline bool ListTestsRequest::preset() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ListTestsRequest.preset)
  return _internal_preset();
}
inline void ListTestsRequest::set_preset(bool value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ListTestsRequest.preset)
}
inline bool ListTestsRequest::_internal_preset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preset_;
}
inline void ListTestsRequest::_internal_set_preset(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preset_ = value;
}

// -------------------------------------------------------------------

// ListTestsResponse

// repeated .kentik.synthetics.v202101beta1.Test tests = 1 [json_name = "tests"];
inline int ListTestsResponse::_internal_tests_size() const {
  return _internal_tests().size();
}
inline int ListTestsResponse::tests_size() const {
  return _internal_tests_size();
}
inline void ListTestsResponse::clear_tests() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tests_.Clear();
}
inline ::kentik::synthetics::v202101beta1::Test* ListTestsResponse::mutable_tests(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.ListTestsResponse.tests)
  return _internal_mutable_tests()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>* ListTestsResponse::mutable_tests()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.synthetics.v202101beta1.ListTestsResponse.tests)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tests();
}
inline const ::kentik::synthetics::v202101beta1::Test& ListTestsResponse::tests(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ListTestsResponse.tests)
  return _internal_tests().Get(index);
}
inline ::kentik::synthetics::v202101beta1::Test* ListTestsResponse::add_tests() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::synthetics::v202101beta1::Test* _add = _internal_mutable_tests()->Add();
  // @@protoc_insertion_point(field_add:kentik.synthetics.v202101beta1.ListTestsResponse.tests)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>& ListTestsResponse::tests() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.synthetics.v202101beta1.ListTestsResponse.tests)
  return _internal_tests();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>&
ListTestsResponse::_internal_tests() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tests_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::synthetics::v202101beta1::Test>*
ListTestsResponse::_internal_mutable_tests() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tests_;
}

// uint32 invalid_tests_count = 2 [json_name = "invalidTestsCount"];
inline void ListTestsResponse::clear_invalid_tests_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_tests_count_ = 0u;
}
inline ::uint32_t ListTestsResponse::invalid_tests_count() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.ListTestsResponse.invalid_tests_count)
  return _internal_invalid_tests_count();
}
inline void ListTestsResponse::set_invalid_tests_count(::uint32_t value) {
  _internal_set_invalid_tests_count(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.ListTestsResponse.invalid_tests_count)
}
inline ::uint32_t ListTestsResponse::_internal_invalid_tests_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invalid_tests_count_;
}
inline void ListTestsResponse::_internal_set_invalid_tests_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invalid_tests_count_ = value;
}

// -------------------------------------------------------------------

// CreateTestRequest

// .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
inline bool CreateTestRequest::has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_ != nullptr);
  return value;
}
inline void CreateTestRequest::clear_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ != nullptr) _impl_.test_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Test& CreateTestRequest::_internal_test() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Test* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Test&>(::kentik::synthetics::v202101beta1::_Test_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Test& CreateTestRequest::test() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.CreateTestRequest.test)
  return _internal_test();
}
inline void CreateTestRequest::unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.CreateTestRequest.test)
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestRequest::release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* released = _impl_.test_;
  _impl_.test_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestRequest::unsafe_arena_release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.CreateTestRequest.test)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestRequest::_internal_mutable_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Test>(GetArena());
    _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(p);
  }
  return _impl_.test_;
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestRequest::mutable_test() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.CreateTestRequest.test)
  return _msg;
}
inline void CreateTestRequest::set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.test_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.CreateTestRequest.test)
}

// -------------------------------------------------------------------

// CreateTestResponse

// .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
inline bool CreateTestResponse::has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_ != nullptr);
  return value;
}
inline void CreateTestResponse::clear_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ != nullptr) _impl_.test_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Test& CreateTestResponse::_internal_test() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Test* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Test&>(::kentik::synthetics::v202101beta1::_Test_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Test& CreateTestResponse::test() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.CreateTestResponse.test)
  return _internal_test();
}
inline void CreateTestResponse::unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.CreateTestResponse.test)
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestResponse::release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* released = _impl_.test_;
  _impl_.test_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestResponse::unsafe_arena_release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.CreateTestResponse.test)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestResponse::_internal_mutable_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Test>(GetArena());
    _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(p);
  }
  return _impl_.test_;
}
inline ::kentik::synthetics::v202101beta1::Test* CreateTestResponse::mutable_test() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.CreateTestResponse.test)
  return _msg;
}
inline void CreateTestResponse::set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.test_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.CreateTestResponse.test)
}

// -------------------------------------------------------------------

// GetTestRequest

// string id = 1 [json_name = "id"];
inline void GetTestRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetTestRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTestRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTestRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.GetTestRequest.id)
}
inline std::string* GetTestRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTestRequest.id)
  return _s;
}
inline const std::string& GetTestRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetTestRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetTestRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetTestRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTestRequest.id)
  return _impl_.id_.Release();
}
inline void GetTestRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTestRequest.id)
}

// -------------------------------------------------------------------

// GetTestResponse

// .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
inline bool GetTestResponse::has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_ != nullptr);
  return value;
}
inline void GetTestResponse::clear_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ != nullptr) _impl_.test_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Test& GetTestResponse::_internal_test() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Test* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Test&>(::kentik::synthetics::v202101beta1::_Test_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Test& GetTestResponse::test() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.GetTestResponse.test)
  return _internal_test();
}
inline void GetTestResponse::unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.GetTestResponse.test)
}
inline ::kentik::synthetics::v202101beta1::Test* GetTestResponse::release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* released = _impl_.test_;
  _impl_.test_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Test* GetTestResponse::unsafe_arena_release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.GetTestResponse.test)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Test* GetTestResponse::_internal_mutable_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Test>(GetArena());
    _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(p);
  }
  return _impl_.test_;
}
inline ::kentik::synthetics::v202101beta1::Test* GetTestResponse::mutable_test() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.GetTestResponse.test)
  return _msg;
}
inline void GetTestResponse::set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.test_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.GetTestResponse.test)
}

// -------------------------------------------------------------------

// SetTestStatusRequest

// string id = 1 [json_name = "id"];
inline void SetTestStatusRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SetTestStatusRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.SetTestStatusRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetTestStatusRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.SetTestStatusRequest.id)
}
inline std::string* SetTestStatusRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.SetTestStatusRequest.id)
  return _s;
}
inline const std::string& SetTestStatusRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void SetTestStatusRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SetTestStatusRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SetTestStatusRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.SetTestStatusRequest.id)
  return _impl_.id_.Release();
}
inline void SetTestStatusRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.SetTestStatusRequest.id)
}

// .kentik.synthetics.v202101beta1.TestStatus status = 2 [json_name = "status"];
inline void SetTestStatusRequest::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::kentik::synthetics::v202101beta1::TestStatus SetTestStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.SetTestStatusRequest.status)
  return _internal_status();
}
inline void SetTestStatusRequest::set_status(::kentik::synthetics::v202101beta1::TestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.SetTestStatusRequest.status)
}
inline ::kentik::synthetics::v202101beta1::TestStatus SetTestStatusRequest::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::synthetics::v202101beta1::TestStatus>(_impl_.status_);
}
inline void SetTestStatusRequest::_internal_set_status(::kentik::synthetics::v202101beta1::TestStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// SetTestStatusResponse

// -------------------------------------------------------------------

// PatchTestRequest

// .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
inline bool PatchTestRequest::has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_ != nullptr);
  return value;
}
inline void PatchTestRequest::clear_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ != nullptr) _impl_.test_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Test& PatchTestRequest::_internal_test() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Test* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Test&>(::kentik::synthetics::v202101beta1::_Test_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Test& PatchTestRequest::test() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PatchTestRequest.test)
  return _internal_test();
}
inline void PatchTestRequest::unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.PatchTestRequest.test)
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestRequest::release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* released = _impl_.test_;
  _impl_.test_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestRequest::unsafe_arena_release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PatchTestRequest.test)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestRequest::_internal_mutable_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Test>(GetArena());
    _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(p);
  }
  return _impl_.test_;
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestRequest::mutable_test() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PatchTestRequest.test)
  return _msg;
}
inline void PatchTestRequest::set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.test_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PatchTestRequest.test)
}

// .google.protobuf.FieldMask mask = 2 [json_name = "mask"];
inline bool PatchTestRequest::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& PatchTestRequest::_internal_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FieldMask* p = _impl_.mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& PatchTestRequest::mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PatchTestRequest.mask)
  return _internal_mask();
}
inline void PatchTestRequest::unsafe_arena_set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }
  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.PatchTestRequest.mask)
}
inline ::google::protobuf::FieldMask* PatchTestRequest::release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.mask_;
  _impl_.mask_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::FieldMask* PatchTestRequest::unsafe_arena_release_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PatchTestRequest.mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* PatchTestRequest::_internal_mutable_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FieldMask>(GetArena());
    _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.mask_;
}
inline ::google::protobuf::FieldMask* PatchTestRequest::mutable_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FieldMask* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PatchTestRequest.mask)
  return _msg;
}
inline void PatchTestRequest::set_allocated_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PatchTestRequest.mask)
}

// -------------------------------------------------------------------

// PatchTestResponse

// .kentik.synthetics.v202101beta1.Test test = 1 [json_name = "test"];
inline bool PatchTestResponse::has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_ != nullptr);
  return value;
}
inline void PatchTestResponse::clear_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ != nullptr) _impl_.test_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::synthetics::v202101beta1::Test& PatchTestResponse::_internal_test() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::synthetics::v202101beta1::Test* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::synthetics::v202101beta1::Test&>(::kentik::synthetics::v202101beta1::_Test_default_instance_);
}
inline const ::kentik::synthetics::v202101beta1::Test& PatchTestResponse::test() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.PatchTestResponse.test)
  return _internal_test();
}
inline void PatchTestResponse::unsafe_arena_set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.synthetics.v202101beta1.PatchTestResponse.test)
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestResponse::release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* released = _impl_.test_;
  _impl_.test_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestResponse::unsafe_arena_release_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.PatchTestResponse.test)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestResponse::_internal_mutable_test() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.test_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::synthetics::v202101beta1::Test>(GetArena());
    _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(p);
  }
  return _impl_.test_;
}
inline ::kentik::synthetics::v202101beta1::Test* PatchTestResponse::mutable_test() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::synthetics::v202101beta1::Test* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.PatchTestResponse.test)
  return _msg;
}
inline void PatchTestResponse::set_allocated_test(::kentik::synthetics::v202101beta1::Test* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.test_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.test_ = reinterpret_cast<::kentik::synthetics::v202101beta1::Test*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.PatchTestResponse.test)
}

// -------------------------------------------------------------------

// DeleteTestRequest

// string id = 1 [json_name = "id"];
inline void DeleteTestRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteTestRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.synthetics.v202101beta1.DeleteTestRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteTestRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.synthetics.v202101beta1.DeleteTestRequest.id)
}
inline std::string* DeleteTestRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kentik.synthetics.v202101beta1.DeleteTestRequest.id)
  return _s;
}
inline const std::string& DeleteTestRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void DeleteTestRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DeleteTestRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DeleteTestRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.synthetics.v202101beta1.DeleteTestRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteTestRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.synthetics.v202101beta1.DeleteTestRequest.id)
}

// -------------------------------------------------------------------

// DeleteTestResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v202101beta1
}  // namespace synthetics
}  // namespace kentik


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::kentik::synthetics::v202101beta1::ImplementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::synthetics::v202101beta1::ImplementType>() {
  return ::kentik::synthetics::v202101beta1::ImplementType_descriptor();
}
template <>
struct is_proto_enum<::kentik::synthetics::v202101beta1::IPFamily> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::synthetics::v202101beta1::IPFamily>() {
  return ::kentik::synthetics::v202101beta1::IPFamily_descriptor();
}
template <>
struct is_proto_enum<::kentik::synthetics::v202101beta1::TestStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::synthetics::v202101beta1::TestStatus>() {
  return ::kentik::synthetics::v202101beta1::TestStatus_descriptor();
}
template <>
struct is_proto_enum<::kentik::synthetics::v202101beta1::AgentStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::synthetics::v202101beta1::AgentStatus>() {
  return ::kentik::synthetics::v202101beta1::AgentStatus_descriptor();
}
template <>
struct is_proto_enum<::kentik::synthetics::v202101beta1::TaskState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::synthetics::v202101beta1::TaskState>() {
  return ::kentik::synthetics::v202101beta1::TaskState_descriptor();
}
template <>
struct is_proto_enum<::kentik::synthetics::v202101beta1::DNSRecord> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::synthetics::v202101beta1::DNSRecord>() {
  return ::kentik::synthetics::v202101beta1::DNSRecord_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // kentik_2fsynthetics_2fv202101beta1_2fsynthetics_2eproto_2epb_2eh
