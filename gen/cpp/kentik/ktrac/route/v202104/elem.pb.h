// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kentik/ktrac/route/v202104/elem.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kentik_2fktrac_2froute_2fv202104_2felem_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kentik_2fktrac_2froute_2fv202104_2felem_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/api/field_behavior.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kentik_2fktrac_2froute_2fv202104_2felem_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
namespace kentik {
namespace ktrac {
namespace route {
namespace v202104 {
class Attributes;
class AttributesDefaultTypeInternal;
extern AttributesDefaultTypeInternal _Attributes_default_instance_;
class Elem;
class ElemDefaultTypeInternal;
extern ElemDefaultTypeInternal _Elem_default_instance_;
class L3vpnNlri;
class L3vpnNlriDefaultTypeInternal;
extern L3vpnNlriDefaultTypeInternal _L3vpnNlri_default_instance_;
class MplsLabelStack;
class MplsLabelStackDefaultTypeInternal;
extern MplsLabelStackDefaultTypeInternal _MplsLabelStack_default_instance_;
class PeerStateElem;
class PeerStateElemDefaultTypeInternal;
extern PeerStateElemDefaultTypeInternal _PeerStateElem_default_instance_;
class RibEntry;
class RibEntryDefaultTypeInternal;
extern RibEntryDefaultTypeInternal _RibEntry_default_instance_;
class UnicastNlri;
class UnicastNlriDefaultTypeInternal;
extern UnicastNlriDefaultTypeInternal _UnicastNlri_default_instance_;
class VantagePoint;
class VantagePointDefaultTypeInternal;
extern VantagePointDefaultTypeInternal _VantagePoint_default_instance_;
class VantagePointTable;
class VantagePointTableDefaultTypeInternal;
extern VantagePointTableDefaultTypeInternal _VantagePointTable_default_instance_;
}  // namespace v202104
}  // namespace route
}  // namespace ktrac
}  // namespace kentik
PROTOBUF_NAMESPACE_OPEN
template<> ::kentik::ktrac::route::v202104::Attributes* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::Attributes>(Arena*);
template<> ::kentik::ktrac::route::v202104::Elem* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::Elem>(Arena*);
template<> ::kentik::ktrac::route::v202104::L3vpnNlri* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::L3vpnNlri>(Arena*);
template<> ::kentik::ktrac::route::v202104::MplsLabelStack* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::MplsLabelStack>(Arena*);
template<> ::kentik::ktrac::route::v202104::PeerStateElem* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::PeerStateElem>(Arena*);
template<> ::kentik::ktrac::route::v202104::RibEntry* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::RibEntry>(Arena*);
template<> ::kentik::ktrac::route::v202104::UnicastNlri* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::UnicastNlri>(Arena*);
template<> ::kentik::ktrac::route::v202104::VantagePoint* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::VantagePoint>(Arena*);
template<> ::kentik::ktrac::route::v202104::VantagePointTable* Arena::CreateMaybeMessage<::kentik::ktrac::route::v202104::VantagePointTable>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kentik {
namespace ktrac {
namespace route {
namespace v202104 {

enum RecordType : int {
  RECORD_TYPE_UNSPECIFIED = 0,
  RECORD_TYPE_UPDATE = 1,
  RECORD_TYPE_RIB = 2,
  RecordType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RecordType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RecordType_IsValid(int value);
constexpr RecordType RecordType_MIN = RECORD_TYPE_UNSPECIFIED;
constexpr RecordType RecordType_MAX = RECORD_TYPE_RIB;
constexpr int RecordType_ARRAYSIZE = RecordType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordType_descriptor();
template<typename T>
inline const std::string& RecordType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordType_descriptor(), enum_t_value);
}
inline bool RecordType_Parse(
    const std::string& name, RecordType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordType>(
    RecordType_descriptor(), name, value);
}
enum Afi : int {
  AFI_UNSPECIFIED = 0,
  AFI_IP4 = 1,
  AFI_IP6 = 2,
  Afi_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Afi_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Afi_IsValid(int value);
constexpr Afi Afi_MIN = AFI_UNSPECIFIED;
constexpr Afi Afi_MAX = AFI_IP6;
constexpr int Afi_ARRAYSIZE = Afi_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Afi_descriptor();
template<typename T>
inline const std::string& Afi_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Afi>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Afi_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Afi_descriptor(), enum_t_value);
}
inline bool Afi_Parse(
    const std::string& name, Afi* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Afi>(
    Afi_descriptor(), name, value);
}
enum Safi : int {
  SAFI_UNSPECIFIED = 0,
  SAFI_UNICAST = 1,
  SAFI_MPLS = 4,
  SAFI_L3VPN = 128,
  Safi_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Safi_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Safi_IsValid(int value);
constexpr Safi Safi_MIN = SAFI_UNSPECIFIED;
constexpr Safi Safi_MAX = SAFI_L3VPN;
constexpr int Safi_ARRAYSIZE = Safi_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Safi_descriptor();
template<typename T>
inline const std::string& Safi_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Safi>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Safi_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Safi_descriptor(), enum_t_value);
}
inline bool Safi_Parse(
    const std::string& name, Safi* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Safi>(
    Safi_descriptor(), name, value);
}
enum Origin : int {
  ORIGIN_UNSPECIFIED = 0,
  ORIGIN_IGP = 10,
  ORIGIN_EGP = 11,
  ORIGIN_INCOMPLETE = 12,
  Origin_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Origin_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Origin_IsValid(int value);
constexpr Origin Origin_MIN = ORIGIN_UNSPECIFIED;
constexpr Origin Origin_MAX = ORIGIN_INCOMPLETE;
constexpr int Origin_ARRAYSIZE = Origin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Origin_descriptor();
template<typename T>
inline const std::string& Origin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Origin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Origin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Origin_descriptor(), enum_t_value);
}
inline bool Origin_Parse(
    const std::string& name, Origin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Origin>(
    Origin_descriptor(), name, value);
}
enum ElemType : int {
  ELEM_TYPE_UNSPECIFIED = 0,
  ELEM_TYPE_PEERSTATE = 10,
  ELEM_TYPE_ANNOUNCEMENT = 11,
  ELEM_TYPE_WITHDRAWAL = 12,
  ELEM_TYPE_RIB_ENTRY = 13,
  ELEM_TYPE_SYNC = 14,
  ElemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ElemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ElemType_IsValid(int value);
constexpr ElemType ElemType_MIN = ELEM_TYPE_UNSPECIFIED;
constexpr ElemType ElemType_MAX = ELEM_TYPE_SYNC;
constexpr int ElemType_ARRAYSIZE = ElemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ElemType_descriptor();
template<typename T>
inline const std::string& ElemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ElemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ElemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ElemType_descriptor(), enum_t_value);
}
inline bool ElemType_Parse(
    const std::string& name, ElemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ElemType>(
    ElemType_descriptor(), name, value);
}
enum PeerState : int {
  PEER_STATE_UNSPECIFIED = 0,
  PEER_STATE_UP = 10,
  PEER_STATE_DOWN = 11,
  PeerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PeerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PeerState_IsValid(int value);
constexpr PeerState PeerState_MIN = PEER_STATE_UNSPECIFIED;
constexpr PeerState PeerState_MAX = PEER_STATE_DOWN;
constexpr int PeerState_ARRAYSIZE = PeerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerState_descriptor();
template<typename T>
inline const std::string& PeerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeerState_descriptor(), enum_t_value);
}
inline bool PeerState_Parse(
    const std::string& name, PeerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeerState>(
    PeerState_descriptor(), name, value);
}
enum DumpPosition : int {
  DUMP_POSITION_UNSPECIFIED = 0,
  DUMP_POSITION_START = 1,
  DUMP_POSITION_MID = 2,
  DUMP_POSITION_END = 3,
  DumpPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DumpPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DumpPosition_IsValid(int value);
constexpr DumpPosition DumpPosition_MIN = DUMP_POSITION_UNSPECIFIED;
constexpr DumpPosition DumpPosition_MAX = DUMP_POSITION_END;
constexpr int DumpPosition_ARRAYSIZE = DumpPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DumpPosition_descriptor();
template<typename T>
inline const std::string& DumpPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DumpPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DumpPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DumpPosition_descriptor(), enum_t_value);
}
inline bool DumpPosition_Parse(
    const std::string& name, DumpPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DumpPosition>(
    DumpPosition_descriptor(), name, value);
}
// ===================================================================

class Elem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.Elem) */ {
 public:
  inline Elem() : Elem(nullptr) {};
  virtual ~Elem();

  Elem(const Elem& from);
  Elem(Elem&& from) noexcept
    : Elem() {
    *this = ::std::move(from);
  }

  inline Elem& operator=(const Elem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Elem& operator=(Elem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Elem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Elem* internal_default_instance() {
    return reinterpret_cast<const Elem*>(
               &_Elem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Elem& a, Elem& b) {
    a.Swap(&b);
  }
  inline void Swap(Elem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Elem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Elem* New() const final {
    return CreateMaybeMessage<Elem>(nullptr);
  }

  Elem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Elem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Elem& from);
  void MergeFrom(const Elem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Elem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.Elem";
  }
  protected:
  explicit Elem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnicastNlrisFieldNumber = 9,
    kL3VpnNlrisFieldNumber = 10,
    kMessageIdFieldNumber = 4,
    kTimeFieldNumber = 1,
    kVantagePointFieldNumber = 3,
    kPeerStateFieldNumber = 11,
    kAttributesFieldNumber = 12,
    kRibEntryFieldNumber = 13,
    kRecordTypeFieldNumber = 2,
    kAfiFieldNumber = 6,
    kSerialFieldNumber = 5,
    kSafiFieldNumber = 7,
    kTypeFieldNumber = 8,
  };
  // repeated .kentik.ktrac.route.v202104.UnicastNlri unicast_nlris = 9[json_name = "unicastNlris"];
  int unicast_nlris_size() const;
  private:
  int _internal_unicast_nlris_size() const;
  public:
  void clear_unicast_nlris();
  ::kentik::ktrac::route::v202104::UnicastNlri* mutable_unicast_nlris(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::UnicastNlri >*
      mutable_unicast_nlris();
  private:
  const ::kentik::ktrac::route::v202104::UnicastNlri& _internal_unicast_nlris(int index) const;
  ::kentik::ktrac::route::v202104::UnicastNlri* _internal_add_unicast_nlris();
  public:
  const ::kentik::ktrac::route::v202104::UnicastNlri& unicast_nlris(int index) const;
  ::kentik::ktrac::route::v202104::UnicastNlri* add_unicast_nlris();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::UnicastNlri >&
      unicast_nlris() const;

  // repeated .kentik.ktrac.route.v202104.L3vpnNlri l3vpn_nlris = 10[json_name = "l3vpnNlris"];
  int l3vpn_nlris_size() const;
  private:
  int _internal_l3vpn_nlris_size() const;
  public:
  void clear_l3vpn_nlris();
  ::kentik::ktrac::route::v202104::L3vpnNlri* mutable_l3vpn_nlris(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::L3vpnNlri >*
      mutable_l3vpn_nlris();
  private:
  const ::kentik::ktrac::route::v202104::L3vpnNlri& _internal_l3vpn_nlris(int index) const;
  ::kentik::ktrac::route::v202104::L3vpnNlri* _internal_add_l3vpn_nlris();
  public:
  const ::kentik::ktrac::route::v202104::L3vpnNlri& l3vpn_nlris(int index) const;
  ::kentik::ktrac::route::v202104::L3vpnNlri* add_l3vpn_nlris();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::L3vpnNlri >&
      l3vpn_nlris() const;

  // bytes message_id = 4[json_name = "messageId"];
  void clear_message_id();
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const void* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message_id(
      std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .google.protobuf.Timestamp time = 1[json_name = "time"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // .kentik.ktrac.route.v202104.VantagePoint vantage_point = 3[json_name = "vantagePoint"];
  bool has_vantage_point() const;
  private:
  bool _internal_has_vantage_point() const;
  public:
  void clear_vantage_point();
  const ::kentik::ktrac::route::v202104::VantagePoint& vantage_point() const;
  ::kentik::ktrac::route::v202104::VantagePoint* release_vantage_point();
  ::kentik::ktrac::route::v202104::VantagePoint* mutable_vantage_point();
  void set_allocated_vantage_point(::kentik::ktrac::route::v202104::VantagePoint* vantage_point);
  private:
  const ::kentik::ktrac::route::v202104::VantagePoint& _internal_vantage_point() const;
  ::kentik::ktrac::route::v202104::VantagePoint* _internal_mutable_vantage_point();
  public:
  void unsafe_arena_set_allocated_vantage_point(
      ::kentik::ktrac::route::v202104::VantagePoint* vantage_point);
  ::kentik::ktrac::route::v202104::VantagePoint* unsafe_arena_release_vantage_point();

  // .kentik.ktrac.route.v202104.PeerStateElem peer_state = 11[json_name = "peerState"];
  bool has_peer_state() const;
  private:
  bool _internal_has_peer_state() const;
  public:
  void clear_peer_state();
  const ::kentik::ktrac::route::v202104::PeerStateElem& peer_state() const;
  ::kentik::ktrac::route::v202104::PeerStateElem* release_peer_state();
  ::kentik::ktrac::route::v202104::PeerStateElem* mutable_peer_state();
  void set_allocated_peer_state(::kentik::ktrac::route::v202104::PeerStateElem* peer_state);
  private:
  const ::kentik::ktrac::route::v202104::PeerStateElem& _internal_peer_state() const;
  ::kentik::ktrac::route::v202104::PeerStateElem* _internal_mutable_peer_state();
  public:
  void unsafe_arena_set_allocated_peer_state(
      ::kentik::ktrac::route::v202104::PeerStateElem* peer_state);
  ::kentik::ktrac::route::v202104::PeerStateElem* unsafe_arena_release_peer_state();

  // .kentik.ktrac.route.v202104.Attributes attributes = 12[json_name = "attributes"];
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::kentik::ktrac::route::v202104::Attributes& attributes() const;
  ::kentik::ktrac::route::v202104::Attributes* release_attributes();
  ::kentik::ktrac::route::v202104::Attributes* mutable_attributes();
  void set_allocated_attributes(::kentik::ktrac::route::v202104::Attributes* attributes);
  private:
  const ::kentik::ktrac::route::v202104::Attributes& _internal_attributes() const;
  ::kentik::ktrac::route::v202104::Attributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::kentik::ktrac::route::v202104::Attributes* attributes);
  ::kentik::ktrac::route::v202104::Attributes* unsafe_arena_release_attributes();

  // .kentik.ktrac.route.v202104.RibEntry rib_entry = 13[json_name = "ribEntry"];
  bool has_rib_entry() const;
  private:
  bool _internal_has_rib_entry() const;
  public:
  void clear_rib_entry();
  const ::kentik::ktrac::route::v202104::RibEntry& rib_entry() const;
  ::kentik::ktrac::route::v202104::RibEntry* release_rib_entry();
  ::kentik::ktrac::route::v202104::RibEntry* mutable_rib_entry();
  void set_allocated_rib_entry(::kentik::ktrac::route::v202104::RibEntry* rib_entry);
  private:
  const ::kentik::ktrac::route::v202104::RibEntry& _internal_rib_entry() const;
  ::kentik::ktrac::route::v202104::RibEntry* _internal_mutable_rib_entry();
  public:
  void unsafe_arena_set_allocated_rib_entry(
      ::kentik::ktrac::route::v202104::RibEntry* rib_entry);
  ::kentik::ktrac::route::v202104::RibEntry* unsafe_arena_release_rib_entry();

  // .kentik.ktrac.route.v202104.RecordType record_type = 2[json_name = "recordType"];
  void clear_record_type();
  ::kentik::ktrac::route::v202104::RecordType record_type() const;
  void set_record_type(::kentik::ktrac::route::v202104::RecordType value);
  private:
  ::kentik::ktrac::route::v202104::RecordType _internal_record_type() const;
  void _internal_set_record_type(::kentik::ktrac::route::v202104::RecordType value);
  public:

  // .kentik.ktrac.route.v202104.Afi afi = 6[json_name = "afi"];
  void clear_afi();
  ::kentik::ktrac::route::v202104::Afi afi() const;
  void set_afi(::kentik::ktrac::route::v202104::Afi value);
  private:
  ::kentik::ktrac::route::v202104::Afi _internal_afi() const;
  void _internal_set_afi(::kentik::ktrac::route::v202104::Afi value);
  public:

  // uint64 serial = 5[json_name = "serial"];
  void clear_serial();
  ::PROTOBUF_NAMESPACE_ID::uint64 serial() const;
  void set_serial(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_serial() const;
  void _internal_set_serial(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .kentik.ktrac.route.v202104.Safi safi = 7[json_name = "safi"];
  void clear_safi();
  ::kentik::ktrac::route::v202104::Safi safi() const;
  void set_safi(::kentik::ktrac::route::v202104::Safi value);
  private:
  ::kentik::ktrac::route::v202104::Safi _internal_safi() const;
  void _internal_set_safi(::kentik::ktrac::route::v202104::Safi value);
  public:

  // .kentik.ktrac.route.v202104.ElemType type = 8[json_name = "type"];
  void clear_type();
  ::kentik::ktrac::route::v202104::ElemType type() const;
  void set_type(::kentik::ktrac::route::v202104::ElemType value);
  private:
  ::kentik::ktrac::route::v202104::ElemType _internal_type() const;
  void _internal_set_type(::kentik::ktrac::route::v202104::ElemType value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.Elem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::UnicastNlri > unicast_nlris_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::L3vpnNlri > l3vpn_nlris_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  ::kentik::ktrac::route::v202104::VantagePoint* vantage_point_;
  ::kentik::ktrac::route::v202104::PeerStateElem* peer_state_;
  ::kentik::ktrac::route::v202104::Attributes* attributes_;
  ::kentik::ktrac::route::v202104::RibEntry* rib_entry_;
  int record_type_;
  int afi_;
  ::PROTOBUF_NAMESPACE_ID::uint64 serial_;
  int safi_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class VantagePoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.VantagePoint) */ {
 public:
  inline VantagePoint() : VantagePoint(nullptr) {};
  virtual ~VantagePoint();

  VantagePoint(const VantagePoint& from);
  VantagePoint(VantagePoint&& from) noexcept
    : VantagePoint() {
    *this = ::std::move(from);
  }

  inline VantagePoint& operator=(const VantagePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline VantagePoint& operator=(VantagePoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VantagePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VantagePoint* internal_default_instance() {
    return reinterpret_cast<const VantagePoint*>(
               &_VantagePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VantagePoint& a, VantagePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(VantagePoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VantagePoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VantagePoint* New() const final {
    return CreateMaybeMessage<VantagePoint>(nullptr);
  }

  VantagePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VantagePoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VantagePoint& from);
  void MergeFrom(const VantagePoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VantagePoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.VantagePoint";
  }
  protected:
  explicit VantagePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
    kCollectorFieldNumber = 2,
    kPeerIpFieldNumber = 4,
    kPeerAsnFieldNumber = 3,
  };
  // string dataset = 1[json_name = "dataset", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_dataset();
  const std::string& dataset() const;
  void set_dataset(const std::string& value);
  void set_dataset(std::string&& value);
  void set_dataset(const char* value);
  void set_dataset(const char* value, size_t size);
  std::string* mutable_dataset();
  std::string* release_dataset();
  void set_allocated_dataset(std::string* dataset);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_dataset();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_dataset(
      std::string* dataset);
  private:
  const std::string& _internal_dataset() const;
  void _internal_set_dataset(const std::string& value);
  std::string* _internal_mutable_dataset();
  public:

  // string collector = 2[json_name = "collector", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_collector();
  const std::string& collector() const;
  void set_collector(const std::string& value);
  void set_collector(std::string&& value);
  void set_collector(const char* value);
  void set_collector(const char* value, size_t size);
  std::string* mutable_collector();
  std::string* release_collector();
  void set_allocated_collector(std::string* collector);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_collector();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_collector(
      std::string* collector);
  private:
  const std::string& _internal_collector() const;
  void _internal_set_collector(const std::string& value);
  std::string* _internal_mutable_collector();
  public:

  // string peer_ip = 4[json_name = "peerIp", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_peer_ip();
  const std::string& peer_ip() const;
  void set_peer_ip(const std::string& value);
  void set_peer_ip(std::string&& value);
  void set_peer_ip(const char* value);
  void set_peer_ip(const char* value, size_t size);
  std::string* mutable_peer_ip();
  std::string* release_peer_ip();
  void set_allocated_peer_ip(std::string* peer_ip);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_peer_ip();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_peer_ip(
      std::string* peer_ip);
  private:
  const std::string& _internal_peer_ip() const;
  void _internal_set_peer_ip(const std::string& value);
  std::string* _internal_mutable_peer_ip();
  public:

  // uint32 peer_asn = 3[json_name = "peerAsn", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_peer_asn();
  ::PROTOBUF_NAMESPACE_ID::uint32 peer_asn() const;
  void set_peer_asn(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_peer_asn() const;
  void _internal_set_peer_asn(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.VantagePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collector_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 peer_asn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class VantagePointTable PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.VantagePointTable) */ {
 public:
  inline VantagePointTable() : VantagePointTable(nullptr) {};
  virtual ~VantagePointTable();

  VantagePointTable(const VantagePointTable& from);
  VantagePointTable(VantagePointTable&& from) noexcept
    : VantagePointTable() {
    *this = ::std::move(from);
  }

  inline VantagePointTable& operator=(const VantagePointTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline VantagePointTable& operator=(VantagePointTable&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VantagePointTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VantagePointTable* internal_default_instance() {
    return reinterpret_cast<const VantagePointTable*>(
               &_VantagePointTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VantagePointTable& a, VantagePointTable& b) {
    a.Swap(&b);
  }
  inline void Swap(VantagePointTable* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VantagePointTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VantagePointTable* New() const final {
    return CreateMaybeMessage<VantagePointTable>(nullptr);
  }

  VantagePointTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VantagePointTable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VantagePointTable& from);
  void MergeFrom(const VantagePointTable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VantagePointTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.VantagePointTable";
  }
  protected:
  explicit VantagePointTable(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVantagePointFieldNumber = 1,
    kAfiFieldNumber = 2,
    kSafiFieldNumber = 3,
  };
  // .kentik.ktrac.route.v202104.VantagePoint vantage_point = 1[json_name = "vantagePoint"];
  bool has_vantage_point() const;
  private:
  bool _internal_has_vantage_point() const;
  public:
  void clear_vantage_point();
  const ::kentik::ktrac::route::v202104::VantagePoint& vantage_point() const;
  ::kentik::ktrac::route::v202104::VantagePoint* release_vantage_point();
  ::kentik::ktrac::route::v202104::VantagePoint* mutable_vantage_point();
  void set_allocated_vantage_point(::kentik::ktrac::route::v202104::VantagePoint* vantage_point);
  private:
  const ::kentik::ktrac::route::v202104::VantagePoint& _internal_vantage_point() const;
  ::kentik::ktrac::route::v202104::VantagePoint* _internal_mutable_vantage_point();
  public:
  void unsafe_arena_set_allocated_vantage_point(
      ::kentik::ktrac::route::v202104::VantagePoint* vantage_point);
  ::kentik::ktrac::route::v202104::VantagePoint* unsafe_arena_release_vantage_point();

  // .kentik.ktrac.route.v202104.Afi afi = 2[json_name = "afi"];
  void clear_afi();
  ::kentik::ktrac::route::v202104::Afi afi() const;
  void set_afi(::kentik::ktrac::route::v202104::Afi value);
  private:
  ::kentik::ktrac::route::v202104::Afi _internal_afi() const;
  void _internal_set_afi(::kentik::ktrac::route::v202104::Afi value);
  public:

  // .kentik.ktrac.route.v202104.Safi safi = 3[json_name = "safi"];
  void clear_safi();
  ::kentik::ktrac::route::v202104::Safi safi() const;
  void set_safi(::kentik::ktrac::route::v202104::Safi value);
  private:
  ::kentik::ktrac::route::v202104::Safi _internal_safi() const;
  void _internal_set_safi(::kentik::ktrac::route::v202104::Safi value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.VantagePointTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::ktrac::route::v202104::VantagePoint* vantage_point_;
  int afi_;
  int safi_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class UnicastNlri PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.UnicastNlri) */ {
 public:
  inline UnicastNlri() : UnicastNlri(nullptr) {};
  virtual ~UnicastNlri();

  UnicastNlri(const UnicastNlri& from);
  UnicastNlri(UnicastNlri&& from) noexcept
    : UnicastNlri() {
    *this = ::std::move(from);
  }

  inline UnicastNlri& operator=(const UnicastNlri& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnicastNlri& operator=(UnicastNlri&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnicastNlri& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnicastNlri* internal_default_instance() {
    return reinterpret_cast<const UnicastNlri*>(
               &_UnicastNlri_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UnicastNlri& a, UnicastNlri& b) {
    a.Swap(&b);
  }
  inline void Swap(UnicastNlri* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnicastNlri* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnicastNlri* New() const final {
    return CreateMaybeMessage<UnicastNlri>(nullptr);
  }

  UnicastNlri* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnicastNlri>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnicastNlri& from);
  void MergeFrom(const UnicastNlri& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnicastNlri* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.UnicastNlri";
  }
  protected:
  explicit UnicastNlri(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
  };
  // string prefix = 1[json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  void set_prefix(const std::string& value);
  void set_prefix(std::string&& value);
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  std::string* mutable_prefix();
  std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_prefix();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_prefix(
      std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.UnicastNlri)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class L3vpnNlri PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.L3vpnNlri) */ {
 public:
  inline L3vpnNlri() : L3vpnNlri(nullptr) {};
  virtual ~L3vpnNlri();

  L3vpnNlri(const L3vpnNlri& from);
  L3vpnNlri(L3vpnNlri&& from) noexcept
    : L3vpnNlri() {
    *this = ::std::move(from);
  }

  inline L3vpnNlri& operator=(const L3vpnNlri& from) {
    CopyFrom(from);
    return *this;
  }
  inline L3vpnNlri& operator=(L3vpnNlri&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const L3vpnNlri& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const L3vpnNlri* internal_default_instance() {
    return reinterpret_cast<const L3vpnNlri*>(
               &_L3vpnNlri_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(L3vpnNlri& a, L3vpnNlri& b) {
    a.Swap(&b);
  }
  inline void Swap(L3vpnNlri* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L3vpnNlri* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline L3vpnNlri* New() const final {
    return CreateMaybeMessage<L3vpnNlri>(nullptr);
  }

  L3vpnNlri* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<L3vpnNlri>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const L3vpnNlri& from);
  void MergeFrom(const L3vpnNlri& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L3vpnNlri* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.L3vpnNlri";
  }
  protected:
  explicit L3vpnNlri(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 2,
    kPrefixFieldNumber = 1,
    kRdFieldNumber = 3,
  };
  // repeated .kentik.ktrac.route.v202104.MplsLabelStack labels = 2[json_name = "labels"];
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::kentik::ktrac::route::v202104::MplsLabelStack* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::MplsLabelStack >*
      mutable_labels();
  private:
  const ::kentik::ktrac::route::v202104::MplsLabelStack& _internal_labels(int index) const;
  ::kentik::ktrac::route::v202104::MplsLabelStack* _internal_add_labels();
  public:
  const ::kentik::ktrac::route::v202104::MplsLabelStack& labels(int index) const;
  ::kentik::ktrac::route::v202104::MplsLabelStack* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::MplsLabelStack >&
      labels() const;

  // string prefix = 1[json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  void set_prefix(const std::string& value);
  void set_prefix(std::string&& value);
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  std::string* mutable_prefix();
  std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_prefix();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_prefix(
      std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string rd = 3[json_name = "rd"];
  void clear_rd();
  const std::string& rd() const;
  void set_rd(const std::string& value);
  void set_rd(std::string&& value);
  void set_rd(const char* value);
  void set_rd(const char* value, size_t size);
  std::string* mutable_rd();
  std::string* release_rd();
  void set_allocated_rd(std::string* rd);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_rd();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rd(
      std::string* rd);
  private:
  const std::string& _internal_rd() const;
  void _internal_set_rd(const std::string& value);
  std::string* _internal_mutable_rd();
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.L3vpnNlri)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::MplsLabelStack > labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class MplsLabelStack PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.MplsLabelStack) */ {
 public:
  inline MplsLabelStack() : MplsLabelStack(nullptr) {};
  virtual ~MplsLabelStack();

  MplsLabelStack(const MplsLabelStack& from);
  MplsLabelStack(MplsLabelStack&& from) noexcept
    : MplsLabelStack() {
    *this = ::std::move(from);
  }

  inline MplsLabelStack& operator=(const MplsLabelStack& from) {
    CopyFrom(from);
    return *this;
  }
  inline MplsLabelStack& operator=(MplsLabelStack&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MplsLabelStack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MplsLabelStack* internal_default_instance() {
    return reinterpret_cast<const MplsLabelStack*>(
               &_MplsLabelStack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MplsLabelStack& a, MplsLabelStack& b) {
    a.Swap(&b);
  }
  inline void Swap(MplsLabelStack* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MplsLabelStack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MplsLabelStack* New() const final {
    return CreateMaybeMessage<MplsLabelStack>(nullptr);
  }

  MplsLabelStack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MplsLabelStack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MplsLabelStack& from);
  void MergeFrom(const MplsLabelStack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MplsLabelStack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.MplsLabelStack";
  }
  protected:
  explicit MplsLabelStack(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
  };
  // repeated uint32 label = 1[json_name = "label"];
  int label_size() const;
  private:
  int _internal_label_size() const;
  public:
  void clear_label();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_label(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_label() const;
  void _internal_add_label(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_label();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 label(int index) const;
  void set_label(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_label(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      label() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_label();

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.MplsLabelStack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > label_;
  mutable std::atomic<int> _label_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class PeerStateElem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.PeerStateElem) */ {
 public:
  inline PeerStateElem() : PeerStateElem(nullptr) {};
  virtual ~PeerStateElem();

  PeerStateElem(const PeerStateElem& from);
  PeerStateElem(PeerStateElem&& from) noexcept
    : PeerStateElem() {
    *this = ::std::move(from);
  }

  inline PeerStateElem& operator=(const PeerStateElem& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerStateElem& operator=(PeerStateElem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeerStateElem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerStateElem* internal_default_instance() {
    return reinterpret_cast<const PeerStateElem*>(
               &_PeerStateElem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PeerStateElem& a, PeerStateElem& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerStateElem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerStateElem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerStateElem* New() const final {
    return CreateMaybeMessage<PeerStateElem>(nullptr);
  }

  PeerStateElem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerStateElem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeerStateElem& from);
  void MergeFrom(const PeerStateElem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerStateElem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.PeerStateElem";
  }
  protected:
  explicit PeerStateElem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewStateFieldNumber = 1,
  };
  // .kentik.ktrac.route.v202104.PeerState new_state = 1[json_name = "newState"];
  void clear_new_state();
  ::kentik::ktrac::route::v202104::PeerState new_state() const;
  void set_new_state(::kentik::ktrac::route::v202104::PeerState value);
  private:
  ::kentik::ktrac::route::v202104::PeerState _internal_new_state() const;
  void _internal_set_new_state(::kentik::ktrac::route::v202104::PeerState value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.PeerStateElem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int new_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class Attributes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.Attributes) */ {
 public:
  inline Attributes() : Attributes(nullptr) {};
  virtual ~Attributes();

  Attributes(const Attributes& from);
  Attributes(Attributes&& from) noexcept
    : Attributes() {
    *this = ::std::move(from);
  }

  inline Attributes& operator=(const Attributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attributes& operator=(Attributes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Attributes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Attributes* internal_default_instance() {
    return reinterpret_cast<const Attributes*>(
               &_Attributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Attributes& a, Attributes& b) {
    a.Swap(&b);
  }
  inline void Swap(Attributes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attributes* New() const final {
    return CreateMaybeMessage<Attributes>(nullptr);
  }

  Attributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attributes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Attributes& from);
  void MergeFrom(const Attributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.Attributes";
  }
  protected:
  explicit Attributes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsPathFieldNumber = 3,
    kCommunitiesFieldNumber = 4,
    kExtendedCommunitiesFieldNumber = 5,
    kNextHopFieldNumber = 2,
    kOriginFieldNumber = 1,
  };
  // repeated string as_path = 3[json_name = "asPath"];
  int as_path_size() const;
  private:
  int _internal_as_path_size() const;
  public:
  void clear_as_path();
  const std::string& as_path(int index) const;
  std::string* mutable_as_path(int index);
  void set_as_path(int index, const std::string& value);
  void set_as_path(int index, std::string&& value);
  void set_as_path(int index, const char* value);
  void set_as_path(int index, const char* value, size_t size);
  std::string* add_as_path();
  void add_as_path(const std::string& value);
  void add_as_path(std::string&& value);
  void add_as_path(const char* value);
  void add_as_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& as_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_as_path();
  private:
  const std::string& _internal_as_path(int index) const;
  std::string* _internal_add_as_path();
  public:

  // repeated uint32 communities = 4[json_name = "communities"];
  int communities_size() const;
  private:
  int _internal_communities_size() const;
  public:
  void clear_communities();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_communities(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_communities() const;
  void _internal_add_communities(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_communities();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 communities(int index) const;
  void set_communities(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_communities(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      communities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_communities();

  // repeated string extended_communities = 5[json_name = "extendedCommunities"];
  int extended_communities_size() const;
  private:
  int _internal_extended_communities_size() const;
  public:
  void clear_extended_communities();
  const std::string& extended_communities(int index) const;
  std::string* mutable_extended_communities(int index);
  void set_extended_communities(int index, const std::string& value);
  void set_extended_communities(int index, std::string&& value);
  void set_extended_communities(int index, const char* value);
  void set_extended_communities(int index, const char* value, size_t size);
  std::string* add_extended_communities();
  void add_extended_communities(const std::string& value);
  void add_extended_communities(std::string&& value);
  void add_extended_communities(const char* value);
  void add_extended_communities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extended_communities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extended_communities();
  private:
  const std::string& _internal_extended_communities(int index) const;
  std::string* _internal_add_extended_communities();
  public:

  // string next_hop = 2[json_name = "nextHop"];
  void clear_next_hop();
  const std::string& next_hop() const;
  void set_next_hop(const std::string& value);
  void set_next_hop(std::string&& value);
  void set_next_hop(const char* value);
  void set_next_hop(const char* value, size_t size);
  std::string* mutable_next_hop();
  std::string* release_next_hop();
  void set_allocated_next_hop(std::string* next_hop);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_next_hop();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_next_hop(
      std::string* next_hop);
  private:
  const std::string& _internal_next_hop() const;
  void _internal_set_next_hop(const std::string& value);
  std::string* _internal_mutable_next_hop();
  public:

  // .kentik.ktrac.route.v202104.Origin origin = 1[json_name = "origin"];
  void clear_origin();
  ::kentik::ktrac::route::v202104::Origin origin() const;
  void set_origin(::kentik::ktrac::route::v202104::Origin value);
  private:
  ::kentik::ktrac::route::v202104::Origin _internal_origin() const;
  void _internal_set_origin(::kentik::ktrac::route::v202104::Origin value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.Attributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> as_path_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > communities_;
  mutable std::atomic<int> _communities_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extended_communities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_hop_;
  int origin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// -------------------------------------------------------------------

class RibEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.ktrac.route.v202104.RibEntry) */ {
 public:
  inline RibEntry() : RibEntry(nullptr) {};
  virtual ~RibEntry();

  RibEntry(const RibEntry& from);
  RibEntry(RibEntry&& from) noexcept
    : RibEntry() {
    *this = ::std::move(from);
  }

  inline RibEntry& operator=(const RibEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RibEntry& operator=(RibEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RibEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RibEntry* internal_default_instance() {
    return reinterpret_cast<const RibEntry*>(
               &_RibEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RibEntry& a, RibEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RibEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RibEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RibEntry* New() const final {
    return CreateMaybeMessage<RibEntry>(nullptr);
  }

  RibEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RibEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RibEntry& from);
  void MergeFrom(const RibEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RibEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.ktrac.route.v202104.RibEntry";
  }
  protected:
  explicit RibEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto);
    return ::descriptor_table_kentik_2fktrac_2froute_2fv202104_2felem_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRibIdFieldNumber = 3,
    kDumpTimeFieldNumber = 1,
    kDumpPositionFieldNumber = 2,
    kElemCountFieldNumber = 4,
  };
  // bytes rib_id = 3[json_name = "ribId"];
  void clear_rib_id();
  const std::string& rib_id() const;
  void set_rib_id(const std::string& value);
  void set_rib_id(std::string&& value);
  void set_rib_id(const char* value);
  void set_rib_id(const void* value, size_t size);
  std::string* mutable_rib_id();
  std::string* release_rib_id();
  void set_allocated_rib_id(std::string* rib_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_rib_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rib_id(
      std::string* rib_id);
  private:
  const std::string& _internal_rib_id() const;
  void _internal_set_rib_id(const std::string& value);
  std::string* _internal_mutable_rib_id();
  public:

  // .google.protobuf.Timestamp dump_time = 1[json_name = "dumpTime"];
  bool has_dump_time() const;
  private:
  bool _internal_has_dump_time() const;
  public:
  void clear_dump_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& dump_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_dump_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_dump_time();
  void set_allocated_dump_time(PROTOBUF_NAMESPACE_ID::Timestamp* dump_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_dump_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_dump_time();
  public:
  void unsafe_arena_set_allocated_dump_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* dump_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_dump_time();

  // .kentik.ktrac.route.v202104.DumpPosition dump_position = 2[json_name = "dumpPosition"];
  void clear_dump_position();
  ::kentik::ktrac::route::v202104::DumpPosition dump_position() const;
  void set_dump_position(::kentik::ktrac::route::v202104::DumpPosition value);
  private:
  ::kentik::ktrac::route::v202104::DumpPosition _internal_dump_position() const;
  void _internal_set_dump_position(::kentik::ktrac::route::v202104::DumpPosition value);
  public:

  // uint32 elem_count = 4[json_name = "elemCount"];
  void clear_elem_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 elem_count() const;
  void set_elem_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_elem_count() const;
  void _internal_set_elem_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.ktrac.route.v202104.RibEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rib_id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* dump_time_;
  int dump_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 elem_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fktrac_2froute_2fv202104_2felem_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Elem

// .google.protobuf.Timestamp time = 1[json_name = "time"];
inline bool Elem::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool Elem::has_time() const {
  return _internal_has_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Elem::_internal_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Elem::time() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.time)
  return _internal_time();
}
inline void Elem::unsafe_arena_set_allocated_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Elem.time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Elem::release_time() {
  auto temp = unsafe_arena_release_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Elem::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Elem.time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Elem::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    time_ = p;
  }
  return time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Elem::mutable_time() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.time)
  return _internal_mutable_time();
}
inline void Elem::set_allocated_time(PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time)->GetArena();
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Elem.time)
}

// .kentik.ktrac.route.v202104.RecordType record_type = 2[json_name = "recordType"];
inline void Elem::clear_record_type() {
  record_type_ = 0;
}
inline ::kentik::ktrac::route::v202104::RecordType Elem::_internal_record_type() const {
  return static_cast< ::kentik::ktrac::route::v202104::RecordType >(record_type_);
}
inline ::kentik::ktrac::route::v202104::RecordType Elem::record_type() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.record_type)
  return _internal_record_type();
}
inline void Elem::_internal_set_record_type(::kentik::ktrac::route::v202104::RecordType value) {
  
  record_type_ = value;
}
inline void Elem::set_record_type(::kentik::ktrac::route::v202104::RecordType value) {
  _internal_set_record_type(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Elem.record_type)
}

// .kentik.ktrac.route.v202104.VantagePoint vantage_point = 3[json_name = "vantagePoint"];
inline bool Elem::_internal_has_vantage_point() const {
  return this != internal_default_instance() && vantage_point_ != nullptr;
}
inline bool Elem::has_vantage_point() const {
  return _internal_has_vantage_point();
}
inline void Elem::clear_vantage_point() {
  if (GetArena() == nullptr && vantage_point_ != nullptr) {
    delete vantage_point_;
  }
  vantage_point_ = nullptr;
}
inline const ::kentik::ktrac::route::v202104::VantagePoint& Elem::_internal_vantage_point() const {
  const ::kentik::ktrac::route::v202104::VantagePoint* p = vantage_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::ktrac::route::v202104::VantagePoint*>(
      &::kentik::ktrac::route::v202104::_VantagePoint_default_instance_);
}
inline const ::kentik::ktrac::route::v202104::VantagePoint& Elem::vantage_point() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.vantage_point)
  return _internal_vantage_point();
}
inline void Elem::unsafe_arena_set_allocated_vantage_point(
    ::kentik::ktrac::route::v202104::VantagePoint* vantage_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vantage_point_);
  }
  vantage_point_ = vantage_point;
  if (vantage_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Elem.vantage_point)
}
inline ::kentik::ktrac::route::v202104::VantagePoint* Elem::release_vantage_point() {
  auto temp = unsafe_arena_release_vantage_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::ktrac::route::v202104::VantagePoint* Elem::unsafe_arena_release_vantage_point() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Elem.vantage_point)
  
  ::kentik::ktrac::route::v202104::VantagePoint* temp = vantage_point_;
  vantage_point_ = nullptr;
  return temp;
}
inline ::kentik::ktrac::route::v202104::VantagePoint* Elem::_internal_mutable_vantage_point() {
  
  if (vantage_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::ktrac::route::v202104::VantagePoint>(GetArena());
    vantage_point_ = p;
  }
  return vantage_point_;
}
inline ::kentik::ktrac::route::v202104::VantagePoint* Elem::mutable_vantage_point() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.vantage_point)
  return _internal_mutable_vantage_point();
}
inline void Elem::set_allocated_vantage_point(::kentik::ktrac::route::v202104::VantagePoint* vantage_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vantage_point_;
  }
  if (vantage_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vantage_point);
    if (message_arena != submessage_arena) {
      vantage_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vantage_point, submessage_arena);
    }
    
  } else {
    
  }
  vantage_point_ = vantage_point;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Elem.vantage_point)
}

// bytes message_id = 4[json_name = "messageId"];
inline void Elem::clear_message_id() {
  message_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Elem::message_id() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.message_id)
  return _internal_message_id();
}
inline void Elem::set_message_id(const std::string& value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Elem.message_id)
}
inline std::string* Elem::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.message_id)
  return _internal_mutable_message_id();
}
inline const std::string& Elem::_internal_message_id() const {
  return message_id_.Get();
}
inline void Elem::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Elem::set_message_id(std::string&& value) {
  
  message_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.Elem.message_id)
}
inline void Elem::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.Elem.message_id)
}
inline void Elem::set_message_id(const void* value,
    size_t size) {
  
  message_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.Elem.message_id)
}
inline std::string* Elem::_internal_mutable_message_id() {
  
  return message_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Elem::release_message_id() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Elem.message_id)
  return message_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Elem::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Elem.message_id)
}
inline std::string* Elem::unsafe_arena_release_message_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.Elem.message_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Elem::unsafe_arena_set_allocated_message_id(
    std::string* message_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Elem.message_id)
}

// uint64 serial = 5[json_name = "serial"];
inline void Elem::clear_serial() {
  serial_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Elem::_internal_serial() const {
  return serial_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Elem::serial() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.serial)
  return _internal_serial();
}
inline void Elem::_internal_set_serial(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  serial_ = value;
}
inline void Elem::set_serial(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_serial(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Elem.serial)
}

// .kentik.ktrac.route.v202104.Afi afi = 6[json_name = "afi"];
inline void Elem::clear_afi() {
  afi_ = 0;
}
inline ::kentik::ktrac::route::v202104::Afi Elem::_internal_afi() const {
  return static_cast< ::kentik::ktrac::route::v202104::Afi >(afi_);
}
inline ::kentik::ktrac::route::v202104::Afi Elem::afi() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.afi)
  return _internal_afi();
}
inline void Elem::_internal_set_afi(::kentik::ktrac::route::v202104::Afi value) {
  
  afi_ = value;
}
inline void Elem::set_afi(::kentik::ktrac::route::v202104::Afi value) {
  _internal_set_afi(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Elem.afi)
}

// .kentik.ktrac.route.v202104.Safi safi = 7[json_name = "safi"];
inline void Elem::clear_safi() {
  safi_ = 0;
}
inline ::kentik::ktrac::route::v202104::Safi Elem::_internal_safi() const {
  return static_cast< ::kentik::ktrac::route::v202104::Safi >(safi_);
}
inline ::kentik::ktrac::route::v202104::Safi Elem::safi() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.safi)
  return _internal_safi();
}
inline void Elem::_internal_set_safi(::kentik::ktrac::route::v202104::Safi value) {
  
  safi_ = value;
}
inline void Elem::set_safi(::kentik::ktrac::route::v202104::Safi value) {
  _internal_set_safi(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Elem.safi)
}

// .kentik.ktrac.route.v202104.ElemType type = 8[json_name = "type"];
inline void Elem::clear_type() {
  type_ = 0;
}
inline ::kentik::ktrac::route::v202104::ElemType Elem::_internal_type() const {
  return static_cast< ::kentik::ktrac::route::v202104::ElemType >(type_);
}
inline ::kentik::ktrac::route::v202104::ElemType Elem::type() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.type)
  return _internal_type();
}
inline void Elem::_internal_set_type(::kentik::ktrac::route::v202104::ElemType value) {
  
  type_ = value;
}
inline void Elem::set_type(::kentik::ktrac::route::v202104::ElemType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Elem.type)
}

// repeated .kentik.ktrac.route.v202104.UnicastNlri unicast_nlris = 9[json_name = "unicastNlris"];
inline int Elem::_internal_unicast_nlris_size() const {
  return unicast_nlris_.size();
}
inline int Elem::unicast_nlris_size() const {
  return _internal_unicast_nlris_size();
}
inline void Elem::clear_unicast_nlris() {
  unicast_nlris_.Clear();
}
inline ::kentik::ktrac::route::v202104::UnicastNlri* Elem::mutable_unicast_nlris(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.unicast_nlris)
  return unicast_nlris_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::UnicastNlri >*
Elem::mutable_unicast_nlris() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.Elem.unicast_nlris)
  return &unicast_nlris_;
}
inline const ::kentik::ktrac::route::v202104::UnicastNlri& Elem::_internal_unicast_nlris(int index) const {
  return unicast_nlris_.Get(index);
}
inline const ::kentik::ktrac::route::v202104::UnicastNlri& Elem::unicast_nlris(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.unicast_nlris)
  return _internal_unicast_nlris(index);
}
inline ::kentik::ktrac::route::v202104::UnicastNlri* Elem::_internal_add_unicast_nlris() {
  return unicast_nlris_.Add();
}
inline ::kentik::ktrac::route::v202104::UnicastNlri* Elem::add_unicast_nlris() {
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Elem.unicast_nlris)
  return _internal_add_unicast_nlris();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::UnicastNlri >&
Elem::unicast_nlris() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.Elem.unicast_nlris)
  return unicast_nlris_;
}

// repeated .kentik.ktrac.route.v202104.L3vpnNlri l3vpn_nlris = 10[json_name = "l3vpnNlris"];
inline int Elem::_internal_l3vpn_nlris_size() const {
  return l3vpn_nlris_.size();
}
inline int Elem::l3vpn_nlris_size() const {
  return _internal_l3vpn_nlris_size();
}
inline void Elem::clear_l3vpn_nlris() {
  l3vpn_nlris_.Clear();
}
inline ::kentik::ktrac::route::v202104::L3vpnNlri* Elem::mutable_l3vpn_nlris(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.l3vpn_nlris)
  return l3vpn_nlris_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::L3vpnNlri >*
Elem::mutable_l3vpn_nlris() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.Elem.l3vpn_nlris)
  return &l3vpn_nlris_;
}
inline const ::kentik::ktrac::route::v202104::L3vpnNlri& Elem::_internal_l3vpn_nlris(int index) const {
  return l3vpn_nlris_.Get(index);
}
inline const ::kentik::ktrac::route::v202104::L3vpnNlri& Elem::l3vpn_nlris(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.l3vpn_nlris)
  return _internal_l3vpn_nlris(index);
}
inline ::kentik::ktrac::route::v202104::L3vpnNlri* Elem::_internal_add_l3vpn_nlris() {
  return l3vpn_nlris_.Add();
}
inline ::kentik::ktrac::route::v202104::L3vpnNlri* Elem::add_l3vpn_nlris() {
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Elem.l3vpn_nlris)
  return _internal_add_l3vpn_nlris();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::L3vpnNlri >&
Elem::l3vpn_nlris() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.Elem.l3vpn_nlris)
  return l3vpn_nlris_;
}

// .kentik.ktrac.route.v202104.PeerStateElem peer_state = 11[json_name = "peerState"];
inline bool Elem::_internal_has_peer_state() const {
  return this != internal_default_instance() && peer_state_ != nullptr;
}
inline bool Elem::has_peer_state() const {
  return _internal_has_peer_state();
}
inline void Elem::clear_peer_state() {
  if (GetArena() == nullptr && peer_state_ != nullptr) {
    delete peer_state_;
  }
  peer_state_ = nullptr;
}
inline const ::kentik::ktrac::route::v202104::PeerStateElem& Elem::_internal_peer_state() const {
  const ::kentik::ktrac::route::v202104::PeerStateElem* p = peer_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::ktrac::route::v202104::PeerStateElem*>(
      &::kentik::ktrac::route::v202104::_PeerStateElem_default_instance_);
}
inline const ::kentik::ktrac::route::v202104::PeerStateElem& Elem::peer_state() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.peer_state)
  return _internal_peer_state();
}
inline void Elem::unsafe_arena_set_allocated_peer_state(
    ::kentik::ktrac::route::v202104::PeerStateElem* peer_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_state_);
  }
  peer_state_ = peer_state;
  if (peer_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Elem.peer_state)
}
inline ::kentik::ktrac::route::v202104::PeerStateElem* Elem::release_peer_state() {
  auto temp = unsafe_arena_release_peer_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::ktrac::route::v202104::PeerStateElem* Elem::unsafe_arena_release_peer_state() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Elem.peer_state)
  
  ::kentik::ktrac::route::v202104::PeerStateElem* temp = peer_state_;
  peer_state_ = nullptr;
  return temp;
}
inline ::kentik::ktrac::route::v202104::PeerStateElem* Elem::_internal_mutable_peer_state() {
  
  if (peer_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::ktrac::route::v202104::PeerStateElem>(GetArena());
    peer_state_ = p;
  }
  return peer_state_;
}
inline ::kentik::ktrac::route::v202104::PeerStateElem* Elem::mutable_peer_state() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.peer_state)
  return _internal_mutable_peer_state();
}
inline void Elem::set_allocated_peer_state(::kentik::ktrac::route::v202104::PeerStateElem* peer_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete peer_state_;
  }
  if (peer_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(peer_state);
    if (message_arena != submessage_arena) {
      peer_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_state, submessage_arena);
    }
    
  } else {
    
  }
  peer_state_ = peer_state;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Elem.peer_state)
}

// .kentik.ktrac.route.v202104.Attributes attributes = 12[json_name = "attributes"];
inline bool Elem::_internal_has_attributes() const {
  return this != internal_default_instance() && attributes_ != nullptr;
}
inline bool Elem::has_attributes() const {
  return _internal_has_attributes();
}
inline void Elem::clear_attributes() {
  if (GetArena() == nullptr && attributes_ != nullptr) {
    delete attributes_;
  }
  attributes_ = nullptr;
}
inline const ::kentik::ktrac::route::v202104::Attributes& Elem::_internal_attributes() const {
  const ::kentik::ktrac::route::v202104::Attributes* p = attributes_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::ktrac::route::v202104::Attributes*>(
      &::kentik::ktrac::route::v202104::_Attributes_default_instance_);
}
inline const ::kentik::ktrac::route::v202104::Attributes& Elem::attributes() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.attributes)
  return _internal_attributes();
}
inline void Elem::unsafe_arena_set_allocated_attributes(
    ::kentik::ktrac::route::v202104::Attributes* attributes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Elem.attributes)
}
inline ::kentik::ktrac::route::v202104::Attributes* Elem::release_attributes() {
  auto temp = unsafe_arena_release_attributes();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::ktrac::route::v202104::Attributes* Elem::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Elem.attributes)
  
  ::kentik::ktrac::route::v202104::Attributes* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::kentik::ktrac::route::v202104::Attributes* Elem::_internal_mutable_attributes() {
  
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::ktrac::route::v202104::Attributes>(GetArena());
    attributes_ = p;
  }
  return attributes_;
}
inline ::kentik::ktrac::route::v202104::Attributes* Elem::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.attributes)
  return _internal_mutable_attributes();
}
inline void Elem::set_allocated_attributes(::kentik::ktrac::route::v202104::Attributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Elem.attributes)
}

// .kentik.ktrac.route.v202104.RibEntry rib_entry = 13[json_name = "ribEntry"];
inline bool Elem::_internal_has_rib_entry() const {
  return this != internal_default_instance() && rib_entry_ != nullptr;
}
inline bool Elem::has_rib_entry() const {
  return _internal_has_rib_entry();
}
inline void Elem::clear_rib_entry() {
  if (GetArena() == nullptr && rib_entry_ != nullptr) {
    delete rib_entry_;
  }
  rib_entry_ = nullptr;
}
inline const ::kentik::ktrac::route::v202104::RibEntry& Elem::_internal_rib_entry() const {
  const ::kentik::ktrac::route::v202104::RibEntry* p = rib_entry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::ktrac::route::v202104::RibEntry*>(
      &::kentik::ktrac::route::v202104::_RibEntry_default_instance_);
}
inline const ::kentik::ktrac::route::v202104::RibEntry& Elem::rib_entry() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Elem.rib_entry)
  return _internal_rib_entry();
}
inline void Elem::unsafe_arena_set_allocated_rib_entry(
    ::kentik::ktrac::route::v202104::RibEntry* rib_entry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rib_entry_);
  }
  rib_entry_ = rib_entry;
  if (rib_entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Elem.rib_entry)
}
inline ::kentik::ktrac::route::v202104::RibEntry* Elem::release_rib_entry() {
  auto temp = unsafe_arena_release_rib_entry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::ktrac::route::v202104::RibEntry* Elem::unsafe_arena_release_rib_entry() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Elem.rib_entry)
  
  ::kentik::ktrac::route::v202104::RibEntry* temp = rib_entry_;
  rib_entry_ = nullptr;
  return temp;
}
inline ::kentik::ktrac::route::v202104::RibEntry* Elem::_internal_mutable_rib_entry() {
  
  if (rib_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::ktrac::route::v202104::RibEntry>(GetArena());
    rib_entry_ = p;
  }
  return rib_entry_;
}
inline ::kentik::ktrac::route::v202104::RibEntry* Elem::mutable_rib_entry() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Elem.rib_entry)
  return _internal_mutable_rib_entry();
}
inline void Elem::set_allocated_rib_entry(::kentik::ktrac::route::v202104::RibEntry* rib_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rib_entry_;
  }
  if (rib_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rib_entry);
    if (message_arena != submessage_arena) {
      rib_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rib_entry, submessage_arena);
    }
    
  } else {
    
  }
  rib_entry_ = rib_entry;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Elem.rib_entry)
}

// -------------------------------------------------------------------

// VantagePoint

// string dataset = 1[json_name = "dataset", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void VantagePoint::clear_dataset() {
  dataset_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VantagePoint::dataset() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePoint.dataset)
  return _internal_dataset();
}
inline void VantagePoint::set_dataset(const std::string& value) {
  _internal_set_dataset(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.VantagePoint.dataset)
}
inline std::string* VantagePoint::mutable_dataset() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.VantagePoint.dataset)
  return _internal_mutable_dataset();
}
inline const std::string& VantagePoint::_internal_dataset() const {
  return dataset_.Get();
}
inline void VantagePoint::_internal_set_dataset(const std::string& value) {
  
  dataset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VantagePoint::set_dataset(std::string&& value) {
  
  dataset_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.VantagePoint.dataset)
}
inline void VantagePoint::set_dataset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dataset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.VantagePoint.dataset)
}
inline void VantagePoint::set_dataset(const char* value,
    size_t size) {
  
  dataset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.VantagePoint.dataset)
}
inline std::string* VantagePoint::_internal_mutable_dataset() {
  
  return dataset_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VantagePoint::release_dataset() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.VantagePoint.dataset)
  return dataset_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VantagePoint::set_allocated_dataset(std::string* dataset) {
  if (dataset != nullptr) {
    
  } else {
    
  }
  dataset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dataset,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.VantagePoint.dataset)
}
inline std::string* VantagePoint::unsafe_arena_release_dataset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.VantagePoint.dataset)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return dataset_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VantagePoint::unsafe_arena_set_allocated_dataset(
    std::string* dataset) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (dataset != nullptr) {
    
  } else {
    
  }
  dataset_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      dataset, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.VantagePoint.dataset)
}

// string collector = 2[json_name = "collector", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void VantagePoint::clear_collector() {
  collector_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VantagePoint::collector() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePoint.collector)
  return _internal_collector();
}
inline void VantagePoint::set_collector(const std::string& value) {
  _internal_set_collector(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.VantagePoint.collector)
}
inline std::string* VantagePoint::mutable_collector() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.VantagePoint.collector)
  return _internal_mutable_collector();
}
inline const std::string& VantagePoint::_internal_collector() const {
  return collector_.Get();
}
inline void VantagePoint::_internal_set_collector(const std::string& value) {
  
  collector_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VantagePoint::set_collector(std::string&& value) {
  
  collector_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.VantagePoint.collector)
}
inline void VantagePoint::set_collector(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  collector_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.VantagePoint.collector)
}
inline void VantagePoint::set_collector(const char* value,
    size_t size) {
  
  collector_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.VantagePoint.collector)
}
inline std::string* VantagePoint::_internal_mutable_collector() {
  
  return collector_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VantagePoint::release_collector() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.VantagePoint.collector)
  return collector_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VantagePoint::set_allocated_collector(std::string* collector) {
  if (collector != nullptr) {
    
  } else {
    
  }
  collector_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collector,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.VantagePoint.collector)
}
inline std::string* VantagePoint::unsafe_arena_release_collector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.VantagePoint.collector)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return collector_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VantagePoint::unsafe_arena_set_allocated_collector(
    std::string* collector) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (collector != nullptr) {
    
  } else {
    
  }
  collector_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      collector, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.VantagePoint.collector)
}

// uint32 peer_asn = 3[json_name = "peerAsn", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void VantagePoint::clear_peer_asn() {
  peer_asn_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VantagePoint::_internal_peer_asn() const {
  return peer_asn_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VantagePoint::peer_asn() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePoint.peer_asn)
  return _internal_peer_asn();
}
inline void VantagePoint::_internal_set_peer_asn(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  peer_asn_ = value;
}
inline void VantagePoint::set_peer_asn(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_peer_asn(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.VantagePoint.peer_asn)
}

// string peer_ip = 4[json_name = "peerIp", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void VantagePoint::clear_peer_ip() {
  peer_ip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VantagePoint::peer_ip() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
  return _internal_peer_ip();
}
inline void VantagePoint::set_peer_ip(const std::string& value) {
  _internal_set_peer_ip(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
}
inline std::string* VantagePoint::mutable_peer_ip() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
  return _internal_mutable_peer_ip();
}
inline const std::string& VantagePoint::_internal_peer_ip() const {
  return peer_ip_.Get();
}
inline void VantagePoint::_internal_set_peer_ip(const std::string& value) {
  
  peer_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VantagePoint::set_peer_ip(std::string&& value) {
  
  peer_ip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
}
inline void VantagePoint::set_peer_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  peer_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
}
inline void VantagePoint::set_peer_ip(const char* value,
    size_t size) {
  
  peer_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
}
inline std::string* VantagePoint::_internal_mutable_peer_ip() {
  
  return peer_ip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VantagePoint::release_peer_ip() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
  return peer_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VantagePoint::set_allocated_peer_ip(std::string* peer_ip) {
  if (peer_ip != nullptr) {
    
  } else {
    
  }
  peer_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
}
inline std::string* VantagePoint::unsafe_arena_release_peer_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return peer_ip_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VantagePoint::unsafe_arena_set_allocated_peer_ip(
    std::string* peer_ip) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (peer_ip != nullptr) {
    
  } else {
    
  }
  peer_ip_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      peer_ip, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.VantagePoint.peer_ip)
}

// -------------------------------------------------------------------

// VantagePointTable

// .kentik.ktrac.route.v202104.VantagePoint vantage_point = 1[json_name = "vantagePoint"];
inline bool VantagePointTable::_internal_has_vantage_point() const {
  return this != internal_default_instance() && vantage_point_ != nullptr;
}
inline bool VantagePointTable::has_vantage_point() const {
  return _internal_has_vantage_point();
}
inline void VantagePointTable::clear_vantage_point() {
  if (GetArena() == nullptr && vantage_point_ != nullptr) {
    delete vantage_point_;
  }
  vantage_point_ = nullptr;
}
inline const ::kentik::ktrac::route::v202104::VantagePoint& VantagePointTable::_internal_vantage_point() const {
  const ::kentik::ktrac::route::v202104::VantagePoint* p = vantage_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::ktrac::route::v202104::VantagePoint*>(
      &::kentik::ktrac::route::v202104::_VantagePoint_default_instance_);
}
inline const ::kentik::ktrac::route::v202104::VantagePoint& VantagePointTable::vantage_point() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePointTable.vantage_point)
  return _internal_vantage_point();
}
inline void VantagePointTable::unsafe_arena_set_allocated_vantage_point(
    ::kentik::ktrac::route::v202104::VantagePoint* vantage_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vantage_point_);
  }
  vantage_point_ = vantage_point;
  if (vantage_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.VantagePointTable.vantage_point)
}
inline ::kentik::ktrac::route::v202104::VantagePoint* VantagePointTable::release_vantage_point() {
  auto temp = unsafe_arena_release_vantage_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::ktrac::route::v202104::VantagePoint* VantagePointTable::unsafe_arena_release_vantage_point() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.VantagePointTable.vantage_point)
  
  ::kentik::ktrac::route::v202104::VantagePoint* temp = vantage_point_;
  vantage_point_ = nullptr;
  return temp;
}
inline ::kentik::ktrac::route::v202104::VantagePoint* VantagePointTable::_internal_mutable_vantage_point() {
  
  if (vantage_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::ktrac::route::v202104::VantagePoint>(GetArena());
    vantage_point_ = p;
  }
  return vantage_point_;
}
inline ::kentik::ktrac::route::v202104::VantagePoint* VantagePointTable::mutable_vantage_point() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.VantagePointTable.vantage_point)
  return _internal_mutable_vantage_point();
}
inline void VantagePointTable::set_allocated_vantage_point(::kentik::ktrac::route::v202104::VantagePoint* vantage_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vantage_point_;
  }
  if (vantage_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vantage_point);
    if (message_arena != submessage_arena) {
      vantage_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vantage_point, submessage_arena);
    }
    
  } else {
    
  }
  vantage_point_ = vantage_point;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.VantagePointTable.vantage_point)
}

// .kentik.ktrac.route.v202104.Afi afi = 2[json_name = "afi"];
inline void VantagePointTable::clear_afi() {
  afi_ = 0;
}
inline ::kentik::ktrac::route::v202104::Afi VantagePointTable::_internal_afi() const {
  return static_cast< ::kentik::ktrac::route::v202104::Afi >(afi_);
}
inline ::kentik::ktrac::route::v202104::Afi VantagePointTable::afi() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePointTable.afi)
  return _internal_afi();
}
inline void VantagePointTable::_internal_set_afi(::kentik::ktrac::route::v202104::Afi value) {
  
  afi_ = value;
}
inline void VantagePointTable::set_afi(::kentik::ktrac::route::v202104::Afi value) {
  _internal_set_afi(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.VantagePointTable.afi)
}

// .kentik.ktrac.route.v202104.Safi safi = 3[json_name = "safi"];
inline void VantagePointTable::clear_safi() {
  safi_ = 0;
}
inline ::kentik::ktrac::route::v202104::Safi VantagePointTable::_internal_safi() const {
  return static_cast< ::kentik::ktrac::route::v202104::Safi >(safi_);
}
inline ::kentik::ktrac::route::v202104::Safi VantagePointTable::safi() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.VantagePointTable.safi)
  return _internal_safi();
}
inline void VantagePointTable::_internal_set_safi(::kentik::ktrac::route::v202104::Safi value) {
  
  safi_ = value;
}
inline void VantagePointTable::set_safi(::kentik::ktrac::route::v202104::Safi value) {
  _internal_set_safi(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.VantagePointTable.safi)
}

// -------------------------------------------------------------------

// UnicastNlri

// string prefix = 1[json_name = "prefix"];
inline void UnicastNlri::clear_prefix() {
  prefix_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UnicastNlri::prefix() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.UnicastNlri.prefix)
  return _internal_prefix();
}
inline void UnicastNlri::set_prefix(const std::string& value) {
  _internal_set_prefix(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.UnicastNlri.prefix)
}
inline std::string* UnicastNlri::mutable_prefix() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.UnicastNlri.prefix)
  return _internal_mutable_prefix();
}
inline const std::string& UnicastNlri::_internal_prefix() const {
  return prefix_.Get();
}
inline void UnicastNlri::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnicastNlri::set_prefix(std::string&& value) {
  
  prefix_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.UnicastNlri.prefix)
}
inline void UnicastNlri::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.UnicastNlri.prefix)
}
inline void UnicastNlri::set_prefix(const char* value,
    size_t size) {
  
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.UnicastNlri.prefix)
}
inline std::string* UnicastNlri::_internal_mutable_prefix() {
  
  return prefix_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnicastNlri::release_prefix() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.UnicastNlri.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnicastNlri::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.UnicastNlri.prefix)
}
inline std::string* UnicastNlri::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.UnicastNlri.prefix)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return prefix_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UnicastNlri::unsafe_arena_set_allocated_prefix(
    std::string* prefix) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      prefix, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.UnicastNlri.prefix)
}

// -------------------------------------------------------------------

// L3vpnNlri

// string prefix = 1[json_name = "prefix"];
inline void L3vpnNlri::clear_prefix() {
  prefix_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& L3vpnNlri::prefix() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
  return _internal_prefix();
}
inline void L3vpnNlri::set_prefix(const std::string& value) {
  _internal_set_prefix(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
}
inline std::string* L3vpnNlri::mutable_prefix() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
  return _internal_mutable_prefix();
}
inline const std::string& L3vpnNlri::_internal_prefix() const {
  return prefix_.Get();
}
inline void L3vpnNlri::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void L3vpnNlri::set_prefix(std::string&& value) {
  
  prefix_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
}
inline void L3vpnNlri::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
}
inline void L3vpnNlri::set_prefix(const char* value,
    size_t size) {
  
  prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
}
inline std::string* L3vpnNlri::_internal_mutable_prefix() {
  
  return prefix_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* L3vpnNlri::release_prefix() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void L3vpnNlri::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
}
inline std::string* L3vpnNlri::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return prefix_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void L3vpnNlri::unsafe_arena_set_allocated_prefix(
    std::string* prefix) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      prefix, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.L3vpnNlri.prefix)
}

// repeated .kentik.ktrac.route.v202104.MplsLabelStack labels = 2[json_name = "labels"];
inline int L3vpnNlri::_internal_labels_size() const {
  return labels_.size();
}
inline int L3vpnNlri::labels_size() const {
  return _internal_labels_size();
}
inline void L3vpnNlri::clear_labels() {
  labels_.Clear();
}
inline ::kentik::ktrac::route::v202104::MplsLabelStack* L3vpnNlri::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.L3vpnNlri.labels)
  return labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::MplsLabelStack >*
L3vpnNlri::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.L3vpnNlri.labels)
  return &labels_;
}
inline const ::kentik::ktrac::route::v202104::MplsLabelStack& L3vpnNlri::_internal_labels(int index) const {
  return labels_.Get(index);
}
inline const ::kentik::ktrac::route::v202104::MplsLabelStack& L3vpnNlri::labels(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.L3vpnNlri.labels)
  return _internal_labels(index);
}
inline ::kentik::ktrac::route::v202104::MplsLabelStack* L3vpnNlri::_internal_add_labels() {
  return labels_.Add();
}
inline ::kentik::ktrac::route::v202104::MplsLabelStack* L3vpnNlri::add_labels() {
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.L3vpnNlri.labels)
  return _internal_add_labels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::ktrac::route::v202104::MplsLabelStack >&
L3vpnNlri::labels() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.L3vpnNlri.labels)
  return labels_;
}

// string rd = 3[json_name = "rd"];
inline void L3vpnNlri::clear_rd() {
  rd_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& L3vpnNlri::rd() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.L3vpnNlri.rd)
  return _internal_rd();
}
inline void L3vpnNlri::set_rd(const std::string& value) {
  _internal_set_rd(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.L3vpnNlri.rd)
}
inline std::string* L3vpnNlri::mutable_rd() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.L3vpnNlri.rd)
  return _internal_mutable_rd();
}
inline const std::string& L3vpnNlri::_internal_rd() const {
  return rd_.Get();
}
inline void L3vpnNlri::_internal_set_rd(const std::string& value) {
  
  rd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void L3vpnNlri::set_rd(std::string&& value) {
  
  rd_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.L3vpnNlri.rd)
}
inline void L3vpnNlri::set_rd(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.L3vpnNlri.rd)
}
inline void L3vpnNlri::set_rd(const char* value,
    size_t size) {
  
  rd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.L3vpnNlri.rd)
}
inline std::string* L3vpnNlri::_internal_mutable_rd() {
  
  return rd_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* L3vpnNlri::release_rd() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.L3vpnNlri.rd)
  return rd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void L3vpnNlri::set_allocated_rd(std::string* rd) {
  if (rd != nullptr) {
    
  } else {
    
  }
  rd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rd,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.L3vpnNlri.rd)
}
inline std::string* L3vpnNlri::unsafe_arena_release_rd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.L3vpnNlri.rd)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return rd_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void L3vpnNlri::unsafe_arena_set_allocated_rd(
    std::string* rd) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (rd != nullptr) {
    
  } else {
    
  }
  rd_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      rd, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.L3vpnNlri.rd)
}

// -------------------------------------------------------------------

// MplsLabelStack

// repeated uint32 label = 1[json_name = "label"];
inline int MplsLabelStack::_internal_label_size() const {
  return label_.size();
}
inline int MplsLabelStack::label_size() const {
  return _internal_label_size();
}
inline void MplsLabelStack::clear_label() {
  label_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MplsLabelStack::_internal_label(int index) const {
  return label_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MplsLabelStack::label(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.MplsLabelStack.label)
  return _internal_label(index);
}
inline void MplsLabelStack::set_label(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  label_.Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.MplsLabelStack.label)
}
inline void MplsLabelStack::_internal_add_label(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  label_.Add(value);
}
inline void MplsLabelStack::add_label(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_label(value);
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.MplsLabelStack.label)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
MplsLabelStack::_internal_label() const {
  return label_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
MplsLabelStack::label() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.MplsLabelStack.label)
  return _internal_label();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
MplsLabelStack::_internal_mutable_label() {
  return &label_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
MplsLabelStack::mutable_label() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.MplsLabelStack.label)
  return _internal_mutable_label();
}

// -------------------------------------------------------------------

// PeerStateElem

// .kentik.ktrac.route.v202104.PeerState new_state = 1[json_name = "newState"];
inline void PeerStateElem::clear_new_state() {
  new_state_ = 0;
}
inline ::kentik::ktrac::route::v202104::PeerState PeerStateElem::_internal_new_state() const {
  return static_cast< ::kentik::ktrac::route::v202104::PeerState >(new_state_);
}
inline ::kentik::ktrac::route::v202104::PeerState PeerStateElem::new_state() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.PeerStateElem.new_state)
  return _internal_new_state();
}
inline void PeerStateElem::_internal_set_new_state(::kentik::ktrac::route::v202104::PeerState value) {
  
  new_state_ = value;
}
inline void PeerStateElem::set_new_state(::kentik::ktrac::route::v202104::PeerState value) {
  _internal_set_new_state(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.PeerStateElem.new_state)
}

// -------------------------------------------------------------------

// Attributes

// .kentik.ktrac.route.v202104.Origin origin = 1[json_name = "origin"];
inline void Attributes::clear_origin() {
  origin_ = 0;
}
inline ::kentik::ktrac::route::v202104::Origin Attributes::_internal_origin() const {
  return static_cast< ::kentik::ktrac::route::v202104::Origin >(origin_);
}
inline ::kentik::ktrac::route::v202104::Origin Attributes::origin() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Attributes.origin)
  return _internal_origin();
}
inline void Attributes::_internal_set_origin(::kentik::ktrac::route::v202104::Origin value) {
  
  origin_ = value;
}
inline void Attributes::set_origin(::kentik::ktrac::route::v202104::Origin value) {
  _internal_set_origin(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.origin)
}

// string next_hop = 2[json_name = "nextHop"];
inline void Attributes::clear_next_hop() {
  next_hop_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Attributes::next_hop() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Attributes.next_hop)
  return _internal_next_hop();
}
inline void Attributes::set_next_hop(const std::string& value) {
  _internal_set_next_hop(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.next_hop)
}
inline std::string* Attributes::mutable_next_hop() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Attributes.next_hop)
  return _internal_mutable_next_hop();
}
inline const std::string& Attributes::_internal_next_hop() const {
  return next_hop_.Get();
}
inline void Attributes::_internal_set_next_hop(const std::string& value) {
  
  next_hop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Attributes::set_next_hop(std::string&& value) {
  
  next_hop_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.Attributes.next_hop)
}
inline void Attributes::set_next_hop(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_hop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.Attributes.next_hop)
}
inline void Attributes::set_next_hop(const char* value,
    size_t size) {
  
  next_hop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.Attributes.next_hop)
}
inline std::string* Attributes::_internal_mutable_next_hop() {
  
  return next_hop_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Attributes::release_next_hop() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.Attributes.next_hop)
  return next_hop_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Attributes::set_allocated_next_hop(std::string* next_hop) {
  if (next_hop != nullptr) {
    
  } else {
    
  }
  next_hop_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_hop,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.Attributes.next_hop)
}
inline std::string* Attributes::unsafe_arena_release_next_hop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.Attributes.next_hop)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return next_hop_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Attributes::unsafe_arena_set_allocated_next_hop(
    std::string* next_hop) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (next_hop != nullptr) {
    
  } else {
    
  }
  next_hop_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      next_hop, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.Attributes.next_hop)
}

// repeated string as_path = 3[json_name = "asPath"];
inline int Attributes::_internal_as_path_size() const {
  return as_path_.size();
}
inline int Attributes::as_path_size() const {
  return _internal_as_path_size();
}
inline void Attributes::clear_as_path() {
  as_path_.Clear();
}
inline std::string* Attributes::add_as_path() {
  // @@protoc_insertion_point(field_add_mutable:kentik.ktrac.route.v202104.Attributes.as_path)
  return _internal_add_as_path();
}
inline const std::string& Attributes::_internal_as_path(int index) const {
  return as_path_.Get(index);
}
inline const std::string& Attributes::as_path(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Attributes.as_path)
  return _internal_as_path(index);
}
inline std::string* Attributes::mutable_as_path(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Attributes.as_path)
  return as_path_.Mutable(index);
}
inline void Attributes::set_as_path(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.as_path)
  as_path_.Mutable(index)->assign(value);
}
inline void Attributes::set_as_path(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.as_path)
  as_path_.Mutable(index)->assign(std::move(value));
}
inline void Attributes::set_as_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  as_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.Attributes.as_path)
}
inline void Attributes::set_as_path(int index, const char* value, size_t size) {
  as_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.Attributes.as_path)
}
inline std::string* Attributes::_internal_add_as_path() {
  return as_path_.Add();
}
inline void Attributes::add_as_path(const std::string& value) {
  as_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Attributes.as_path)
}
inline void Attributes::add_as_path(std::string&& value) {
  as_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Attributes.as_path)
}
inline void Attributes::add_as_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  as_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.ktrac.route.v202104.Attributes.as_path)
}
inline void Attributes::add_as_path(const char* value, size_t size) {
  as_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.ktrac.route.v202104.Attributes.as_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Attributes::as_path() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.Attributes.as_path)
  return as_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Attributes::mutable_as_path() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.Attributes.as_path)
  return &as_path_;
}

// repeated uint32 communities = 4[json_name = "communities"];
inline int Attributes::_internal_communities_size() const {
  return communities_.size();
}
inline int Attributes::communities_size() const {
  return _internal_communities_size();
}
inline void Attributes::clear_communities() {
  communities_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Attributes::_internal_communities(int index) const {
  return communities_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Attributes::communities(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Attributes.communities)
  return _internal_communities(index);
}
inline void Attributes::set_communities(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  communities_.Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.communities)
}
inline void Attributes::_internal_add_communities(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  communities_.Add(value);
}
inline void Attributes::add_communities(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_communities(value);
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Attributes.communities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Attributes::_internal_communities() const {
  return communities_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Attributes::communities() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.Attributes.communities)
  return _internal_communities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Attributes::_internal_mutable_communities() {
  return &communities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Attributes::mutable_communities() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.Attributes.communities)
  return _internal_mutable_communities();
}

// repeated string extended_communities = 5[json_name = "extendedCommunities"];
inline int Attributes::_internal_extended_communities_size() const {
  return extended_communities_.size();
}
inline int Attributes::extended_communities_size() const {
  return _internal_extended_communities_size();
}
inline void Attributes::clear_extended_communities() {
  extended_communities_.Clear();
}
inline std::string* Attributes::add_extended_communities() {
  // @@protoc_insertion_point(field_add_mutable:kentik.ktrac.route.v202104.Attributes.extended_communities)
  return _internal_add_extended_communities();
}
inline const std::string& Attributes::_internal_extended_communities(int index) const {
  return extended_communities_.Get(index);
}
inline const std::string& Attributes::extended_communities(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.Attributes.extended_communities)
  return _internal_extended_communities(index);
}
inline std::string* Attributes::mutable_extended_communities(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.Attributes.extended_communities)
  return extended_communities_.Mutable(index);
}
inline void Attributes::set_extended_communities(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.extended_communities)
  extended_communities_.Mutable(index)->assign(value);
}
inline void Attributes::set_extended_communities(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.Attributes.extended_communities)
  extended_communities_.Mutable(index)->assign(std::move(value));
}
inline void Attributes::set_extended_communities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  extended_communities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.Attributes.extended_communities)
}
inline void Attributes::set_extended_communities(int index, const char* value, size_t size) {
  extended_communities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.Attributes.extended_communities)
}
inline std::string* Attributes::_internal_add_extended_communities() {
  return extended_communities_.Add();
}
inline void Attributes::add_extended_communities(const std::string& value) {
  extended_communities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Attributes.extended_communities)
}
inline void Attributes::add_extended_communities(std::string&& value) {
  extended_communities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.ktrac.route.v202104.Attributes.extended_communities)
}
inline void Attributes::add_extended_communities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  extended_communities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.ktrac.route.v202104.Attributes.extended_communities)
}
inline void Attributes::add_extended_communities(const char* value, size_t size) {
  extended_communities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.ktrac.route.v202104.Attributes.extended_communities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Attributes::extended_communities() const {
  // @@protoc_insertion_point(field_list:kentik.ktrac.route.v202104.Attributes.extended_communities)
  return extended_communities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Attributes::mutable_extended_communities() {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktrac.route.v202104.Attributes.extended_communities)
  return &extended_communities_;
}

// -------------------------------------------------------------------

// RibEntry

// .google.protobuf.Timestamp dump_time = 1[json_name = "dumpTime"];
inline bool RibEntry::_internal_has_dump_time() const {
  return this != internal_default_instance() && dump_time_ != nullptr;
}
inline bool RibEntry::has_dump_time() const {
  return _internal_has_dump_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RibEntry::_internal_dump_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = dump_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RibEntry::dump_time() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.RibEntry.dump_time)
  return _internal_dump_time();
}
inline void RibEntry::unsafe_arena_set_allocated_dump_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* dump_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dump_time_);
  }
  dump_time_ = dump_time;
  if (dump_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.RibEntry.dump_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RibEntry::release_dump_time() {
  auto temp = unsafe_arena_release_dump_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RibEntry::unsafe_arena_release_dump_time() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.RibEntry.dump_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = dump_time_;
  dump_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RibEntry::_internal_mutable_dump_time() {
  
  if (dump_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    dump_time_ = p;
  }
  return dump_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RibEntry::mutable_dump_time() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.RibEntry.dump_time)
  return _internal_mutable_dump_time();
}
inline void RibEntry::set_allocated_dump_time(PROTOBUF_NAMESPACE_ID::Timestamp* dump_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dump_time_);
  }
  if (dump_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dump_time)->GetArena();
    if (message_arena != submessage_arena) {
      dump_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dump_time, submessage_arena);
    }
    
  } else {
    
  }
  dump_time_ = dump_time;
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.RibEntry.dump_time)
}

// .kentik.ktrac.route.v202104.DumpPosition dump_position = 2[json_name = "dumpPosition"];
inline void RibEntry::clear_dump_position() {
  dump_position_ = 0;
}
inline ::kentik::ktrac::route::v202104::DumpPosition RibEntry::_internal_dump_position() const {
  return static_cast< ::kentik::ktrac::route::v202104::DumpPosition >(dump_position_);
}
inline ::kentik::ktrac::route::v202104::DumpPosition RibEntry::dump_position() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.RibEntry.dump_position)
  return _internal_dump_position();
}
inline void RibEntry::_internal_set_dump_position(::kentik::ktrac::route::v202104::DumpPosition value) {
  
  dump_position_ = value;
}
inline void RibEntry::set_dump_position(::kentik::ktrac::route::v202104::DumpPosition value) {
  _internal_set_dump_position(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.RibEntry.dump_position)
}

// bytes rib_id = 3[json_name = "ribId"];
inline void RibEntry::clear_rib_id() {
  rib_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RibEntry::rib_id() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.RibEntry.rib_id)
  return _internal_rib_id();
}
inline void RibEntry::set_rib_id(const std::string& value) {
  _internal_set_rib_id(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.RibEntry.rib_id)
}
inline std::string* RibEntry::mutable_rib_id() {
  // @@protoc_insertion_point(field_mutable:kentik.ktrac.route.v202104.RibEntry.rib_id)
  return _internal_mutable_rib_id();
}
inline const std::string& RibEntry::_internal_rib_id() const {
  return rib_id_.Get();
}
inline void RibEntry::_internal_set_rib_id(const std::string& value) {
  
  rib_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RibEntry::set_rib_id(std::string&& value) {
  
  rib_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.ktrac.route.v202104.RibEntry.rib_id)
}
inline void RibEntry::set_rib_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rib_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.ktrac.route.v202104.RibEntry.rib_id)
}
inline void RibEntry::set_rib_id(const void* value,
    size_t size) {
  
  rib_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.ktrac.route.v202104.RibEntry.rib_id)
}
inline std::string* RibEntry::_internal_mutable_rib_id() {
  
  return rib_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RibEntry::release_rib_id() {
  // @@protoc_insertion_point(field_release:kentik.ktrac.route.v202104.RibEntry.rib_id)
  return rib_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RibEntry::set_allocated_rib_id(std::string* rib_id) {
  if (rib_id != nullptr) {
    
  } else {
    
  }
  rib_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rib_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.ktrac.route.v202104.RibEntry.rib_id)
}
inline std::string* RibEntry::unsafe_arena_release_rib_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktrac.route.v202104.RibEntry.rib_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return rib_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RibEntry::unsafe_arena_set_allocated_rib_id(
    std::string* rib_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (rib_id != nullptr) {
    
  } else {
    
  }
  rib_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      rib_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktrac.route.v202104.RibEntry.rib_id)
}

// uint32 elem_count = 4[json_name = "elemCount"];
inline void RibEntry::clear_elem_count() {
  elem_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RibEntry::_internal_elem_count() const {
  return elem_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RibEntry::elem_count() const {
  // @@protoc_insertion_point(field_get:kentik.ktrac.route.v202104.RibEntry.elem_count)
  return _internal_elem_count();
}
inline void RibEntry::_internal_set_elem_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  elem_count_ = value;
}
inline void RibEntry::set_elem_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_elem_count(value);
  // @@protoc_insertion_point(field_set:kentik.ktrac.route.v202104.RibEntry.elem_count)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v202104
}  // namespace route
}  // namespace ktrac
}  // namespace kentik

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::RecordType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::RecordType>() {
  return ::kentik::ktrac::route::v202104::RecordType_descriptor();
}
template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::Afi> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::Afi>() {
  return ::kentik::ktrac::route::v202104::Afi_descriptor();
}
template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::Safi> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::Safi>() {
  return ::kentik::ktrac::route::v202104::Safi_descriptor();
}
template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::Origin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::Origin>() {
  return ::kentik::ktrac::route::v202104::Origin_descriptor();
}
template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::ElemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::ElemType>() {
  return ::kentik::ktrac::route::v202104::ElemType_descriptor();
}
template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::PeerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::PeerState>() {
  return ::kentik::ktrac::route::v202104::PeerState_descriptor();
}
template <> struct is_proto_enum< ::kentik::ktrac::route::v202104::DumpPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::ktrac::route::v202104::DumpPosition>() {
  return ::kentik::ktrac::route::v202104::DumpPosition_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kentik_2fktrac_2froute_2fv202104_2felem_2eproto
