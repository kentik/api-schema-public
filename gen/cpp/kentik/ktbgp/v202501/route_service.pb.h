// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: kentik/ktbgp/v202501/route_service.proto
// Protobuf C++ Version: 5.29.3

#ifndef kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto_2epb_2eh
#define kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include "kentik/core/v202303/annotations.pb.h"
#include "kentik/alerting/types/v202303/types.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
namespace kentik {
namespace ktbgp {
namespace v202501 {
class DeviceAdverts;
struct DeviceAdvertsDefaultTypeInternal;
extern DeviceAdvertsDefaultTypeInternal _DeviceAdverts_default_instance_;
class FlowspecAction;
struct FlowspecActionDefaultTypeInternal;
extern FlowspecActionDefaultTypeInternal _FlowspecAction_default_instance_;
class FlowspecActionAccept;
struct FlowspecActionAcceptDefaultTypeInternal;
extern FlowspecActionAcceptDefaultTypeInternal _FlowspecActionAccept_default_instance_;
class FlowspecActionDiscard;
struct FlowspecActionDiscardDefaultTypeInternal;
extern FlowspecActionDiscardDefaultTypeInternal _FlowspecActionDiscard_default_instance_;
class FlowspecActionExtendedCommunity;
struct FlowspecActionExtendedCommunityDefaultTypeInternal;
extern FlowspecActionExtendedCommunityDefaultTypeInternal _FlowspecActionExtendedCommunity_default_instance_;
class FlowspecActionIPNextHopCopy;
struct FlowspecActionIPNextHopCopyDefaultTypeInternal;
extern FlowspecActionIPNextHopCopyDefaultTypeInternal _FlowspecActionIPNextHopCopy_default_instance_;
class FlowspecActionIPNextHopRedirect;
struct FlowspecActionIPNextHopRedirectDefaultTypeInternal;
extern FlowspecActionIPNextHopRedirectDefaultTypeInternal _FlowspecActionIPNextHopRedirect_default_instance_;
class FlowspecActionLargeCommunity;
struct FlowspecActionLargeCommunityDefaultTypeInternal;
extern FlowspecActionLargeCommunityDefaultTypeInternal _FlowspecActionLargeCommunity_default_instance_;
class FlowspecActionMarkDSCP;
struct FlowspecActionMarkDSCPDefaultTypeInternal;
extern FlowspecActionMarkDSCPDefaultTypeInternal _FlowspecActionMarkDSCP_default_instance_;
class FlowspecActionRegularCommunity;
struct FlowspecActionRegularCommunityDefaultTypeInternal;
extern FlowspecActionRegularCommunityDefaultTypeInternal _FlowspecActionRegularCommunity_default_instance_;
class FlowspecActionRouteTargetRedirect;
struct FlowspecActionRouteTargetRedirectDefaultTypeInternal;
extern FlowspecActionRouteTargetRedirectDefaultTypeInternal _FlowspecActionRouteTargetRedirect_default_instance_;
class FlowspecActionTerminalSample;
struct FlowspecActionTerminalSampleDefaultTypeInternal;
extern FlowspecActionTerminalSampleDefaultTypeInternal _FlowspecActionTerminalSample_default_instance_;
class FlowspecActionTrafficRateBytes;
struct FlowspecActionTrafficRateBytesDefaultTypeInternal;
extern FlowspecActionTrafficRateBytesDefaultTypeInternal _FlowspecActionTrafficRateBytes_default_instance_;
class FlowspecMatch;
struct FlowspecMatchDefaultTypeInternal;
extern FlowspecMatchDefaultTypeInternal _FlowspecMatch_default_instance_;
class FlowspecUpdate;
struct FlowspecUpdateDefaultTypeInternal;
extern FlowspecUpdateDefaultTypeInternal _FlowspecUpdate_default_instance_;
class FlowspecUpdates;
struct FlowspecUpdatesDefaultTypeInternal;
extern FlowspecUpdatesDefaultTypeInternal _FlowspecUpdates_default_instance_;
class FragmentFormula;
struct FragmentFormulaDefaultTypeInternal;
extern FragmentFormulaDefaultTypeInternal _FragmentFormula_default_instance_;
class FragmentPredicate;
struct FragmentPredicateDefaultTypeInternal;
extern FragmentPredicateDefaultTypeInternal _FragmentPredicate_default_instance_;
class FragmentPredicateGroup;
struct FragmentPredicateGroupDefaultTypeInternal;
extern FragmentPredicateGroupDefaultTypeInternal _FragmentPredicateGroup_default_instance_;
class NumericFormula;
struct NumericFormulaDefaultTypeInternal;
extern NumericFormulaDefaultTypeInternal _NumericFormula_default_instance_;
class NumericPredicate;
struct NumericPredicateDefaultTypeInternal;
extern NumericPredicateDefaultTypeInternal _NumericPredicate_default_instance_;
class NumericPredicateGroup;
struct NumericPredicateGroupDefaultTypeInternal;
extern NumericPredicateGroupDefaultTypeInternal _NumericPredicateGroup_default_instance_;
class RTBHAction;
struct RTBHActionDefaultTypeInternal;
extern RTBHActionDefaultTypeInternal _RTBHAction_default_instance_;
class RTBHMatch;
struct RTBHMatchDefaultTypeInternal;
extern RTBHMatchDefaultTypeInternal _RTBHMatch_default_instance_;
class RTBHUpdate;
struct RTBHUpdateDefaultTypeInternal;
extern RTBHUpdateDefaultTypeInternal _RTBHUpdate_default_instance_;
class RTBHUpdates;
struct RTBHUpdatesDefaultTypeInternal;
extern RTBHUpdatesDefaultTypeInternal _RTBHUpdates_default_instance_;
class RouteServiceAnnounceRequest;
struct RouteServiceAnnounceRequestDefaultTypeInternal;
extern RouteServiceAnnounceRequestDefaultTypeInternal _RouteServiceAnnounceRequest_default_instance_;
class RouteServiceAnnounceResponse;
struct RouteServiceAnnounceResponseDefaultTypeInternal;
extern RouteServiceAnnounceResponseDefaultTypeInternal _RouteServiceAnnounceResponse_default_instance_;
class RouteServiceListRequest;
struct RouteServiceListRequestDefaultTypeInternal;
extern RouteServiceListRequestDefaultTypeInternal _RouteServiceListRequest_default_instance_;
class RouteServiceListResponse;
struct RouteServiceListResponseDefaultTypeInternal;
extern RouteServiceListResponseDefaultTypeInternal _RouteServiceListResponse_default_instance_;
class RouteServiceWithdrawRequest;
struct RouteServiceWithdrawRequestDefaultTypeInternal;
extern RouteServiceWithdrawRequestDefaultTypeInternal _RouteServiceWithdrawRequest_default_instance_;
class RouteServiceWithdrawResponse;
struct RouteServiceWithdrawResponseDefaultTypeInternal;
extern RouteServiceWithdrawResponseDefaultTypeInternal _RouteServiceWithdrawResponse_default_instance_;
class RoutesFilter;
struct RoutesFilterDefaultTypeInternal;
extern RoutesFilterDefaultTypeInternal _RoutesFilter_default_instance_;
class TCPFlagsFormula;
struct TCPFlagsFormulaDefaultTypeInternal;
extern TCPFlagsFormulaDefaultTypeInternal _TCPFlagsFormula_default_instance_;
class TCPFlagsPredicate;
struct TCPFlagsPredicateDefaultTypeInternal;
extern TCPFlagsPredicateDefaultTypeInternal _TCPFlagsPredicate_default_instance_;
class TCPFlagsPredicateGroup;
struct TCPFlagsPredicateGroupDefaultTypeInternal;
extern TCPFlagsPredicateGroupDefaultTypeInternal _TCPFlagsPredicateGroup_default_instance_;
class UpdateResult;
struct UpdateResultDefaultTypeInternal;
extern UpdateResultDefaultTypeInternal _UpdateResult_default_instance_;
class Withdraw;
struct WithdrawDefaultTypeInternal;
extern WithdrawDefaultTypeInternal _Withdraw_default_instance_;
}  // namespace v202501
}  // namespace ktbgp
}  // namespace kentik
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kentik {
namespace ktbgp {
namespace v202501 {
enum InetType : int {
  INET_TYPE_UNSPECIFIED = 0,
  INET_TYPE_IPV4 = 1,
  INET_TYPE_IPV6 = 2,
  InetType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InetType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InetType_IsValid(int value);
extern const uint32_t InetType_internal_data_[];
constexpr InetType InetType_MIN = static_cast<InetType>(0);
constexpr InetType InetType_MAX = static_cast<InetType>(2);
constexpr int InetType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
InetType_descriptor();
template <typename T>
const std::string& InetType_Name(T value) {
  static_assert(std::is_same<T, InetType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InetType_Name().");
  return InetType_Name(static_cast<InetType>(value));
}
template <>
inline const std::string& InetType_Name(InetType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InetType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool InetType_Parse(absl::string_view name, InetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InetType>(
      InetType_descriptor(), name, value);
}
enum ExtendedCommunityRouteType : int {
  EXTENDED_COMMUNITY_ROUTE_TYPE_UNSPECIFIED = 0,
  EXTENDED_COMMUNITY_ROUTE_TYPE_TARGET = 1,
  EXTENDED_COMMUNITY_ROUTE_TYPE_ORIGIN = 2,
  ExtendedCommunityRouteType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExtendedCommunityRouteType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExtendedCommunityRouteType_IsValid(int value);
extern const uint32_t ExtendedCommunityRouteType_internal_data_[];
constexpr ExtendedCommunityRouteType ExtendedCommunityRouteType_MIN = static_cast<ExtendedCommunityRouteType>(0);
constexpr ExtendedCommunityRouteType ExtendedCommunityRouteType_MAX = static_cast<ExtendedCommunityRouteType>(2);
constexpr int ExtendedCommunityRouteType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ExtendedCommunityRouteType_descriptor();
template <typename T>
const std::string& ExtendedCommunityRouteType_Name(T value) {
  static_assert(std::is_same<T, ExtendedCommunityRouteType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExtendedCommunityRouteType_Name().");
  return ExtendedCommunityRouteType_Name(static_cast<ExtendedCommunityRouteType>(value));
}
template <>
inline const std::string& ExtendedCommunityRouteType_Name(ExtendedCommunityRouteType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ExtendedCommunityRouteType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ExtendedCommunityRouteType_Parse(absl::string_view name, ExtendedCommunityRouteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExtendedCommunityRouteType>(
      ExtendedCommunityRouteType_descriptor(), name, value);
}
enum Fragment : int {
  FRAGMENT_UNSPECIFIED = 0,
  FRAGMENT_DF = 1,
  FRAGMENT_ISF = 2,
  FRAGMENT_FF = 3,
  FRAGMENT_LF = 4,
  Fragment_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Fragment_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Fragment_IsValid(int value);
extern const uint32_t Fragment_internal_data_[];
constexpr Fragment Fragment_MIN = static_cast<Fragment>(0);
constexpr Fragment Fragment_MAX = static_cast<Fragment>(4);
constexpr int Fragment_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Fragment_descriptor();
template <typename T>
const std::string& Fragment_Name(T value) {
  static_assert(std::is_same<T, Fragment>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Fragment_Name().");
  return Fragment_Name(static_cast<Fragment>(value));
}
template <>
inline const std::string& Fragment_Name(Fragment value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Fragment_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Fragment_Parse(absl::string_view name, Fragment* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fragment>(
      Fragment_descriptor(), name, value);
}
enum TCPFlag : int {
  TCP_FLAG_UNSPECIFIED = 0,
  TCP_FLAG_FIN = 1,
  TCP_FLAG_SYN = 2,
  TCP_FLAG_RST = 3,
  TCP_FLAG_PSH = 4,
  TCP_FLAG_ACK = 5,
  TCP_FLAG_URG = 6,
  TCP_FLAG_ECE = 7,
  TCP_FLAG_CWR = 8,
  TCPFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TCPFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TCPFlag_IsValid(int value);
extern const uint32_t TCPFlag_internal_data_[];
constexpr TCPFlag TCPFlag_MIN = static_cast<TCPFlag>(0);
constexpr TCPFlag TCPFlag_MAX = static_cast<TCPFlag>(8);
constexpr int TCPFlag_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
TCPFlag_descriptor();
template <typename T>
const std::string& TCPFlag_Name(T value) {
  static_assert(std::is_same<T, TCPFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TCPFlag_Name().");
  return TCPFlag_Name(static_cast<TCPFlag>(value));
}
template <>
inline const std::string& TCPFlag_Name(TCPFlag value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TCPFlag_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool TCPFlag_Parse(absl::string_view name, TCPFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TCPFlag>(
      TCPFlag_descriptor(), name, value);
}
enum NumericOp : int {
  NUMERIC_OP_UNSPECIFIED = 0,
  NUMERIC_OP_EQUALS = 1,
  NUMERIC_OP_NOT_EQUALS = 2,
  NUMERIC_OP_LESS_THAN = 3,
  NUMERIC_OP_GREATER_THAN = 4,
  NUMERIC_OP_LESS_THAN_OR_EQUALS = 5,
  NUMERIC_OP_GREATER_THAN_OR_EQUALS = 6,
  NumericOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumericOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumericOp_IsValid(int value);
extern const uint32_t NumericOp_internal_data_[];
constexpr NumericOp NumericOp_MIN = static_cast<NumericOp>(0);
constexpr NumericOp NumericOp_MAX = static_cast<NumericOp>(6);
constexpr int NumericOp_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
NumericOp_descriptor();
template <typename T>
const std::string& NumericOp_Name(T value) {
  static_assert(std::is_same<T, NumericOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NumericOp_Name().");
  return NumericOp_Name(static_cast<NumericOp>(value));
}
template <>
inline const std::string& NumericOp_Name(NumericOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumericOp_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool NumericOp_Parse(absl::string_view name, NumericOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumericOp>(
      NumericOp_descriptor(), name, value);
}
enum BitwiseOp : int {
  BITWISE_OP_UNSPECIFIED = 0,
  BITWISE_OP_ANY = 1,
  BITWISE_OP_NONE = 2,
  BITWISE_OP_ALL = 3,
  BITWISE_OP_NOT_ALL = 4,
  BitwiseOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BitwiseOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BitwiseOp_IsValid(int value);
extern const uint32_t BitwiseOp_internal_data_[];
constexpr BitwiseOp BitwiseOp_MIN = static_cast<BitwiseOp>(0);
constexpr BitwiseOp BitwiseOp_MAX = static_cast<BitwiseOp>(4);
constexpr int BitwiseOp_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
BitwiseOp_descriptor();
template <typename T>
const std::string& BitwiseOp_Name(T value) {
  static_assert(std::is_same<T, BitwiseOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BitwiseOp_Name().");
  return BitwiseOp_Name(static_cast<BitwiseOp>(value));
}
template <>
inline const std::string& BitwiseOp_Name(BitwiseOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BitwiseOp_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool BitwiseOp_Parse(absl::string_view name, BitwiseOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BitwiseOp>(
      BitwiseOp_descriptor(), name, value);
}
enum AdvertStatus : int {
  ADVERT_STATUS_UNSPECIFIED = 0,
  ADVERT_STATUS_ANNOUNCED = 1,
  ADVERT_STATUS_WITHDRAWN = 2,
  ADVERT_STATUS_NO_SESSION = 4,
  ADVERT_STATUS_FAILED = 3,
  AdvertStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AdvertStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AdvertStatus_IsValid(int value);
extern const uint32_t AdvertStatus_internal_data_[];
constexpr AdvertStatus AdvertStatus_MIN = static_cast<AdvertStatus>(0);
constexpr AdvertStatus AdvertStatus_MAX = static_cast<AdvertStatus>(4);
constexpr int AdvertStatus_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AdvertStatus_descriptor();
template <typename T>
const std::string& AdvertStatus_Name(T value) {
  static_assert(std::is_same<T, AdvertStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AdvertStatus_Name().");
  return AdvertStatus_Name(static_cast<AdvertStatus>(value));
}
template <>
inline const std::string& AdvertStatus_Name(AdvertStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AdvertStatus_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool AdvertStatus_Parse(absl::string_view name, AdvertStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdvertStatus>(
      AdvertStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.UpdateResult) */ {
 public:
  inline UpdateResult() : UpdateResult(nullptr) {}
  ~UpdateResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateResult(const UpdateResult& from) : UpdateResult(nullptr, from) {}
  inline UpdateResult(UpdateResult&& from) noexcept
      : UpdateResult(nullptr, std::move(from)) {}
  inline UpdateResult& operator=(const UpdateResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResult& operator=(UpdateResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResult* internal_default_instance() {
    return reinterpret_cast<const UpdateResult*>(
        &_UpdateResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(UpdateResult& a, UpdateResult& b) { a.Swap(&b); }
  inline void Swap(UpdateResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateResult& from) { UpdateResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.UpdateResult"; }

 protected:
  explicit UpdateResult(::google::protobuf::Arena* arena);
  UpdateResult(::google::protobuf::Arena* arena, const UpdateResult& from);
  UpdateResult(::google::protobuf::Arena* arena, UpdateResult&& from) noexcept
      : UpdateResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string message = 3 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // uint64 device_id = 1 [json_name = "deviceId"];
  void clear_device_id() ;
  ::uint64_t device_id() const;
  void set_device_id(::uint64_t value);

  private:
  ::uint64_t _internal_device_id() const;
  void _internal_set_device_id(::uint64_t value);

  public:
  // .kentik.ktbgp.v202501.AdvertStatus status = 2 [json_name = "status"];
  void clear_status() ;
  ::kentik::ktbgp::v202501::AdvertStatus status() const;
  void set_status(::kentik::ktbgp::v202501::AdvertStatus value);

  private:
  ::kentik::ktbgp::v202501::AdvertStatus _internal_status() const;
  void _internal_set_status(::kentik::ktbgp::v202501::AdvertStatus value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.UpdateResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateResult& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t device_id_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TCPFlagsPredicate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.TCPFlagsPredicate) */ {
 public:
  inline TCPFlagsPredicate() : TCPFlagsPredicate(nullptr) {}
  ~TCPFlagsPredicate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TCPFlagsPredicate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TCPFlagsPredicate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TCPFlagsPredicate(
      ::google::protobuf::internal::ConstantInitialized);

  inline TCPFlagsPredicate(const TCPFlagsPredicate& from) : TCPFlagsPredicate(nullptr, from) {}
  inline TCPFlagsPredicate(TCPFlagsPredicate&& from) noexcept
      : TCPFlagsPredicate(nullptr, std::move(from)) {}
  inline TCPFlagsPredicate& operator=(const TCPFlagsPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCPFlagsPredicate& operator=(TCPFlagsPredicate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCPFlagsPredicate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCPFlagsPredicate* internal_default_instance() {
    return reinterpret_cast<const TCPFlagsPredicate*>(
        &_TCPFlagsPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(TCPFlagsPredicate& a, TCPFlagsPredicate& b) { a.Swap(&b); }
  inline void Swap(TCPFlagsPredicate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCPFlagsPredicate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCPFlagsPredicate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TCPFlagsPredicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TCPFlagsPredicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TCPFlagsPredicate& from) { TCPFlagsPredicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TCPFlagsPredicate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.TCPFlagsPredicate"; }

 protected:
  explicit TCPFlagsPredicate(::google::protobuf::Arena* arena);
  TCPFlagsPredicate(::google::protobuf::Arena* arena, const TCPFlagsPredicate& from);
  TCPFlagsPredicate(::google::protobuf::Arena* arena, TCPFlagsPredicate&& from) noexcept
      : TCPFlagsPredicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 2,
    kOperatorFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.TCPFlag values = 2 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  public:
  ::kentik::ktbgp::v202501::TCPFlag values(int index) const;
  void set_values(int index, ::kentik::ktbgp::v202501::TCPFlag value);
  void add_values(::kentik::ktbgp::v202501::TCPFlag value);
  const ::google::protobuf::RepeatedField<int>& values() const;
  ::google::protobuf::RepeatedField<int>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_values() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_values();

  public:
  // .kentik.ktbgp.v202501.BitwiseOp operator = 1 [json_name = "operator"];
  void clear_operator_() ;
  ::kentik::ktbgp::v202501::BitwiseOp operator_() const;
  void set_operator_(::kentik::ktbgp::v202501::BitwiseOp value);

  private:
  ::kentik::ktbgp::v202501::BitwiseOp _internal_operator_() const;
  void _internal_set_operator_(::kentik::ktbgp::v202501::BitwiseOp value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.TCPFlagsPredicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TCPFlagsPredicate& from_msg);
    ::google::protobuf::RepeatedField<int> values_;
    ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    int operator__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RoutesFilter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RoutesFilter) */ {
 public:
  inline RoutesFilter() : RoutesFilter(nullptr) {}
  ~RoutesFilter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoutesFilter* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoutesFilter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutesFilter(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoutesFilter(const RoutesFilter& from) : RoutesFilter(nullptr, from) {}
  inline RoutesFilter(RoutesFilter&& from) noexcept
      : RoutesFilter(nullptr, std::move(from)) {}
  inline RoutesFilter& operator=(const RoutesFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutesFilter& operator=(RoutesFilter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutesFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutesFilter* internal_default_instance() {
    return reinterpret_cast<const RoutesFilter*>(
        &_RoutesFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(RoutesFilter& a, RoutesFilter& b) { a.Swap(&b); }
  inline void Swap(RoutesFilter* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutesFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutesFilter* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoutesFilter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutesFilter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutesFilter& from) { RoutesFilter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoutesFilter* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RoutesFilter"; }

 protected:
  explicit RoutesFilter(::google::protobuf::Arena* arena);
  RoutesFilter(::google::protobuf::Arena* arena, const RoutesFilter& from);
  RoutesFilter(::google::protobuf::Arena* arena, RoutesFilter&& from) noexcept
      : RoutesFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceIdsFieldNumber = 1,
  };
  // repeated uint64 device_ids = 1 [json_name = "deviceIds"];
  int device_ids_size() const;
  private:
  int _internal_device_ids_size() const;

  public:
  void clear_device_ids() ;
  ::uint64_t device_ids(int index) const;
  void set_device_ids(int index, ::uint64_t value);
  void add_device_ids(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& device_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_device_ids();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_device_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_device_ids();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RoutesFilter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RoutesFilter& from_msg);
    ::google::protobuf::RepeatedField<::uint64_t> device_ids_;
    ::google::protobuf::internal::CachedSize _device_ids_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RTBHMatch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RTBHMatch) */ {
 public:
  inline RTBHMatch() : RTBHMatch(nullptr) {}
  ~RTBHMatch() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RTBHMatch* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RTBHMatch));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RTBHMatch(
      ::google::protobuf::internal::ConstantInitialized);

  inline RTBHMatch(const RTBHMatch& from) : RTBHMatch(nullptr, from) {}
  inline RTBHMatch(RTBHMatch&& from) noexcept
      : RTBHMatch(nullptr, std::move(from)) {}
  inline RTBHMatch& operator=(const RTBHMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTBHMatch& operator=(RTBHMatch&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTBHMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTBHMatch* internal_default_instance() {
    return reinterpret_cast<const RTBHMatch*>(
        &_RTBHMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(RTBHMatch& a, RTBHMatch& b) { a.Swap(&b); }
  inline void Swap(RTBHMatch* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTBHMatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTBHMatch* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RTBHMatch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RTBHMatch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RTBHMatch& from) { RTBHMatch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RTBHMatch* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RTBHMatch"; }

 protected:
  explicit RTBHMatch(::google::protobuf::Arena* arena);
  RTBHMatch(::google::protobuf::Arena* arena, const RTBHMatch& from);
  RTBHMatch(::google::protobuf::Arena* arena, RTBHMatch&& from) noexcept
      : RTBHMatch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSrcPrefixFieldNumber = 1,
  };
  // string src_prefix = 1 [json_name = "srcPrefix"];
  void clear_src_prefix() ;
  const std::string& src_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_src_prefix();
  PROTOBUF_NODISCARD std::string* release_src_prefix();
  void set_allocated_src_prefix(std::string* value);

  private:
  const std::string& _internal_src_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_prefix(
      const std::string& value);
  std::string* _internal_mutable_src_prefix();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RTBHMatch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RTBHMatch& from_msg);
    ::google::protobuf::internal::ArenaStringPtr src_prefix_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RTBHAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RTBHAction) */ {
 public:
  inline RTBHAction() : RTBHAction(nullptr) {}
  ~RTBHAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RTBHAction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RTBHAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RTBHAction(
      ::google::protobuf::internal::ConstantInitialized);

  inline RTBHAction(const RTBHAction& from) : RTBHAction(nullptr, from) {}
  inline RTBHAction(RTBHAction&& from) noexcept
      : RTBHAction(nullptr, std::move(from)) {}
  inline RTBHAction& operator=(const RTBHAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTBHAction& operator=(RTBHAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTBHAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTBHAction* internal_default_instance() {
    return reinterpret_cast<const RTBHAction*>(
        &_RTBHAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(RTBHAction& a, RTBHAction& b) { a.Swap(&b); }
  inline void Swap(RTBHAction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTBHAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTBHAction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RTBHAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RTBHAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RTBHAction& from) { RTBHAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RTBHAction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RTBHAction"; }

 protected:
  explicit RTBHAction(::google::protobuf::Arena* arena);
  RTBHAction(::google::protobuf::Arena* arena, const RTBHAction& from);
  RTBHAction(::google::protobuf::Arena* arena, RTBHAction&& from) noexcept
      : RTBHAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBgpCommunitiesFieldNumber = 1,
    kNextHopFieldNumber = 2,
    kLocalPreferenceFieldNumber = 3,
  };
  // repeated uint32 bgp_communities = 1 [json_name = "bgpCommunities"];
  int bgp_communities_size() const;
  private:
  int _internal_bgp_communities_size() const;

  public:
  void clear_bgp_communities() ;
  ::uint32_t bgp_communities(int index) const;
  void set_bgp_communities(int index, ::uint32_t value);
  void add_bgp_communities(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& bgp_communities() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_bgp_communities();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_bgp_communities() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_bgp_communities();

  public:
  // string next_hop = 2 [json_name = "nextHop"];
  void clear_next_hop() ;
  const std::string& next_hop() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_hop(Arg_&& arg, Args_... args);
  std::string* mutable_next_hop();
  PROTOBUF_NODISCARD std::string* release_next_hop();
  void set_allocated_next_hop(std::string* value);

  private:
  const std::string& _internal_next_hop() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_hop(
      const std::string& value);
  std::string* _internal_mutable_next_hop();

  public:
  // uint32 local_preference = 3 [json_name = "localPreference"];
  void clear_local_preference() ;
  ::uint32_t local_preference() const;
  void set_local_preference(::uint32_t value);

  private:
  ::uint32_t _internal_local_preference() const;
  void _internal_set_local_preference(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RTBHAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RTBHAction& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> bgp_communities_;
    ::google::protobuf::internal::CachedSize _bgp_communities_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr next_hop_;
    ::uint32_t local_preference_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class NumericPredicate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.NumericPredicate) */ {
 public:
  inline NumericPredicate() : NumericPredicate(nullptr) {}
  ~NumericPredicate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NumericPredicate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NumericPredicate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NumericPredicate(
      ::google::protobuf::internal::ConstantInitialized);

  inline NumericPredicate(const NumericPredicate& from) : NumericPredicate(nullptr, from) {}
  inline NumericPredicate(NumericPredicate&& from) noexcept
      : NumericPredicate(nullptr, std::move(from)) {}
  inline NumericPredicate& operator=(const NumericPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericPredicate& operator=(NumericPredicate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumericPredicate& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumericPredicate* internal_default_instance() {
    return reinterpret_cast<const NumericPredicate*>(
        &_NumericPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(NumericPredicate& a, NumericPredicate& b) { a.Swap(&b); }
  inline void Swap(NumericPredicate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericPredicate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumericPredicate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NumericPredicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumericPredicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NumericPredicate& from) { NumericPredicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NumericPredicate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.NumericPredicate"; }

 protected:
  explicit NumericPredicate(::google::protobuf::Arena* arena);
  NumericPredicate(::google::protobuf::Arena* arena, const NumericPredicate& from);
  NumericPredicate(::google::protobuf::Arena* arena, NumericPredicate&& from) noexcept
      : NumericPredicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 2,
    kOperatorFieldNumber = 1,
  };
  // uint64 value = 2 [json_name = "value"];
  void clear_value() ;
  ::uint64_t value() const;
  void set_value(::uint64_t value);

  private:
  ::uint64_t _internal_value() const;
  void _internal_set_value(::uint64_t value);

  public:
  // .kentik.ktbgp.v202501.NumericOp operator = 1 [json_name = "operator"];
  void clear_operator_() ;
  ::kentik::ktbgp::v202501::NumericOp operator_() const;
  void set_operator_(::kentik::ktbgp::v202501::NumericOp value);

  private:
  ::kentik::ktbgp::v202501::NumericOp _internal_operator_() const;
  void _internal_set_operator_(::kentik::ktbgp::v202501::NumericOp value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.NumericPredicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NumericPredicate& from_msg);
    ::uint64_t value_;
    int operator__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FragmentPredicate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FragmentPredicate) */ {
 public:
  inline FragmentPredicate() : FragmentPredicate(nullptr) {}
  ~FragmentPredicate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FragmentPredicate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FragmentPredicate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FragmentPredicate(
      ::google::protobuf::internal::ConstantInitialized);

  inline FragmentPredicate(const FragmentPredicate& from) : FragmentPredicate(nullptr, from) {}
  inline FragmentPredicate(FragmentPredicate&& from) noexcept
      : FragmentPredicate(nullptr, std::move(from)) {}
  inline FragmentPredicate& operator=(const FragmentPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentPredicate& operator=(FragmentPredicate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentPredicate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentPredicate* internal_default_instance() {
    return reinterpret_cast<const FragmentPredicate*>(
        &_FragmentPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(FragmentPredicate& a, FragmentPredicate& b) { a.Swap(&b); }
  inline void Swap(FragmentPredicate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentPredicate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentPredicate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FragmentPredicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FragmentPredicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FragmentPredicate& from) { FragmentPredicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FragmentPredicate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FragmentPredicate"; }

 protected:
  explicit FragmentPredicate(::google::protobuf::Arena* arena);
  FragmentPredicate(::google::protobuf::Arena* arena, const FragmentPredicate& from);
  FragmentPredicate(::google::protobuf::Arena* arena, FragmentPredicate&& from) noexcept
      : FragmentPredicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 2,
    kOperatorFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.Fragment values = 2 [json_name = "values"];
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  public:
  ::kentik::ktbgp::v202501::Fragment values(int index) const;
  void set_values(int index, ::kentik::ktbgp::v202501::Fragment value);
  void add_values(::kentik::ktbgp::v202501::Fragment value);
  const ::google::protobuf::RepeatedField<int>& values() const;
  ::google::protobuf::RepeatedField<int>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_values() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_values();

  public:
  // .kentik.ktbgp.v202501.BitwiseOp operator = 1 [json_name = "operator"];
  void clear_operator_() ;
  ::kentik::ktbgp::v202501::BitwiseOp operator_() const;
  void set_operator_(::kentik::ktbgp::v202501::BitwiseOp value);

  private:
  ::kentik::ktbgp::v202501::BitwiseOp _internal_operator_() const;
  void _internal_set_operator_(::kentik::ktbgp::v202501::BitwiseOp value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FragmentPredicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FragmentPredicate& from_msg);
    ::google::protobuf::RepeatedField<int> values_;
    ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    int operator__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionTrafficRateBytes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes) */ {
 public:
  inline FlowspecActionTrafficRateBytes() : FlowspecActionTrafficRateBytes(nullptr) {}
  ~FlowspecActionTrafficRateBytes() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionTrafficRateBytes* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionTrafficRateBytes));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionTrafficRateBytes(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionTrafficRateBytes(const FlowspecActionTrafficRateBytes& from) : FlowspecActionTrafficRateBytes(nullptr, from) {}
  inline FlowspecActionTrafficRateBytes(FlowspecActionTrafficRateBytes&& from) noexcept
      : FlowspecActionTrafficRateBytes(nullptr, std::move(from)) {}
  inline FlowspecActionTrafficRateBytes& operator=(const FlowspecActionTrafficRateBytes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionTrafficRateBytes& operator=(FlowspecActionTrafficRateBytes&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionTrafficRateBytes& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionTrafficRateBytes* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionTrafficRateBytes*>(
        &_FlowspecActionTrafficRateBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(FlowspecActionTrafficRateBytes& a, FlowspecActionTrafficRateBytes& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionTrafficRateBytes* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionTrafficRateBytes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionTrafficRateBytes* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionTrafficRateBytes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionTrafficRateBytes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionTrafficRateBytes& from) { FlowspecActionTrafficRateBytes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionTrafficRateBytes* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes"; }

 protected:
  explicit FlowspecActionTrafficRateBytes(::google::protobuf::Arena* arena);
  FlowspecActionTrafficRateBytes(::google::protobuf::Arena* arena, const FlowspecActionTrafficRateBytes& from);
  FlowspecActionTrafficRateBytes(::google::protobuf::Arena* arena, FlowspecActionTrafficRateBytes&& from) noexcept
      : FlowspecActionTrafficRateBytes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBytesPerSecondFieldNumber = 1,
  };
  // float bytes_per_second = 1 [json_name = "bytesPerSecond"];
  void clear_bytes_per_second() ;
  float bytes_per_second() const;
  void set_bytes_per_second(float value);

  private:
  float _internal_bytes_per_second() const;
  void _internal_set_bytes_per_second(float value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionTrafficRateBytes& from_msg);
    float bytes_per_second_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionTerminalSample final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionTerminalSample) */ {
 public:
  inline FlowspecActionTerminalSample() : FlowspecActionTerminalSample(nullptr) {}
  ~FlowspecActionTerminalSample() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionTerminalSample* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionTerminalSample));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionTerminalSample(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionTerminalSample(const FlowspecActionTerminalSample& from) : FlowspecActionTerminalSample(nullptr, from) {}
  inline FlowspecActionTerminalSample(FlowspecActionTerminalSample&& from) noexcept
      : FlowspecActionTerminalSample(nullptr, std::move(from)) {}
  inline FlowspecActionTerminalSample& operator=(const FlowspecActionTerminalSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionTerminalSample& operator=(FlowspecActionTerminalSample&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionTerminalSample& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionTerminalSample* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionTerminalSample*>(
        &_FlowspecActionTerminalSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(FlowspecActionTerminalSample& a, FlowspecActionTerminalSample& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionTerminalSample* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionTerminalSample* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionTerminalSample* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionTerminalSample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionTerminalSample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionTerminalSample& from) { FlowspecActionTerminalSample::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionTerminalSample* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionTerminalSample"; }

 protected:
  explicit FlowspecActionTerminalSample(::google::protobuf::Arena* arena);
  FlowspecActionTerminalSample(::google::protobuf::Arena* arena, const FlowspecActionTerminalSample& from);
  FlowspecActionTerminalSample(::google::protobuf::Arena* arena, FlowspecActionTerminalSample&& from) noexcept
      : FlowspecActionTerminalSample(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTerminalFieldNumber = 1,
    kSampleFieldNumber = 2,
  };
  // bool terminal = 1 [json_name = "terminal"];
  void clear_terminal() ;
  bool terminal() const;
  void set_terminal(bool value);

  private:
  bool _internal_terminal() const;
  void _internal_set_terminal(bool value);

  public:
  // bool sample = 2 [json_name = "sample"];
  void clear_sample() ;
  bool sample() const;
  void set_sample(bool value);

  private:
  bool _internal_sample() const;
  void _internal_set_sample(bool value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionTerminalSample)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionTerminalSample& from_msg);
    bool terminal_;
    bool sample_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionRouteTargetRedirect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect) */ {
 public:
  inline FlowspecActionRouteTargetRedirect() : FlowspecActionRouteTargetRedirect(nullptr) {}
  ~FlowspecActionRouteTargetRedirect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionRouteTargetRedirect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionRouteTargetRedirect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionRouteTargetRedirect(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionRouteTargetRedirect(const FlowspecActionRouteTargetRedirect& from) : FlowspecActionRouteTargetRedirect(nullptr, from) {}
  inline FlowspecActionRouteTargetRedirect(FlowspecActionRouteTargetRedirect&& from) noexcept
      : FlowspecActionRouteTargetRedirect(nullptr, std::move(from)) {}
  inline FlowspecActionRouteTargetRedirect& operator=(const FlowspecActionRouteTargetRedirect& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionRouteTargetRedirect& operator=(FlowspecActionRouteTargetRedirect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionRouteTargetRedirect& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionRouteTargetRedirect* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionRouteTargetRedirect*>(
        &_FlowspecActionRouteTargetRedirect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(FlowspecActionRouteTargetRedirect& a, FlowspecActionRouteTargetRedirect& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionRouteTargetRedirect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionRouteTargetRedirect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionRouteTargetRedirect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionRouteTargetRedirect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionRouteTargetRedirect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionRouteTargetRedirect& from) { FlowspecActionRouteTargetRedirect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionRouteTargetRedirect* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect"; }

 protected:
  explicit FlowspecActionRouteTargetRedirect(::google::protobuf::Arena* arena);
  FlowspecActionRouteTargetRedirect(::google::protobuf::Arena* arena, const FlowspecActionRouteTargetRedirect& from);
  FlowspecActionRouteTargetRedirect(::google::protobuf::Arena* arena, FlowspecActionRouteTargetRedirect&& from) noexcept
      : FlowspecActionRouteTargetRedirect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAsnFieldNumber = 1,
    kRouteTargetFieldNumber = 2,
  };
  // uint32 asn = 1 [json_name = "asn"];
  void clear_asn() ;
  ::uint32_t asn() const;
  void set_asn(::uint32_t value);

  private:
  ::uint32_t _internal_asn() const;
  void _internal_set_asn(::uint32_t value);

  public:
  // uint32 route_target = 2 [json_name = "routeTarget"];
  void clear_route_target() ;
  ::uint32_t route_target() const;
  void set_route_target(::uint32_t value);

  private:
  ::uint32_t _internal_route_target() const;
  void _internal_set_route_target(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionRouteTargetRedirect& from_msg);
    ::uint32_t asn_;
    ::uint32_t route_target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionRegularCommunity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionRegularCommunity) */ {
 public:
  inline FlowspecActionRegularCommunity() : FlowspecActionRegularCommunity(nullptr) {}
  ~FlowspecActionRegularCommunity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionRegularCommunity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionRegularCommunity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionRegularCommunity(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionRegularCommunity(const FlowspecActionRegularCommunity& from) : FlowspecActionRegularCommunity(nullptr, from) {}
  inline FlowspecActionRegularCommunity(FlowspecActionRegularCommunity&& from) noexcept
      : FlowspecActionRegularCommunity(nullptr, std::move(from)) {}
  inline FlowspecActionRegularCommunity& operator=(const FlowspecActionRegularCommunity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionRegularCommunity& operator=(FlowspecActionRegularCommunity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionRegularCommunity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionRegularCommunity* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionRegularCommunity*>(
        &_FlowspecActionRegularCommunity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(FlowspecActionRegularCommunity& a, FlowspecActionRegularCommunity& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionRegularCommunity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionRegularCommunity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionRegularCommunity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionRegularCommunity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionRegularCommunity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionRegularCommunity& from) { FlowspecActionRegularCommunity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionRegularCommunity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionRegularCommunity"; }

 protected:
  explicit FlowspecActionRegularCommunity(::google::protobuf::Arena* arena);
  FlowspecActionRegularCommunity(::google::protobuf::Arena* arena, const FlowspecActionRegularCommunity& from);
  FlowspecActionRegularCommunity(::google::protobuf::Arena* arena, FlowspecActionRegularCommunity&& from) noexcept
      : FlowspecActionRegularCommunity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAsn1FieldNumber = 1,
    kAsn2FieldNumber = 2,
  };
  // uint32 asn1 = 1 [json_name = "asn1"];
  void clear_asn1() ;
  ::uint32_t asn1() const;
  void set_asn1(::uint32_t value);

  private:
  ::uint32_t _internal_asn1() const;
  void _internal_set_asn1(::uint32_t value);

  public:
  // uint32 asn2 = 2 [json_name = "asn2"];
  void clear_asn2() ;
  ::uint32_t asn2() const;
  void set_asn2(::uint32_t value);

  private:
  ::uint32_t _internal_asn2() const;
  void _internal_set_asn2(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionRegularCommunity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionRegularCommunity& from_msg);
    ::uint32_t asn1_;
    ::uint32_t asn2_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionMarkDSCP final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionMarkDSCP) */ {
 public:
  inline FlowspecActionMarkDSCP() : FlowspecActionMarkDSCP(nullptr) {}
  ~FlowspecActionMarkDSCP() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionMarkDSCP* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionMarkDSCP));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionMarkDSCP(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionMarkDSCP(const FlowspecActionMarkDSCP& from) : FlowspecActionMarkDSCP(nullptr, from) {}
  inline FlowspecActionMarkDSCP(FlowspecActionMarkDSCP&& from) noexcept
      : FlowspecActionMarkDSCP(nullptr, std::move(from)) {}
  inline FlowspecActionMarkDSCP& operator=(const FlowspecActionMarkDSCP& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionMarkDSCP& operator=(FlowspecActionMarkDSCP&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionMarkDSCP& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionMarkDSCP* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionMarkDSCP*>(
        &_FlowspecActionMarkDSCP_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(FlowspecActionMarkDSCP& a, FlowspecActionMarkDSCP& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionMarkDSCP* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionMarkDSCP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionMarkDSCP* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionMarkDSCP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionMarkDSCP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionMarkDSCP& from) { FlowspecActionMarkDSCP::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionMarkDSCP* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionMarkDSCP"; }

 protected:
  explicit FlowspecActionMarkDSCP(::google::protobuf::Arena* arena);
  FlowspecActionMarkDSCP(::google::protobuf::Arena* arena, const FlowspecActionMarkDSCP& from);
  FlowspecActionMarkDSCP(::google::protobuf::Arena* arena, FlowspecActionMarkDSCP&& from) noexcept
      : FlowspecActionMarkDSCP(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDscpFieldNumber = 1,
  };
  // uint32 dscp = 1 [json_name = "dscp"];
  void clear_dscp() ;
  ::uint32_t dscp() const;
  void set_dscp(::uint32_t value);

  private:
  ::uint32_t _internal_dscp() const;
  void _internal_set_dscp(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionMarkDSCP)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionMarkDSCP& from_msg);
    ::uint32_t dscp_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionLargeCommunity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionLargeCommunity) */ {
 public:
  inline FlowspecActionLargeCommunity() : FlowspecActionLargeCommunity(nullptr) {}
  ~FlowspecActionLargeCommunity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionLargeCommunity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionLargeCommunity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionLargeCommunity(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionLargeCommunity(const FlowspecActionLargeCommunity& from) : FlowspecActionLargeCommunity(nullptr, from) {}
  inline FlowspecActionLargeCommunity(FlowspecActionLargeCommunity&& from) noexcept
      : FlowspecActionLargeCommunity(nullptr, std::move(from)) {}
  inline FlowspecActionLargeCommunity& operator=(const FlowspecActionLargeCommunity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionLargeCommunity& operator=(FlowspecActionLargeCommunity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionLargeCommunity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionLargeCommunity* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionLargeCommunity*>(
        &_FlowspecActionLargeCommunity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(FlowspecActionLargeCommunity& a, FlowspecActionLargeCommunity& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionLargeCommunity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionLargeCommunity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionLargeCommunity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionLargeCommunity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionLargeCommunity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionLargeCommunity& from) { FlowspecActionLargeCommunity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionLargeCommunity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionLargeCommunity"; }

 protected:
  explicit FlowspecActionLargeCommunity(::google::protobuf::Arena* arena);
  FlowspecActionLargeCommunity(::google::protobuf::Arena* arena, const FlowspecActionLargeCommunity& from);
  FlowspecActionLargeCommunity(::google::protobuf::Arena* arena, FlowspecActionLargeCommunity&& from) noexcept
      : FlowspecActionLargeCommunity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAsnFieldNumber = 1,
    kData1FieldNumber = 2,
    kData2FieldNumber = 3,
  };
  // uint32 asn = 1 [json_name = "asn"];
  void clear_asn() ;
  ::uint32_t asn() const;
  void set_asn(::uint32_t value);

  private:
  ::uint32_t _internal_asn() const;
  void _internal_set_asn(::uint32_t value);

  public:
  // uint32 data1 = 2 [json_name = "data1"];
  void clear_data1() ;
  ::uint32_t data1() const;
  void set_data1(::uint32_t value);

  private:
  ::uint32_t _internal_data1() const;
  void _internal_set_data1(::uint32_t value);

  public:
  // uint32 data2 = 3 [json_name = "data2"];
  void clear_data2() ;
  ::uint32_t data2() const;
  void set_data2(::uint32_t value);

  private:
  ::uint32_t _internal_data2() const;
  void _internal_set_data2(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionLargeCommunity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionLargeCommunity& from_msg);
    ::uint32_t asn_;
    ::uint32_t data1_;
    ::uint32_t data2_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionIPNextHopRedirect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect) */ {
 public:
  inline FlowspecActionIPNextHopRedirect() : FlowspecActionIPNextHopRedirect(nullptr) {}
  ~FlowspecActionIPNextHopRedirect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionIPNextHopRedirect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionIPNextHopRedirect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionIPNextHopRedirect(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionIPNextHopRedirect(const FlowspecActionIPNextHopRedirect& from) : FlowspecActionIPNextHopRedirect(nullptr, from) {}
  inline FlowspecActionIPNextHopRedirect(FlowspecActionIPNextHopRedirect&& from) noexcept
      : FlowspecActionIPNextHopRedirect(nullptr, std::move(from)) {}
  inline FlowspecActionIPNextHopRedirect& operator=(const FlowspecActionIPNextHopRedirect& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionIPNextHopRedirect& operator=(FlowspecActionIPNextHopRedirect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionIPNextHopRedirect& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionIPNextHopRedirect* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionIPNextHopRedirect*>(
        &_FlowspecActionIPNextHopRedirect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(FlowspecActionIPNextHopRedirect& a, FlowspecActionIPNextHopRedirect& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionIPNextHopRedirect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionIPNextHopRedirect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionIPNextHopRedirect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionIPNextHopRedirect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionIPNextHopRedirect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionIPNextHopRedirect& from) { FlowspecActionIPNextHopRedirect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionIPNextHopRedirect* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect"; }

 protected:
  explicit FlowspecActionIPNextHopRedirect(::google::protobuf::Arena* arena);
  FlowspecActionIPNextHopRedirect(::google::protobuf::Arena* arena, const FlowspecActionIPNextHopRedirect& from);
  FlowspecActionIPNextHopRedirect(::google::protobuf::Arena* arena, FlowspecActionIPNextHopRedirect&& from) noexcept
      : FlowspecActionIPNextHopRedirect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNextHopFieldNumber = 1,
  };
  // string next_hop = 1 [json_name = "nextHop"];
  void clear_next_hop() ;
  const std::string& next_hop() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_hop(Arg_&& arg, Args_... args);
  std::string* mutable_next_hop();
  PROTOBUF_NODISCARD std::string* release_next_hop();
  void set_allocated_next_hop(std::string* value);

  private:
  const std::string& _internal_next_hop() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_hop(
      const std::string& value);
  std::string* _internal_mutable_next_hop();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      69, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionIPNextHopRedirect& from_msg);
    ::google::protobuf::internal::ArenaStringPtr next_hop_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionIPNextHopCopy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy) */ {
 public:
  inline FlowspecActionIPNextHopCopy() : FlowspecActionIPNextHopCopy(nullptr) {}
  ~FlowspecActionIPNextHopCopy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionIPNextHopCopy* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionIPNextHopCopy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionIPNextHopCopy(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionIPNextHopCopy(const FlowspecActionIPNextHopCopy& from) : FlowspecActionIPNextHopCopy(nullptr, from) {}
  inline FlowspecActionIPNextHopCopy(FlowspecActionIPNextHopCopy&& from) noexcept
      : FlowspecActionIPNextHopCopy(nullptr, std::move(from)) {}
  inline FlowspecActionIPNextHopCopy& operator=(const FlowspecActionIPNextHopCopy& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionIPNextHopCopy& operator=(FlowspecActionIPNextHopCopy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionIPNextHopCopy& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionIPNextHopCopy* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionIPNextHopCopy*>(
        &_FlowspecActionIPNextHopCopy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(FlowspecActionIPNextHopCopy& a, FlowspecActionIPNextHopCopy& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionIPNextHopCopy* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionIPNextHopCopy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionIPNextHopCopy* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionIPNextHopCopy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionIPNextHopCopy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionIPNextHopCopy& from) { FlowspecActionIPNextHopCopy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionIPNextHopCopy* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy"; }

 protected:
  explicit FlowspecActionIPNextHopCopy(::google::protobuf::Arena* arena);
  FlowspecActionIPNextHopCopy(::google::protobuf::Arena* arena, const FlowspecActionIPNextHopCopy& from);
  FlowspecActionIPNextHopCopy(::google::protobuf::Arena* arena, FlowspecActionIPNextHopCopy&& from) noexcept
      : FlowspecActionIPNextHopCopy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNextHopFieldNumber = 1,
  };
  // string next_hop = 1 [json_name = "nextHop"];
  void clear_next_hop() ;
  const std::string& next_hop() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_hop(Arg_&& arg, Args_... args);
  std::string* mutable_next_hop();
  PROTOBUF_NODISCARD std::string* release_next_hop();
  void set_allocated_next_hop(std::string* value);

  private:
  const std::string& _internal_next_hop() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_hop(
      const std::string& value);
  std::string* _internal_mutable_next_hop();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionIPNextHopCopy& from_msg);
    ::google::protobuf::internal::ArenaStringPtr next_hop_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionExtendedCommunity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity) */ {
 public:
  inline FlowspecActionExtendedCommunity() : FlowspecActionExtendedCommunity(nullptr) {}
  ~FlowspecActionExtendedCommunity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionExtendedCommunity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionExtendedCommunity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionExtendedCommunity(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionExtendedCommunity(const FlowspecActionExtendedCommunity& from) : FlowspecActionExtendedCommunity(nullptr, from) {}
  inline FlowspecActionExtendedCommunity(FlowspecActionExtendedCommunity&& from) noexcept
      : FlowspecActionExtendedCommunity(nullptr, std::move(from)) {}
  inline FlowspecActionExtendedCommunity& operator=(const FlowspecActionExtendedCommunity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionExtendedCommunity& operator=(FlowspecActionExtendedCommunity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionExtendedCommunity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionExtendedCommunity* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionExtendedCommunity*>(
        &_FlowspecActionExtendedCommunity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(FlowspecActionExtendedCommunity& a, FlowspecActionExtendedCommunity& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionExtendedCommunity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionExtendedCommunity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionExtendedCommunity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecActionExtendedCommunity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecActionExtendedCommunity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecActionExtendedCommunity& from) { FlowspecActionExtendedCommunity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecActionExtendedCommunity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionExtendedCommunity"; }

 protected:
  explicit FlowspecActionExtendedCommunity(::google::protobuf::Arena* arena);
  FlowspecActionExtendedCommunity(::google::protobuf::Arena* arena, const FlowspecActionExtendedCommunity& from);
  FlowspecActionExtendedCommunity(::google::protobuf::Arena* arena, FlowspecActionExtendedCommunity&& from) noexcept
      : FlowspecActionExtendedCommunity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRouteTypeFieldNumber = 1,
    kAsn1FieldNumber = 2,
    kAsn2FieldNumber = 3,
  };
  // .kentik.ktbgp.v202501.ExtendedCommunityRouteType route_type = 1 [json_name = "routeType"];
  void clear_route_type() ;
  ::kentik::ktbgp::v202501::ExtendedCommunityRouteType route_type() const;
  void set_route_type(::kentik::ktbgp::v202501::ExtendedCommunityRouteType value);

  private:
  ::kentik::ktbgp::v202501::ExtendedCommunityRouteType _internal_route_type() const;
  void _internal_set_route_type(::kentik::ktbgp::v202501::ExtendedCommunityRouteType value);

  public:
  // uint32 asn1 = 2 [json_name = "asn1"];
  void clear_asn1() ;
  ::uint32_t asn1() const;
  void set_asn1(::uint32_t value);

  private:
  ::uint32_t _internal_asn1() const;
  void _internal_set_asn1(::uint32_t value);

  public:
  // uint32 asn2 = 3 [json_name = "asn2"];
  void clear_asn2() ;
  ::uint32_t asn2() const;
  void set_asn2(::uint32_t value);

  private:
  ::uint32_t _internal_asn2() const;
  void _internal_set_asn2(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionExtendedCommunity& from_msg);
    int route_type_;
    ::uint32_t asn1_;
    ::uint32_t asn2_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionDiscard final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionDiscard) */ {
 public:
  inline FlowspecActionDiscard() : FlowspecActionDiscard(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionDiscard* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionDiscard));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionDiscard(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionDiscard(const FlowspecActionDiscard& from) : FlowspecActionDiscard(nullptr, from) {}
  inline FlowspecActionDiscard(FlowspecActionDiscard&& from) noexcept
      : FlowspecActionDiscard(nullptr, std::move(from)) {}
  inline FlowspecActionDiscard& operator=(const FlowspecActionDiscard& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionDiscard& operator=(FlowspecActionDiscard&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionDiscard& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionDiscard* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionDiscard*>(
        &_FlowspecActionDiscard_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(FlowspecActionDiscard& a, FlowspecActionDiscard& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionDiscard* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionDiscard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionDiscard* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<FlowspecActionDiscard>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlowspecActionDiscard& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlowspecActionDiscard& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionDiscard"; }

 protected:
  explicit FlowspecActionDiscard(::google::protobuf::Arena* arena);
  FlowspecActionDiscard(::google::protobuf::Arena* arena, const FlowspecActionDiscard& from);
  FlowspecActionDiscard(::google::protobuf::Arena* arena, FlowspecActionDiscard&& from) noexcept
      : FlowspecActionDiscard(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionDiscard)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionDiscard& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecActionAccept final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecActionAccept) */ {
 public:
  inline FlowspecActionAccept() : FlowspecActionAccept(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecActionAccept* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecActionAccept));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecActionAccept(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecActionAccept(const FlowspecActionAccept& from) : FlowspecActionAccept(nullptr, from) {}
  inline FlowspecActionAccept(FlowspecActionAccept&& from) noexcept
      : FlowspecActionAccept(nullptr, std::move(from)) {}
  inline FlowspecActionAccept& operator=(const FlowspecActionAccept& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecActionAccept& operator=(FlowspecActionAccept&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecActionAccept& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecActionAccept* internal_default_instance() {
    return reinterpret_cast<const FlowspecActionAccept*>(
        &_FlowspecActionAccept_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(FlowspecActionAccept& a, FlowspecActionAccept& b) { a.Swap(&b); }
  inline void Swap(FlowspecActionAccept* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecActionAccept* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecActionAccept* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<FlowspecActionAccept>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlowspecActionAccept& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlowspecActionAccept& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecActionAccept"; }

 protected:
  explicit FlowspecActionAccept(::google::protobuf::Arena* arena);
  FlowspecActionAccept(::google::protobuf::Arena* arena, const FlowspecActionAccept& from);
  FlowspecActionAccept(::google::protobuf::Arena* arena, FlowspecActionAccept&& from) noexcept
      : FlowspecActionAccept(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecActionAccept)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecActionAccept& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TCPFlagsPredicateGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.TCPFlagsPredicateGroup) */ {
 public:
  inline TCPFlagsPredicateGroup() : TCPFlagsPredicateGroup(nullptr) {}
  ~TCPFlagsPredicateGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TCPFlagsPredicateGroup* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TCPFlagsPredicateGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TCPFlagsPredicateGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline TCPFlagsPredicateGroup(const TCPFlagsPredicateGroup& from) : TCPFlagsPredicateGroup(nullptr, from) {}
  inline TCPFlagsPredicateGroup(TCPFlagsPredicateGroup&& from) noexcept
      : TCPFlagsPredicateGroup(nullptr, std::move(from)) {}
  inline TCPFlagsPredicateGroup& operator=(const TCPFlagsPredicateGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCPFlagsPredicateGroup& operator=(TCPFlagsPredicateGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCPFlagsPredicateGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCPFlagsPredicateGroup* internal_default_instance() {
    return reinterpret_cast<const TCPFlagsPredicateGroup*>(
        &_TCPFlagsPredicateGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(TCPFlagsPredicateGroup& a, TCPFlagsPredicateGroup& b) { a.Swap(&b); }
  inline void Swap(TCPFlagsPredicateGroup* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCPFlagsPredicateGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCPFlagsPredicateGroup* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TCPFlagsPredicateGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TCPFlagsPredicateGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TCPFlagsPredicateGroup& from) { TCPFlagsPredicateGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TCPFlagsPredicateGroup* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.TCPFlagsPredicateGroup"; }

 protected:
  explicit TCPFlagsPredicateGroup(::google::protobuf::Arena* arena);
  TCPFlagsPredicateGroup(::google::protobuf::Arena* arena, const TCPFlagsPredicateGroup& from);
  TCPFlagsPredicateGroup(::google::protobuf::Arena* arena, TCPFlagsPredicateGroup&& from) noexcept
      : TCPFlagsPredicateGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAndFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.TCPFlagsPredicate and = 1 [json_name = "and"];
  int and__size() const;
  private:
  int _internal_and__size() const;

  public:
  void clear_and_() ;
  ::kentik::ktbgp::v202501::TCPFlagsPredicate* mutable_and_(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>* mutable_and_();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>& _internal_and_() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>* _internal_mutable_and_();
  public:
  const ::kentik::ktbgp::v202501::TCPFlagsPredicate& and_(int index) const;
  ::kentik::ktbgp::v202501::TCPFlagsPredicate* add_and_();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>& and_() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.TCPFlagsPredicateGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TCPFlagsPredicateGroup& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::TCPFlagsPredicate > and__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceWithdrawResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RouteServiceWithdrawResponse) */ {
 public:
  inline RouteServiceWithdrawResponse() : RouteServiceWithdrawResponse(nullptr) {}
  ~RouteServiceWithdrawResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteServiceWithdrawResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteServiceWithdrawResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteServiceWithdrawResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteServiceWithdrawResponse(const RouteServiceWithdrawResponse& from) : RouteServiceWithdrawResponse(nullptr, from) {}
  inline RouteServiceWithdrawResponse(RouteServiceWithdrawResponse&& from) noexcept
      : RouteServiceWithdrawResponse(nullptr, std::move(from)) {}
  inline RouteServiceWithdrawResponse& operator=(const RouteServiceWithdrawResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceWithdrawResponse& operator=(RouteServiceWithdrawResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteServiceWithdrawResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteServiceWithdrawResponse* internal_default_instance() {
    return reinterpret_cast<const RouteServiceWithdrawResponse*>(
        &_RouteServiceWithdrawResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RouteServiceWithdrawResponse& a, RouteServiceWithdrawResponse& b) { a.Swap(&b); }
  inline void Swap(RouteServiceWithdrawResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteServiceWithdrawResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteServiceWithdrawResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteServiceWithdrawResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteServiceWithdrawResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteServiceWithdrawResponse& from) { RouteServiceWithdrawResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteServiceWithdrawResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RouteServiceWithdrawResponse"; }

 protected:
  explicit RouteServiceWithdrawResponse(::google::protobuf::Arena* arena);
  RouteServiceWithdrawResponse(::google::protobuf::Arena* arena, const RouteServiceWithdrawResponse& from);
  RouteServiceWithdrawResponse(::google::protobuf::Arena* arena, RouteServiceWithdrawResponse&& from) noexcept
      : RouteServiceWithdrawResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.UpdateResult results = 1 [json_name = "results"];
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  ::kentik::ktbgp::v202501::UpdateResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>* mutable_results();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>* _internal_mutable_results();
  public:
  const ::kentik::ktbgp::v202501::UpdateResult& results(int index) const;
  ::kentik::ktbgp::v202501::UpdateResult* add_results();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>& results() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RouteServiceWithdrawResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteServiceWithdrawResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::UpdateResult > results_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceListRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RouteServiceListRequest) */ {
 public:
  inline RouteServiceListRequest() : RouteServiceListRequest(nullptr) {}
  ~RouteServiceListRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteServiceListRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteServiceListRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteServiceListRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteServiceListRequest(const RouteServiceListRequest& from) : RouteServiceListRequest(nullptr, from) {}
  inline RouteServiceListRequest(RouteServiceListRequest&& from) noexcept
      : RouteServiceListRequest(nullptr, std::move(from)) {}
  inline RouteServiceListRequest& operator=(const RouteServiceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceListRequest& operator=(RouteServiceListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteServiceListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteServiceListRequest* internal_default_instance() {
    return reinterpret_cast<const RouteServiceListRequest*>(
        &_RouteServiceListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(RouteServiceListRequest& a, RouteServiceListRequest& b) { a.Swap(&b); }
  inline void Swap(RouteServiceListRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteServiceListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteServiceListRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteServiceListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteServiceListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteServiceListRequest& from) { RouteServiceListRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteServiceListRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RouteServiceListRequest"; }

 protected:
  explicit RouteServiceListRequest(::google::protobuf::Arena* arena);
  RouteServiceListRequest(::google::protobuf::Arena* arena, const RouteServiceListRequest& from);
  RouteServiceListRequest(::google::protobuf::Arena* arena, RouteServiceListRequest&& from) noexcept
      : RouteServiceListRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFiltersFieldNumber = 1,
  };
  // .kentik.ktbgp.v202501.RoutesFilter filters = 1 [json_name = "filters"];
  bool has_filters() const;
  void clear_filters() ;
  const ::kentik::ktbgp::v202501::RoutesFilter& filters() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::RoutesFilter* release_filters();
  ::kentik::ktbgp::v202501::RoutesFilter* mutable_filters();
  void set_allocated_filters(::kentik::ktbgp::v202501::RoutesFilter* value);
  void unsafe_arena_set_allocated_filters(::kentik::ktbgp::v202501::RoutesFilter* value);
  ::kentik::ktbgp::v202501::RoutesFilter* unsafe_arena_release_filters();

  private:
  const ::kentik::ktbgp::v202501::RoutesFilter& _internal_filters() const;
  ::kentik::ktbgp::v202501::RoutesFilter* _internal_mutable_filters();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RouteServiceListRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteServiceListRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::kentik::ktbgp::v202501::RoutesFilter* filters_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceAnnounceResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RouteServiceAnnounceResponse) */ {
 public:
  inline RouteServiceAnnounceResponse() : RouteServiceAnnounceResponse(nullptr) {}
  ~RouteServiceAnnounceResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteServiceAnnounceResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteServiceAnnounceResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteServiceAnnounceResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteServiceAnnounceResponse(const RouteServiceAnnounceResponse& from) : RouteServiceAnnounceResponse(nullptr, from) {}
  inline RouteServiceAnnounceResponse(RouteServiceAnnounceResponse&& from) noexcept
      : RouteServiceAnnounceResponse(nullptr, std::move(from)) {}
  inline RouteServiceAnnounceResponse& operator=(const RouteServiceAnnounceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceAnnounceResponse& operator=(RouteServiceAnnounceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteServiceAnnounceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteServiceAnnounceResponse* internal_default_instance() {
    return reinterpret_cast<const RouteServiceAnnounceResponse*>(
        &_RouteServiceAnnounceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RouteServiceAnnounceResponse& a, RouteServiceAnnounceResponse& b) { a.Swap(&b); }
  inline void Swap(RouteServiceAnnounceResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteServiceAnnounceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteServiceAnnounceResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteServiceAnnounceResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteServiceAnnounceResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteServiceAnnounceResponse& from) { RouteServiceAnnounceResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteServiceAnnounceResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RouteServiceAnnounceResponse"; }

 protected:
  explicit RouteServiceAnnounceResponse(::google::protobuf::Arena* arena);
  RouteServiceAnnounceResponse(::google::protobuf::Arena* arena, const RouteServiceAnnounceResponse& from);
  RouteServiceAnnounceResponse(::google::protobuf::Arena* arena, RouteServiceAnnounceResponse&& from) noexcept
      : RouteServiceAnnounceResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.UpdateResult results = 1 [json_name = "results"];
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  ::kentik::ktbgp::v202501::UpdateResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>* mutable_results();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>* _internal_mutable_results();
  public:
  const ::kentik::ktbgp::v202501::UpdateResult& results(int index) const;
  ::kentik::ktbgp::v202501::UpdateResult* add_results();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>& results() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RouteServiceAnnounceResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteServiceAnnounceResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::UpdateResult > results_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RTBHUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RTBHUpdate) */ {
 public:
  inline RTBHUpdate() : RTBHUpdate(nullptr) {}
  ~RTBHUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RTBHUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RTBHUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RTBHUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline RTBHUpdate(const RTBHUpdate& from) : RTBHUpdate(nullptr, from) {}
  inline RTBHUpdate(RTBHUpdate&& from) noexcept
      : RTBHUpdate(nullptr, std::move(from)) {}
  inline RTBHUpdate& operator=(const RTBHUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTBHUpdate& operator=(RTBHUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTBHUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTBHUpdate* internal_default_instance() {
    return reinterpret_cast<const RTBHUpdate*>(
        &_RTBHUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RTBHUpdate& a, RTBHUpdate& b) { a.Swap(&b); }
  inline void Swap(RTBHUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTBHUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTBHUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RTBHUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RTBHUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RTBHUpdate& from) { RTBHUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RTBHUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RTBHUpdate"; }

 protected:
  explicit RTBHUpdate(::google::protobuf::Arena* arena);
  RTBHUpdate(::google::protobuf::Arena* arena, const RTBHUpdate& from);
  RTBHUpdate(::google::protobuf::Arena* arena, RTBHUpdate&& from) noexcept
      : RTBHUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInetFieldNumber = 4,
    kKeyFieldNumber = 6,
    kMatchFieldNumber = 1,
    kActionFieldNumber = 2,
    kCreationTimeFieldNumber = 3,
    kInetTypeFieldNumber = 5,
  };
  // string inet = 4 [json_name = "inet", deprecated = true];
  [[deprecated]]  void clear_inet() ;
  [[deprecated]] const std::string& inet() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_inet(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_inet();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_inet();
  [[deprecated]] void set_allocated_inet(std::string* value);

  private:
  const std::string& _internal_inet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inet(
      const std::string& value);
  std::string* _internal_mutable_inet();

  public:
  // string key = 6 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .kentik.ktbgp.v202501.RTBHMatch match = 1 [json_name = "match"];
  bool has_match() const;
  void clear_match() ;
  const ::kentik::ktbgp::v202501::RTBHMatch& match() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::RTBHMatch* release_match();
  ::kentik::ktbgp::v202501::RTBHMatch* mutable_match();
  void set_allocated_match(::kentik::ktbgp::v202501::RTBHMatch* value);
  void unsafe_arena_set_allocated_match(::kentik::ktbgp::v202501::RTBHMatch* value);
  ::kentik::ktbgp::v202501::RTBHMatch* unsafe_arena_release_match();

  private:
  const ::kentik::ktbgp::v202501::RTBHMatch& _internal_match() const;
  ::kentik::ktbgp::v202501::RTBHMatch* _internal_mutable_match();

  public:
  // .kentik.ktbgp.v202501.RTBHAction action = 2 [json_name = "action"];
  bool has_action() const;
  void clear_action() ;
  const ::kentik::ktbgp::v202501::RTBHAction& action() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::RTBHAction* release_action();
  ::kentik::ktbgp::v202501::RTBHAction* mutable_action();
  void set_allocated_action(::kentik::ktbgp::v202501::RTBHAction* value);
  void unsafe_arena_set_allocated_action(::kentik::ktbgp::v202501::RTBHAction* value);
  ::kentik::ktbgp::v202501::RTBHAction* unsafe_arena_release_action();

  private:
  const ::kentik::ktbgp::v202501::RTBHAction& _internal_action() const;
  ::kentik::ktbgp::v202501::RTBHAction* _internal_mutable_action();

  public:
  // .google.protobuf.Timestamp creation_time = 3 [json_name = "creationTime"];
  bool has_creation_time() const;
  void clear_creation_time() ;
  const ::google::protobuf::Timestamp& creation_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_creation_time();
  ::google::protobuf::Timestamp* mutable_creation_time();
  void set_allocated_creation_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_creation_time();

  private:
  const ::google::protobuf::Timestamp& _internal_creation_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_creation_time();

  public:
  // .kentik.ktbgp.v202501.InetType inet_type = 5 [json_name = "inetType"];
  void clear_inet_type() ;
  ::kentik::ktbgp::v202501::InetType inet_type() const;
  void set_inet_type(::kentik::ktbgp::v202501::InetType value);

  private:
  ::kentik::ktbgp::v202501::InetType _internal_inet_type() const;
  void _internal_set_inet_type(::kentik::ktbgp::v202501::InetType value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RTBHUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RTBHUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr inet_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::kentik::ktbgp::v202501::RTBHMatch* match_;
    ::kentik::ktbgp::v202501::RTBHAction* action_;
    ::google::protobuf::Timestamp* creation_time_;
    int inet_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class NumericPredicateGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.NumericPredicateGroup) */ {
 public:
  inline NumericPredicateGroup() : NumericPredicateGroup(nullptr) {}
  ~NumericPredicateGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NumericPredicateGroup* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NumericPredicateGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NumericPredicateGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline NumericPredicateGroup(const NumericPredicateGroup& from) : NumericPredicateGroup(nullptr, from) {}
  inline NumericPredicateGroup(NumericPredicateGroup&& from) noexcept
      : NumericPredicateGroup(nullptr, std::move(from)) {}
  inline NumericPredicateGroup& operator=(const NumericPredicateGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericPredicateGroup& operator=(NumericPredicateGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumericPredicateGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumericPredicateGroup* internal_default_instance() {
    return reinterpret_cast<const NumericPredicateGroup*>(
        &_NumericPredicateGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(NumericPredicateGroup& a, NumericPredicateGroup& b) { a.Swap(&b); }
  inline void Swap(NumericPredicateGroup* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericPredicateGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumericPredicateGroup* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NumericPredicateGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumericPredicateGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NumericPredicateGroup& from) { NumericPredicateGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NumericPredicateGroup* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.NumericPredicateGroup"; }

 protected:
  explicit NumericPredicateGroup(::google::protobuf::Arena* arena);
  NumericPredicateGroup(::google::protobuf::Arena* arena, const NumericPredicateGroup& from);
  NumericPredicateGroup(::google::protobuf::Arena* arena, NumericPredicateGroup&& from) noexcept
      : NumericPredicateGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAndFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.NumericPredicate and = 1 [json_name = "and"];
  int and__size() const;
  private:
  int _internal_and__size() const;

  public:
  void clear_and_() ;
  ::kentik::ktbgp::v202501::NumericPredicate* mutable_and_(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>* mutable_and_();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>& _internal_and_() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>* _internal_mutable_and_();
  public:
  const ::kentik::ktbgp::v202501::NumericPredicate& and_(int index) const;
  ::kentik::ktbgp::v202501::NumericPredicate* add_and_();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>& and_() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.NumericPredicateGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NumericPredicateGroup& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::NumericPredicate > and__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FragmentPredicateGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FragmentPredicateGroup) */ {
 public:
  inline FragmentPredicateGroup() : FragmentPredicateGroup(nullptr) {}
  ~FragmentPredicateGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FragmentPredicateGroup* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FragmentPredicateGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FragmentPredicateGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline FragmentPredicateGroup(const FragmentPredicateGroup& from) : FragmentPredicateGroup(nullptr, from) {}
  inline FragmentPredicateGroup(FragmentPredicateGroup&& from) noexcept
      : FragmentPredicateGroup(nullptr, std::move(from)) {}
  inline FragmentPredicateGroup& operator=(const FragmentPredicateGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentPredicateGroup& operator=(FragmentPredicateGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentPredicateGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentPredicateGroup* internal_default_instance() {
    return reinterpret_cast<const FragmentPredicateGroup*>(
        &_FragmentPredicateGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(FragmentPredicateGroup& a, FragmentPredicateGroup& b) { a.Swap(&b); }
  inline void Swap(FragmentPredicateGroup* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentPredicateGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentPredicateGroup* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FragmentPredicateGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FragmentPredicateGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FragmentPredicateGroup& from) { FragmentPredicateGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FragmentPredicateGroup* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FragmentPredicateGroup"; }

 protected:
  explicit FragmentPredicateGroup(::google::protobuf::Arena* arena);
  FragmentPredicateGroup(::google::protobuf::Arena* arena, const FragmentPredicateGroup& from);
  FragmentPredicateGroup(::google::protobuf::Arena* arena, FragmentPredicateGroup&& from) noexcept
      : FragmentPredicateGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAndFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.FragmentPredicate and = 1 [json_name = "and"];
  int and__size() const;
  private:
  int _internal_and__size() const;

  public:
  void clear_and_() ;
  ::kentik::ktbgp::v202501::FragmentPredicate* mutable_and_(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>* mutable_and_();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>& _internal_and_() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>* _internal_mutable_and_();
  public:
  const ::kentik::ktbgp::v202501::FragmentPredicate& and_(int index) const;
  ::kentik::ktbgp::v202501::FragmentPredicate* add_and_();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>& and_() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FragmentPredicateGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FragmentPredicateGroup& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::FragmentPredicate > and__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecAction) */ {
 public:
  inline FlowspecAction() : FlowspecAction(nullptr) {}
  ~FlowspecAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecAction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecAction(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecAction(const FlowspecAction& from) : FlowspecAction(nullptr, from) {}
  inline FlowspecAction(FlowspecAction&& from) noexcept
      : FlowspecAction(nullptr, std::move(from)) {}
  inline FlowspecAction& operator=(const FlowspecAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecAction& operator=(FlowspecAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecAction& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kAccept = 1,
    kDiscard = 2,
    kRateBytes = 3,
    kMarkDscp = 4,
    kRtRedirect = 5,
    kIpRedirect = 6,
    kActionType = 7,
    kRtCopy = 8,
    kRegularCommunity = 9,
    kExtendedCommunity = 10,
    kLargeCommunity = 11,
    ACTION_NOT_SET = 0,
  };
  static inline const FlowspecAction* internal_default_instance() {
    return reinterpret_cast<const FlowspecAction*>(
        &_FlowspecAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(FlowspecAction& a, FlowspecAction& b) { a.Swap(&b); }
  inline void Swap(FlowspecAction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecAction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecAction& from) { FlowspecAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecAction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecAction"; }

 protected:
  explicit FlowspecAction(::google::protobuf::Arena* arena);
  FlowspecAction(::google::protobuf::Arena* arena, const FlowspecAction& from);
  FlowspecAction(::google::protobuf::Arena* arena, FlowspecAction&& from) noexcept
      : FlowspecAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAcceptFieldNumber = 1,
    kDiscardFieldNumber = 2,
    kRateBytesFieldNumber = 3,
    kMarkDscpFieldNumber = 4,
    kRtRedirectFieldNumber = 5,
    kIpRedirectFieldNumber = 6,
    kActionTypeFieldNumber = 7,
    kRtCopyFieldNumber = 8,
    kRegularCommunityFieldNumber = 9,
    kExtendedCommunityFieldNumber = 10,
    kLargeCommunityFieldNumber = 11,
  };
  // .kentik.ktbgp.v202501.FlowspecActionAccept accept = 1 [json_name = "accept"];
  bool has_accept() const;
  private:
  bool _internal_has_accept() const;

  public:
  void clear_accept() ;
  const ::kentik::ktbgp::v202501::FlowspecActionAccept& accept() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionAccept* release_accept();
  ::kentik::ktbgp::v202501::FlowspecActionAccept* mutable_accept();
  void set_allocated_accept(::kentik::ktbgp::v202501::FlowspecActionAccept* value);
  void unsafe_arena_set_allocated_accept(::kentik::ktbgp::v202501::FlowspecActionAccept* value);
  ::kentik::ktbgp::v202501::FlowspecActionAccept* unsafe_arena_release_accept();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionAccept& _internal_accept() const;
  ::kentik::ktbgp::v202501::FlowspecActionAccept* _internal_mutable_accept();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionDiscard discard = 2 [json_name = "discard"];
  bool has_discard() const;
  private:
  bool _internal_has_discard() const;

  public:
  void clear_discard() ;
  const ::kentik::ktbgp::v202501::FlowspecActionDiscard& discard() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionDiscard* release_discard();
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* mutable_discard();
  void set_allocated_discard(::kentik::ktbgp::v202501::FlowspecActionDiscard* value);
  void unsafe_arena_set_allocated_discard(::kentik::ktbgp::v202501::FlowspecActionDiscard* value);
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* unsafe_arena_release_discard();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionDiscard& _internal_discard() const;
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* _internal_mutable_discard();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes rate_bytes = 3 [json_name = "rateBytes"];
  bool has_rate_bytes() const;
  private:
  bool _internal_has_rate_bytes() const;

  public:
  void clear_rate_bytes() ;
  const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& rate_bytes() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* release_rate_bytes();
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* mutable_rate_bytes();
  void set_allocated_rate_bytes(::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* value);
  void unsafe_arena_set_allocated_rate_bytes(::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* value);
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* unsafe_arena_release_rate_bytes();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& _internal_rate_bytes() const;
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* _internal_mutable_rate_bytes();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionMarkDSCP mark_dscp = 4 [json_name = "markDscp"];
  bool has_mark_dscp() const;
  private:
  bool _internal_has_mark_dscp() const;

  public:
  void clear_mark_dscp() ;
  const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& mark_dscp() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* release_mark_dscp();
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* mutable_mark_dscp();
  void set_allocated_mark_dscp(::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* value);
  void unsafe_arena_set_allocated_mark_dscp(::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* value);
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* unsafe_arena_release_mark_dscp();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& _internal_mark_dscp() const;
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* _internal_mutable_mark_dscp();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect rt_redirect = 5 [json_name = "rtRedirect"];
  bool has_rt_redirect() const;
  private:
  bool _internal_has_rt_redirect() const;

  public:
  void clear_rt_redirect() ;
  const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& rt_redirect() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* release_rt_redirect();
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* mutable_rt_redirect();
  void set_allocated_rt_redirect(::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* value);
  void unsafe_arena_set_allocated_rt_redirect(::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* value);
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* unsafe_arena_release_rt_redirect();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& _internal_rt_redirect() const;
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* _internal_mutable_rt_redirect();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect ip_redirect = 6 [json_name = "ipRedirect"];
  bool has_ip_redirect() const;
  private:
  bool _internal_has_ip_redirect() const;

  public:
  void clear_ip_redirect() ;
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& ip_redirect() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* release_ip_redirect();
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* mutable_ip_redirect();
  void set_allocated_ip_redirect(::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* value);
  void unsafe_arena_set_allocated_ip_redirect(::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* value);
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* unsafe_arena_release_ip_redirect();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& _internal_ip_redirect() const;
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* _internal_mutable_ip_redirect();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionTerminalSample action_type = 7 [json_name = "actionType"];
  bool has_action_type() const;
  private:
  bool _internal_has_action_type() const;

  public:
  void clear_action_type() ;
  const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& action_type() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* release_action_type();
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* mutable_action_type();
  void set_allocated_action_type(::kentik::ktbgp::v202501::FlowspecActionTerminalSample* value);
  void unsafe_arena_set_allocated_action_type(::kentik::ktbgp::v202501::FlowspecActionTerminalSample* value);
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* unsafe_arena_release_action_type();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& _internal_action_type() const;
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* _internal_mutable_action_type();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy rt_copy = 8 [json_name = "rtCopy"];
  bool has_rt_copy() const;
  private:
  bool _internal_has_rt_copy() const;

  public:
  void clear_rt_copy() ;
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& rt_copy() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* release_rt_copy();
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* mutable_rt_copy();
  void set_allocated_rt_copy(::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* value);
  void unsafe_arena_set_allocated_rt_copy(::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* value);
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* unsafe_arena_release_rt_copy();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& _internal_rt_copy() const;
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* _internal_mutable_rt_copy();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionRegularCommunity regular_community = 9 [json_name = "regularCommunity"];
  bool has_regular_community() const;
  private:
  bool _internal_has_regular_community() const;

  public:
  void clear_regular_community() ;
  const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& regular_community() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* release_regular_community();
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* mutable_regular_community();
  void set_allocated_regular_community(::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* value);
  void unsafe_arena_set_allocated_regular_community(::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* value);
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* unsafe_arena_release_regular_community();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& _internal_regular_community() const;
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* _internal_mutable_regular_community();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionExtendedCommunity extended_community = 10 [json_name = "extendedCommunity"];
  bool has_extended_community() const;
  private:
  bool _internal_has_extended_community() const;

  public:
  void clear_extended_community() ;
  const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& extended_community() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* release_extended_community();
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* mutable_extended_community();
  void set_allocated_extended_community(::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* value);
  void unsafe_arena_set_allocated_extended_community(::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* value);
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* unsafe_arena_release_extended_community();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& _internal_extended_community() const;
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* _internal_mutable_extended_community();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionLargeCommunity large_community = 11 [json_name = "largeCommunity"];
  bool has_large_community() const;
  private:
  bool _internal_has_large_community() const;

  public:
  void clear_large_community() ;
  const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& large_community() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* release_large_community();
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* mutable_large_community();
  void set_allocated_large_community(::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* value);
  void unsafe_arena_set_allocated_large_community(::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* value);
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* unsafe_arena_release_large_community();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& _internal_large_community() const;
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* _internal_mutable_large_community();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecAction)
 private:
  class _Internal;
  void set_has_accept();
  void set_has_discard();
  void set_has_rate_bytes();
  void set_has_mark_dscp();
  void set_has_rt_redirect();
  void set_has_ip_redirect();
  void set_has_action_type();
  void set_has_rt_copy();
  void set_has_regular_community();
  void set_has_extended_community();
  void set_has_large_community();
  inline bool has_action() const;
  inline void clear_has_action();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 11, 11,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecAction& from_msg);
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::kentik::ktbgp::v202501::FlowspecActionAccept* accept_;
      ::kentik::ktbgp::v202501::FlowspecActionDiscard* discard_;
      ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* rate_bytes_;
      ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* mark_dscp_;
      ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* rt_redirect_;
      ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* ip_redirect_;
      ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* action_type_;
      ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* rt_copy_;
      ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* regular_community_;
      ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* extended_community_;
      ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* large_community_;
    } action_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TCPFlagsFormula final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.TCPFlagsFormula) */ {
 public:
  inline TCPFlagsFormula() : TCPFlagsFormula(nullptr) {}
  ~TCPFlagsFormula() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TCPFlagsFormula* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TCPFlagsFormula));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TCPFlagsFormula(
      ::google::protobuf::internal::ConstantInitialized);

  inline TCPFlagsFormula(const TCPFlagsFormula& from) : TCPFlagsFormula(nullptr, from) {}
  inline TCPFlagsFormula(TCPFlagsFormula&& from) noexcept
      : TCPFlagsFormula(nullptr, std::move(from)) {}
  inline TCPFlagsFormula& operator=(const TCPFlagsFormula& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCPFlagsFormula& operator=(TCPFlagsFormula&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCPFlagsFormula& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCPFlagsFormula* internal_default_instance() {
    return reinterpret_cast<const TCPFlagsFormula*>(
        &_TCPFlagsFormula_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(TCPFlagsFormula& a, TCPFlagsFormula& b) { a.Swap(&b); }
  inline void Swap(TCPFlagsFormula* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCPFlagsFormula* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCPFlagsFormula* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TCPFlagsFormula>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TCPFlagsFormula& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TCPFlagsFormula& from) { TCPFlagsFormula::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TCPFlagsFormula* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.TCPFlagsFormula"; }

 protected:
  explicit TCPFlagsFormula(::google::protobuf::Arena* arena);
  TCPFlagsFormula(::google::protobuf::Arena* arena, const TCPFlagsFormula& from);
  TCPFlagsFormula(::google::protobuf::Arena* arena, TCPFlagsFormula&& from) noexcept
      : TCPFlagsFormula(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.TCPFlagsPredicateGroup or = 1 [json_name = "or"];
  int or__size() const;
  private:
  int _internal_or__size() const;

  public:
  void clear_or_() ;
  ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup* mutable_or_(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>* mutable_or_();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>& _internal_or_() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>* _internal_mutable_or_();
  public:
  const ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup& or_(int index) const;
  ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup* add_or_();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>& or_() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.TCPFlagsFormula)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TCPFlagsFormula& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup > or__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RTBHUpdates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RTBHUpdates) */ {
 public:
  inline RTBHUpdates() : RTBHUpdates(nullptr) {}
  ~RTBHUpdates() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RTBHUpdates* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RTBHUpdates));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RTBHUpdates(
      ::google::protobuf::internal::ConstantInitialized);

  inline RTBHUpdates(const RTBHUpdates& from) : RTBHUpdates(nullptr, from) {}
  inline RTBHUpdates(RTBHUpdates&& from) noexcept
      : RTBHUpdates(nullptr, std::move(from)) {}
  inline RTBHUpdates& operator=(const RTBHUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTBHUpdates& operator=(RTBHUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTBHUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTBHUpdates* internal_default_instance() {
    return reinterpret_cast<const RTBHUpdates*>(
        &_RTBHUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RTBHUpdates& a, RTBHUpdates& b) { a.Swap(&b); }
  inline void Swap(RTBHUpdates* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTBHUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTBHUpdates* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RTBHUpdates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RTBHUpdates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RTBHUpdates& from) { RTBHUpdates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RTBHUpdates* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RTBHUpdates"; }

 protected:
  explicit RTBHUpdates(::google::protobuf::Arena* arena);
  RTBHUpdates(::google::protobuf::Arena* arena, const RTBHUpdates& from);
  RTBHUpdates(::google::protobuf::Arena* arena, RTBHUpdates&& from) noexcept
      : RTBHUpdates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdateFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.RTBHUpdate update = 1 [json_name = "update"];
  int update_size() const;
  private:
  int _internal_update_size() const;

  public:
  void clear_update() ;
  ::kentik::ktbgp::v202501::RTBHUpdate* mutable_update(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>* mutable_update();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>& _internal_update() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>* _internal_mutable_update();
  public:
  const ::kentik::ktbgp::v202501::RTBHUpdate& update(int index) const;
  ::kentik::ktbgp::v202501::RTBHUpdate* add_update();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>& update() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RTBHUpdates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RTBHUpdates& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::RTBHUpdate > update_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class NumericFormula final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.NumericFormula) */ {
 public:
  inline NumericFormula() : NumericFormula(nullptr) {}
  ~NumericFormula() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NumericFormula* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NumericFormula));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NumericFormula(
      ::google::protobuf::internal::ConstantInitialized);

  inline NumericFormula(const NumericFormula& from) : NumericFormula(nullptr, from) {}
  inline NumericFormula(NumericFormula&& from) noexcept
      : NumericFormula(nullptr, std::move(from)) {}
  inline NumericFormula& operator=(const NumericFormula& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericFormula& operator=(NumericFormula&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumericFormula& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumericFormula* internal_default_instance() {
    return reinterpret_cast<const NumericFormula*>(
        &_NumericFormula_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(NumericFormula& a, NumericFormula& b) { a.Swap(&b); }
  inline void Swap(NumericFormula* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericFormula* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumericFormula* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NumericFormula>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumericFormula& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NumericFormula& from) { NumericFormula::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NumericFormula* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.NumericFormula"; }

 protected:
  explicit NumericFormula(::google::protobuf::Arena* arena);
  NumericFormula(::google::protobuf::Arena* arena, const NumericFormula& from);
  NumericFormula(::google::protobuf::Arena* arena, NumericFormula&& from) noexcept
      : NumericFormula(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.NumericPredicateGroup or = 1 [json_name = "or"];
  int or__size() const;
  private:
  int _internal_or__size() const;

  public:
  void clear_or_() ;
  ::kentik::ktbgp::v202501::NumericPredicateGroup* mutable_or_(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>* mutable_or_();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>& _internal_or_() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>* _internal_mutable_or_();
  public:
  const ::kentik::ktbgp::v202501::NumericPredicateGroup& or_(int index) const;
  ::kentik::ktbgp::v202501::NumericPredicateGroup* add_or_();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>& or_() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.NumericFormula)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NumericFormula& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::NumericPredicateGroup > or__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FragmentFormula final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FragmentFormula) */ {
 public:
  inline FragmentFormula() : FragmentFormula(nullptr) {}
  ~FragmentFormula() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FragmentFormula* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FragmentFormula));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FragmentFormula(
      ::google::protobuf::internal::ConstantInitialized);

  inline FragmentFormula(const FragmentFormula& from) : FragmentFormula(nullptr, from) {}
  inline FragmentFormula(FragmentFormula&& from) noexcept
      : FragmentFormula(nullptr, std::move(from)) {}
  inline FragmentFormula& operator=(const FragmentFormula& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentFormula& operator=(FragmentFormula&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentFormula& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentFormula* internal_default_instance() {
    return reinterpret_cast<const FragmentFormula*>(
        &_FragmentFormula_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(FragmentFormula& a, FragmentFormula& b) { a.Swap(&b); }
  inline void Swap(FragmentFormula* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentFormula* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentFormula* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FragmentFormula>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FragmentFormula& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FragmentFormula& from) { FragmentFormula::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FragmentFormula* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FragmentFormula"; }

 protected:
  explicit FragmentFormula(::google::protobuf::Arena* arena);
  FragmentFormula(::google::protobuf::Arena* arena, const FragmentFormula& from);
  FragmentFormula(::google::protobuf::Arena* arena, FragmentFormula&& from) noexcept
      : FragmentFormula(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.FragmentPredicateGroup or = 1 [json_name = "or"];
  int or__size() const;
  private:
  int _internal_or__size() const;

  public:
  void clear_or_() ;
  ::kentik::ktbgp::v202501::FragmentPredicateGroup* mutable_or_(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>* mutable_or_();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>& _internal_or_() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>* _internal_mutable_or_();
  public:
  const ::kentik::ktbgp::v202501::FragmentPredicateGroup& or_(int index) const;
  ::kentik::ktbgp::v202501::FragmentPredicateGroup* add_or_();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>& or_() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FragmentFormula)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FragmentFormula& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::FragmentPredicateGroup > or__;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecMatch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecMatch) */ {
 public:
  inline FlowspecMatch() : FlowspecMatch(nullptr) {}
  ~FlowspecMatch() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecMatch* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecMatch));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecMatch(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecMatch(const FlowspecMatch& from) : FlowspecMatch(nullptr, from) {}
  inline FlowspecMatch(FlowspecMatch&& from) noexcept
      : FlowspecMatch(nullptr, std::move(from)) {}
  inline FlowspecMatch& operator=(const FlowspecMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecMatch& operator=(FlowspecMatch&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecMatch* internal_default_instance() {
    return reinterpret_cast<const FlowspecMatch*>(
        &_FlowspecMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(FlowspecMatch& a, FlowspecMatch& b) { a.Swap(&b); }
  inline void Swap(FlowspecMatch* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecMatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecMatch* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecMatch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecMatch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecMatch& from) { FlowspecMatch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecMatch* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecMatch"; }

 protected:
  explicit FlowspecMatch(::google::protobuf::Arena* arena);
  FlowspecMatch(::google::protobuf::Arena* arena, const FlowspecMatch& from);
  FlowspecMatch(::google::protobuf::Arena* arena, FlowspecMatch&& from) noexcept
      : FlowspecMatch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDstPrefixFieldNumber = 1,
    kSrcPrefixFieldNumber = 2,
    kIpProtocolFieldNumber = 3,
    kDstPortFieldNumber = 5,
    kSrcPortFieldNumber = 6,
    kIcmpTypeFieldNumber = 7,
    kIcmpCodeFieldNumber = 8,
    kTcpFlagsFieldNumber = 9,
    kPacketLengthFieldNumber = 10,
    kDscpFieldNumber = 11,
    kFragmentsFieldNumber = 12,
  };
  // string dst_prefix = 1 [json_name = "dstPrefix"];
  void clear_dst_prefix() ;
  const std::string& dst_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_dst_prefix();
  PROTOBUF_NODISCARD std::string* release_dst_prefix();
  void set_allocated_dst_prefix(std::string* value);

  private:
  const std::string& _internal_dst_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_prefix(
      const std::string& value);
  std::string* _internal_mutable_dst_prefix();

  public:
  // string src_prefix = 2 [json_name = "srcPrefix"];
  void clear_src_prefix() ;
  const std::string& src_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_src_prefix();
  PROTOBUF_NODISCARD std::string* release_src_prefix();
  void set_allocated_src_prefix(std::string* value);

  private:
  const std::string& _internal_src_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_prefix(
      const std::string& value);
  std::string* _internal_mutable_src_prefix();

  public:
  // .kentik.ktbgp.v202501.NumericFormula ip_protocol = 3 [json_name = "ipProtocol"];
  bool has_ip_protocol() const;
  void clear_ip_protocol() ;
  const ::kentik::ktbgp::v202501::NumericFormula& ip_protocol() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_ip_protocol();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_ip_protocol();
  void set_allocated_ip_protocol(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_ip_protocol(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_ip_protocol();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_ip_protocol() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_ip_protocol();

  public:
  // .kentik.ktbgp.v202501.NumericFormula dst_port = 5 [json_name = "dstPort"];
  bool has_dst_port() const;
  void clear_dst_port() ;
  const ::kentik::ktbgp::v202501::NumericFormula& dst_port() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_dst_port();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_dst_port();
  void set_allocated_dst_port(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_dst_port(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_dst_port();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_dst_port() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_dst_port();

  public:
  // .kentik.ktbgp.v202501.NumericFormula src_port = 6 [json_name = "srcPort"];
  bool has_src_port() const;
  void clear_src_port() ;
  const ::kentik::ktbgp::v202501::NumericFormula& src_port() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_src_port();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_src_port();
  void set_allocated_src_port(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_src_port(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_src_port();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_src_port() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_src_port();

  public:
  // .kentik.ktbgp.v202501.NumericFormula icmp_type = 7 [json_name = "icmpType"];
  bool has_icmp_type() const;
  void clear_icmp_type() ;
  const ::kentik::ktbgp::v202501::NumericFormula& icmp_type() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_icmp_type();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_icmp_type();
  void set_allocated_icmp_type(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_icmp_type(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_icmp_type();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_icmp_type() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_icmp_type();

  public:
  // .kentik.ktbgp.v202501.NumericFormula icmp_code = 8 [json_name = "icmpCode"];
  bool has_icmp_code() const;
  void clear_icmp_code() ;
  const ::kentik::ktbgp::v202501::NumericFormula& icmp_code() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_icmp_code();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_icmp_code();
  void set_allocated_icmp_code(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_icmp_code(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_icmp_code();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_icmp_code() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_icmp_code();

  public:
  // .kentik.ktbgp.v202501.TCPFlagsFormula tcp_flags = 9 [json_name = "tcpFlags"];
  bool has_tcp_flags() const;
  void clear_tcp_flags() ;
  const ::kentik::ktbgp::v202501::TCPFlagsFormula& tcp_flags() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::TCPFlagsFormula* release_tcp_flags();
  ::kentik::ktbgp::v202501::TCPFlagsFormula* mutable_tcp_flags();
  void set_allocated_tcp_flags(::kentik::ktbgp::v202501::TCPFlagsFormula* value);
  void unsafe_arena_set_allocated_tcp_flags(::kentik::ktbgp::v202501::TCPFlagsFormula* value);
  ::kentik::ktbgp::v202501::TCPFlagsFormula* unsafe_arena_release_tcp_flags();

  private:
  const ::kentik::ktbgp::v202501::TCPFlagsFormula& _internal_tcp_flags() const;
  ::kentik::ktbgp::v202501::TCPFlagsFormula* _internal_mutable_tcp_flags();

  public:
  // .kentik.ktbgp.v202501.NumericFormula packet_length = 10 [json_name = "packetLength"];
  bool has_packet_length() const;
  void clear_packet_length() ;
  const ::kentik::ktbgp::v202501::NumericFormula& packet_length() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_packet_length();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_packet_length();
  void set_allocated_packet_length(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_packet_length(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_packet_length();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_packet_length() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_packet_length();

  public:
  // .kentik.ktbgp.v202501.NumericFormula dscp = 11 [json_name = "dscp"];
  bool has_dscp() const;
  void clear_dscp() ;
  const ::kentik::ktbgp::v202501::NumericFormula& dscp() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::NumericFormula* release_dscp();
  ::kentik::ktbgp::v202501::NumericFormula* mutable_dscp();
  void set_allocated_dscp(::kentik::ktbgp::v202501::NumericFormula* value);
  void unsafe_arena_set_allocated_dscp(::kentik::ktbgp::v202501::NumericFormula* value);
  ::kentik::ktbgp::v202501::NumericFormula* unsafe_arena_release_dscp();

  private:
  const ::kentik::ktbgp::v202501::NumericFormula& _internal_dscp() const;
  ::kentik::ktbgp::v202501::NumericFormula* _internal_mutable_dscp();

  public:
  // .kentik.ktbgp.v202501.FragmentFormula fragments = 12 [json_name = "fragments"];
  bool has_fragments() const;
  void clear_fragments() ;
  const ::kentik::ktbgp::v202501::FragmentFormula& fragments() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FragmentFormula* release_fragments();
  ::kentik::ktbgp::v202501::FragmentFormula* mutable_fragments();
  void set_allocated_fragments(::kentik::ktbgp::v202501::FragmentFormula* value);
  void unsafe_arena_set_allocated_fragments(::kentik::ktbgp::v202501::FragmentFormula* value);
  ::kentik::ktbgp::v202501::FragmentFormula* unsafe_arena_release_fragments();

  private:
  const ::kentik::ktbgp::v202501::FragmentFormula& _internal_fragments() const;
  ::kentik::ktbgp::v202501::FragmentFormula* _internal_mutable_fragments();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecMatch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 9,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecMatch& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dst_prefix_;
    ::google::protobuf::internal::ArenaStringPtr src_prefix_;
    ::kentik::ktbgp::v202501::NumericFormula* ip_protocol_;
    ::kentik::ktbgp::v202501::NumericFormula* dst_port_;
    ::kentik::ktbgp::v202501::NumericFormula* src_port_;
    ::kentik::ktbgp::v202501::NumericFormula* icmp_type_;
    ::kentik::ktbgp::v202501::NumericFormula* icmp_code_;
    ::kentik::ktbgp::v202501::TCPFlagsFormula* tcp_flags_;
    ::kentik::ktbgp::v202501::NumericFormula* packet_length_;
    ::kentik::ktbgp::v202501::NumericFormula* dscp_;
    ::kentik::ktbgp::v202501::FragmentFormula* fragments_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Withdraw final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.Withdraw) */ {
 public:
  inline Withdraw() : Withdraw(nullptr) {}
  ~Withdraw() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Withdraw* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Withdraw));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Withdraw(
      ::google::protobuf::internal::ConstantInitialized);

  inline Withdraw(const Withdraw& from) : Withdraw(nullptr, from) {}
  inline Withdraw(Withdraw&& from) noexcept
      : Withdraw(nullptr, std::move(from)) {}
  inline Withdraw& operator=(const Withdraw& from) {
    CopyFrom(from);
    return *this;
  }
  inline Withdraw& operator=(Withdraw&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Withdraw& default_instance() {
    return *internal_default_instance();
  }
  enum WithdrawCase {
    kFlowspec = 1,
    kRtbh = 2,
    WITHDRAW_NOT_SET = 0,
  };
  static inline const Withdraw* internal_default_instance() {
    return reinterpret_cast<const Withdraw*>(
        &_Withdraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Withdraw& a, Withdraw& b) { a.Swap(&b); }
  inline void Swap(Withdraw* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Withdraw* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Withdraw* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Withdraw>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Withdraw& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Withdraw& from) { Withdraw::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Withdraw* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.Withdraw"; }

 protected:
  explicit Withdraw(::google::protobuf::Arena* arena);
  Withdraw(::google::protobuf::Arena* arena, const Withdraw& from);
  Withdraw(::google::protobuf::Arena* arena, Withdraw&& from) noexcept
      : Withdraw(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFlowspecFieldNumber = 1,
    kRtbhFieldNumber = 2,
  };
  // .kentik.ktbgp.v202501.FlowspecMatch flowspec = 1 [json_name = "flowspec"];
  bool has_flowspec() const;
  private:
  bool _internal_has_flowspec() const;

  public:
  void clear_flowspec() ;
  const ::kentik::ktbgp::v202501::FlowspecMatch& flowspec() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecMatch* release_flowspec();
  ::kentik::ktbgp::v202501::FlowspecMatch* mutable_flowspec();
  void set_allocated_flowspec(::kentik::ktbgp::v202501::FlowspecMatch* value);
  void unsafe_arena_set_allocated_flowspec(::kentik::ktbgp::v202501::FlowspecMatch* value);
  ::kentik::ktbgp::v202501::FlowspecMatch* unsafe_arena_release_flowspec();

  private:
  const ::kentik::ktbgp::v202501::FlowspecMatch& _internal_flowspec() const;
  ::kentik::ktbgp::v202501::FlowspecMatch* _internal_mutable_flowspec();

  public:
  // .kentik.ktbgp.v202501.RTBHMatch rtbh = 2 [json_name = "rtbh"];
  bool has_rtbh() const;
  private:
  bool _internal_has_rtbh() const;

  public:
  void clear_rtbh() ;
  const ::kentik::ktbgp::v202501::RTBHMatch& rtbh() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::RTBHMatch* release_rtbh();
  ::kentik::ktbgp::v202501::RTBHMatch* mutable_rtbh();
  void set_allocated_rtbh(::kentik::ktbgp::v202501::RTBHMatch* value);
  void unsafe_arena_set_allocated_rtbh(::kentik::ktbgp::v202501::RTBHMatch* value);
  ::kentik::ktbgp::v202501::RTBHMatch* unsafe_arena_release_rtbh();

  private:
  const ::kentik::ktbgp::v202501::RTBHMatch& _internal_rtbh() const;
  ::kentik::ktbgp::v202501::RTBHMatch* _internal_mutable_rtbh();

  public:
  void clear_withdraw();
  WithdrawCase withdraw_case() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.Withdraw)
 private:
  class _Internal;
  void set_has_flowspec();
  void set_has_rtbh();
  inline bool has_withdraw() const;
  inline void clear_has_withdraw();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Withdraw& from_msg);
    union WithdrawUnion {
      constexpr WithdrawUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::kentik::ktbgp::v202501::FlowspecMatch* flowspec_;
      ::kentik::ktbgp::v202501::RTBHMatch* rtbh_;
    } withdraw_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecUpdate) */ {
 public:
  inline FlowspecUpdate() : FlowspecUpdate(nullptr) {}
  ~FlowspecUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecUpdate(const FlowspecUpdate& from) : FlowspecUpdate(nullptr, from) {}
  inline FlowspecUpdate(FlowspecUpdate&& from) noexcept
      : FlowspecUpdate(nullptr, std::move(from)) {}
  inline FlowspecUpdate& operator=(const FlowspecUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecUpdate& operator=(FlowspecUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kRateBytes = 11,
    kDiscard = 12,
    kMarkDscp = 13,
    kRtRedirect = 14,
    kIpRedirect = 15,
    kAccept = 16,
    kActionType = 17,
    kRtCopy = 18,
    kRegularCommunity = 19,
    kExtendedCommunity = 20,
    kLargeCommunity = 21,
    ACTION_NOT_SET = 0,
  };
  static inline const FlowspecUpdate* internal_default_instance() {
    return reinterpret_cast<const FlowspecUpdate*>(
        &_FlowspecUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(FlowspecUpdate& a, FlowspecUpdate& b) { a.Swap(&b); }
  inline void Swap(FlowspecUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecUpdate& from) { FlowspecUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecUpdate"; }

 protected:
  explicit FlowspecUpdate(::google::protobuf::Arena* arena);
  FlowspecUpdate(::google::protobuf::Arena* arena, const FlowspecUpdate& from);
  FlowspecUpdate(::google::protobuf::Arena* arena, FlowspecUpdate&& from) noexcept
      : FlowspecUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionsFieldNumber = 8,
    kInetFieldNumber = 3,
    kKeyFieldNumber = 7,
    kMatchFieldNumber = 1,
    kCreationTimeFieldNumber = 2,
    kTerminalFieldNumber = 4,
    kSampleFieldNumber = 5,
    kInetTypeFieldNumber = 6,
    kRateBytesFieldNumber = 11,
    kDiscardFieldNumber = 12,
    kMarkDscpFieldNumber = 13,
    kRtRedirectFieldNumber = 14,
    kIpRedirectFieldNumber = 15,
    kAcceptFieldNumber = 16,
    kActionTypeFieldNumber = 17,
    kRtCopyFieldNumber = 18,
    kRegularCommunityFieldNumber = 19,
    kExtendedCommunityFieldNumber = 20,
    kLargeCommunityFieldNumber = 21,
  };
  // repeated .kentik.ktbgp.v202501.FlowspecAction actions = 8 [json_name = "actions"];
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::kentik::ktbgp::v202501::FlowspecAction* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>* mutable_actions();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>* _internal_mutable_actions();
  public:
  const ::kentik::ktbgp::v202501::FlowspecAction& actions(int index) const;
  ::kentik::ktbgp::v202501::FlowspecAction* add_actions();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>& actions() const;
  // string inet = 3 [json_name = "inet", deprecated = true];
  [[deprecated]]  void clear_inet() ;
  [[deprecated]] const std::string& inet() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_inet(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_inet();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_inet();
  [[deprecated]] void set_allocated_inet(std::string* value);

  private:
  const std::string& _internal_inet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inet(
      const std::string& value);
  std::string* _internal_mutable_inet();

  public:
  // string key = 7 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .kentik.ktbgp.v202501.FlowspecMatch match = 1 [json_name = "match"];
  bool has_match() const;
  void clear_match() ;
  const ::kentik::ktbgp::v202501::FlowspecMatch& match() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecMatch* release_match();
  ::kentik::ktbgp::v202501::FlowspecMatch* mutable_match();
  void set_allocated_match(::kentik::ktbgp::v202501::FlowspecMatch* value);
  void unsafe_arena_set_allocated_match(::kentik::ktbgp::v202501::FlowspecMatch* value);
  ::kentik::ktbgp::v202501::FlowspecMatch* unsafe_arena_release_match();

  private:
  const ::kentik::ktbgp::v202501::FlowspecMatch& _internal_match() const;
  ::kentik::ktbgp::v202501::FlowspecMatch* _internal_mutable_match();

  public:
  // .google.protobuf.Timestamp creation_time = 2 [json_name = "creationTime"];
  bool has_creation_time() const;
  void clear_creation_time() ;
  const ::google::protobuf::Timestamp& creation_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_creation_time();
  ::google::protobuf::Timestamp* mutable_creation_time();
  void set_allocated_creation_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_creation_time();

  private:
  const ::google::protobuf::Timestamp& _internal_creation_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_creation_time();

  public:
  // bool terminal = 4 [json_name = "terminal", deprecated = true];
  [[deprecated]]  void clear_terminal() ;
  [[deprecated]] bool terminal() const;
  [[deprecated]] void set_terminal(bool value);

  private:
  bool _internal_terminal() const;
  void _internal_set_terminal(bool value);

  public:
  // bool sample = 5 [json_name = "sample", deprecated = true];
  [[deprecated]]  void clear_sample() ;
  [[deprecated]] bool sample() const;
  [[deprecated]] void set_sample(bool value);

  private:
  bool _internal_sample() const;
  void _internal_set_sample(bool value);

  public:
  // .kentik.ktbgp.v202501.InetType inet_type = 6 [json_name = "inetType"];
  void clear_inet_type() ;
  ::kentik::ktbgp::v202501::InetType inet_type() const;
  void set_inet_type(::kentik::ktbgp::v202501::InetType value);

  private:
  ::kentik::ktbgp::v202501::InetType _internal_inet_type() const;
  void _internal_set_inet_type(::kentik::ktbgp::v202501::InetType value);

  public:
  // .kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes rate_bytes = 11 [json_name = "rateBytes"];
  bool has_rate_bytes() const;
  private:
  bool _internal_has_rate_bytes() const;

  public:
  void clear_rate_bytes() ;
  const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& rate_bytes() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* release_rate_bytes();
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* mutable_rate_bytes();
  void set_allocated_rate_bytes(::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* value);
  void unsafe_arena_set_allocated_rate_bytes(::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* value);
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* unsafe_arena_release_rate_bytes();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& _internal_rate_bytes() const;
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* _internal_mutable_rate_bytes();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionDiscard discard = 12 [json_name = "discard"];
  bool has_discard() const;
  private:
  bool _internal_has_discard() const;

  public:
  void clear_discard() ;
  const ::kentik::ktbgp::v202501::FlowspecActionDiscard& discard() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionDiscard* release_discard();
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* mutable_discard();
  void set_allocated_discard(::kentik::ktbgp::v202501::FlowspecActionDiscard* value);
  void unsafe_arena_set_allocated_discard(::kentik::ktbgp::v202501::FlowspecActionDiscard* value);
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* unsafe_arena_release_discard();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionDiscard& _internal_discard() const;
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* _internal_mutable_discard();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionMarkDSCP mark_dscp = 13 [json_name = "markDscp"];
  bool has_mark_dscp() const;
  private:
  bool _internal_has_mark_dscp() const;

  public:
  void clear_mark_dscp() ;
  const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& mark_dscp() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* release_mark_dscp();
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* mutable_mark_dscp();
  void set_allocated_mark_dscp(::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* value);
  void unsafe_arena_set_allocated_mark_dscp(::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* value);
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* unsafe_arena_release_mark_dscp();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& _internal_mark_dscp() const;
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* _internal_mutable_mark_dscp();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect rt_redirect = 14 [json_name = "rtRedirect"];
  bool has_rt_redirect() const;
  private:
  bool _internal_has_rt_redirect() const;

  public:
  void clear_rt_redirect() ;
  const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& rt_redirect() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* release_rt_redirect();
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* mutable_rt_redirect();
  void set_allocated_rt_redirect(::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* value);
  void unsafe_arena_set_allocated_rt_redirect(::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* value);
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* unsafe_arena_release_rt_redirect();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& _internal_rt_redirect() const;
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* _internal_mutable_rt_redirect();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect ip_redirect = 15 [json_name = "ipRedirect"];
  bool has_ip_redirect() const;
  private:
  bool _internal_has_ip_redirect() const;

  public:
  void clear_ip_redirect() ;
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& ip_redirect() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* release_ip_redirect();
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* mutable_ip_redirect();
  void set_allocated_ip_redirect(::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* value);
  void unsafe_arena_set_allocated_ip_redirect(::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* value);
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* unsafe_arena_release_ip_redirect();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& _internal_ip_redirect() const;
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* _internal_mutable_ip_redirect();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionAccept accept = 16 [json_name = "accept"];
  bool has_accept() const;
  private:
  bool _internal_has_accept() const;

  public:
  void clear_accept() ;
  const ::kentik::ktbgp::v202501::FlowspecActionAccept& accept() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionAccept* release_accept();
  ::kentik::ktbgp::v202501::FlowspecActionAccept* mutable_accept();
  void set_allocated_accept(::kentik::ktbgp::v202501::FlowspecActionAccept* value);
  void unsafe_arena_set_allocated_accept(::kentik::ktbgp::v202501::FlowspecActionAccept* value);
  ::kentik::ktbgp::v202501::FlowspecActionAccept* unsafe_arena_release_accept();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionAccept& _internal_accept() const;
  ::kentik::ktbgp::v202501::FlowspecActionAccept* _internal_mutable_accept();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionTerminalSample action_type = 17 [json_name = "actionType"];
  bool has_action_type() const;
  private:
  bool _internal_has_action_type() const;

  public:
  void clear_action_type() ;
  const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& action_type() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* release_action_type();
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* mutable_action_type();
  void set_allocated_action_type(::kentik::ktbgp::v202501::FlowspecActionTerminalSample* value);
  void unsafe_arena_set_allocated_action_type(::kentik::ktbgp::v202501::FlowspecActionTerminalSample* value);
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* unsafe_arena_release_action_type();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& _internal_action_type() const;
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* _internal_mutable_action_type();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy rt_copy = 18 [json_name = "rtCopy"];
  bool has_rt_copy() const;
  private:
  bool _internal_has_rt_copy() const;

  public:
  void clear_rt_copy() ;
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& rt_copy() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* release_rt_copy();
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* mutable_rt_copy();
  void set_allocated_rt_copy(::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* value);
  void unsafe_arena_set_allocated_rt_copy(::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* value);
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* unsafe_arena_release_rt_copy();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& _internal_rt_copy() const;
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* _internal_mutable_rt_copy();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionRegularCommunity regular_community = 19 [json_name = "regularCommunity"];
  bool has_regular_community() const;
  private:
  bool _internal_has_regular_community() const;

  public:
  void clear_regular_community() ;
  const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& regular_community() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* release_regular_community();
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* mutable_regular_community();
  void set_allocated_regular_community(::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* value);
  void unsafe_arena_set_allocated_regular_community(::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* value);
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* unsafe_arena_release_regular_community();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& _internal_regular_community() const;
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* _internal_mutable_regular_community();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionExtendedCommunity extended_community = 20 [json_name = "extendedCommunity"];
  bool has_extended_community() const;
  private:
  bool _internal_has_extended_community() const;

  public:
  void clear_extended_community() ;
  const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& extended_community() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* release_extended_community();
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* mutable_extended_community();
  void set_allocated_extended_community(::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* value);
  void unsafe_arena_set_allocated_extended_community(::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* value);
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* unsafe_arena_release_extended_community();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& _internal_extended_community() const;
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* _internal_mutable_extended_community();

  public:
  // .kentik.ktbgp.v202501.FlowspecActionLargeCommunity large_community = 21 [json_name = "largeCommunity"];
  bool has_large_community() const;
  private:
  bool _internal_has_large_community() const;

  public:
  void clear_large_community() ;
  const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& large_community() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* release_large_community();
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* mutable_large_community();
  void set_allocated_large_community(::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* value);
  void unsafe_arena_set_allocated_large_community(::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* value);
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* unsafe_arena_release_large_community();

  private:
  const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& _internal_large_community() const;
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* _internal_mutable_large_community();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecUpdate)
 private:
  class _Internal;
  void set_has_rate_bytes();
  void set_has_discard();
  void set_has_mark_dscp();
  void set_has_rt_redirect();
  void set_has_ip_redirect();
  void set_has_accept();
  void set_has_action_type();
  void set_has_rt_copy();
  void set_has_regular_community();
  void set_has_extended_community();
  void set_has_large_community();
  inline bool has_action() const;
  inline void clear_has_action();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 19, 14,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::FlowspecAction > actions_;
    ::google::protobuf::internal::ArenaStringPtr inet_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::kentik::ktbgp::v202501::FlowspecMatch* match_;
    ::google::protobuf::Timestamp* creation_time_;
    bool terminal_;
    bool sample_;
    int inet_type_;
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* rate_bytes_;
      ::kentik::ktbgp::v202501::FlowspecActionDiscard* discard_;
      ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* mark_dscp_;
      ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* rt_redirect_;
      ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* ip_redirect_;
      ::kentik::ktbgp::v202501::FlowspecActionAccept* accept_;
      ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* action_type_;
      ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* rt_copy_;
      ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* regular_community_;
      ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* extended_community_;
      ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* large_community_;
    } action_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceWithdrawRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RouteServiceWithdrawRequest) */ {
 public:
  inline RouteServiceWithdrawRequest() : RouteServiceWithdrawRequest(nullptr) {}
  ~RouteServiceWithdrawRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteServiceWithdrawRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteServiceWithdrawRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteServiceWithdrawRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteServiceWithdrawRequest(const RouteServiceWithdrawRequest& from) : RouteServiceWithdrawRequest(nullptr, from) {}
  inline RouteServiceWithdrawRequest(RouteServiceWithdrawRequest&& from) noexcept
      : RouteServiceWithdrawRequest(nullptr, std::move(from)) {}
  inline RouteServiceWithdrawRequest& operator=(const RouteServiceWithdrawRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceWithdrawRequest& operator=(RouteServiceWithdrawRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteServiceWithdrawRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteServiceWithdrawRequest* internal_default_instance() {
    return reinterpret_cast<const RouteServiceWithdrawRequest*>(
        &_RouteServiceWithdrawRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RouteServiceWithdrawRequest& a, RouteServiceWithdrawRequest& b) { a.Swap(&b); }
  inline void Swap(RouteServiceWithdrawRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteServiceWithdrawRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteServiceWithdrawRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteServiceWithdrawRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteServiceWithdrawRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteServiceWithdrawRequest& from) { RouteServiceWithdrawRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteServiceWithdrawRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RouteServiceWithdrawRequest"; }

 protected:
  explicit RouteServiceWithdrawRequest(::google::protobuf::Arena* arena);
  RouteServiceWithdrawRequest(::google::protobuf::Arena* arena, const RouteServiceWithdrawRequest& from);
  RouteServiceWithdrawRequest(::google::protobuf::Arena* arena, RouteServiceWithdrawRequest&& from) noexcept
      : RouteServiceWithdrawRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceIdsFieldNumber = 1,
    kWithdrawFieldNumber = 2,
  };
  // repeated uint64 device_ids = 1 [json_name = "deviceIds"];
  int device_ids_size() const;
  private:
  int _internal_device_ids_size() const;

  public:
  void clear_device_ids() ;
  ::uint64_t device_ids(int index) const;
  void set_device_ids(int index, ::uint64_t value);
  void add_device_ids(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& device_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_device_ids();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_device_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_device_ids();

  public:
  // .kentik.ktbgp.v202501.Withdraw withdraw = 2 [json_name = "withdraw"];
  bool has_withdraw() const;
  void clear_withdraw() ;
  const ::kentik::ktbgp::v202501::Withdraw& withdraw() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::Withdraw* release_withdraw();
  ::kentik::ktbgp::v202501::Withdraw* mutable_withdraw();
  void set_allocated_withdraw(::kentik::ktbgp::v202501::Withdraw* value);
  void unsafe_arena_set_allocated_withdraw(::kentik::ktbgp::v202501::Withdraw* value);
  ::kentik::ktbgp::v202501::Withdraw* unsafe_arena_release_withdraw();

  private:
  const ::kentik::ktbgp::v202501::Withdraw& _internal_withdraw() const;
  ::kentik::ktbgp::v202501::Withdraw* _internal_mutable_withdraw();

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RouteServiceWithdrawRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteServiceWithdrawRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> device_ids_;
    ::google::protobuf::internal::CachedSize _device_ids_cached_byte_size_;
    ::kentik::ktbgp::v202501::Withdraw* withdraw_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceAnnounceRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RouteServiceAnnounceRequest) */ {
 public:
  inline RouteServiceAnnounceRequest() : RouteServiceAnnounceRequest(nullptr) {}
  ~RouteServiceAnnounceRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteServiceAnnounceRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteServiceAnnounceRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteServiceAnnounceRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteServiceAnnounceRequest(const RouteServiceAnnounceRequest& from) : RouteServiceAnnounceRequest(nullptr, from) {}
  inline RouteServiceAnnounceRequest(RouteServiceAnnounceRequest&& from) noexcept
      : RouteServiceAnnounceRequest(nullptr, std::move(from)) {}
  inline RouteServiceAnnounceRequest& operator=(const RouteServiceAnnounceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceAnnounceRequest& operator=(RouteServiceAnnounceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteServiceAnnounceRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UpdateCase {
    kFlowspec = 11,
    kRtbh = 12,
    UPDATE_NOT_SET = 0,
  };
  static inline const RouteServiceAnnounceRequest* internal_default_instance() {
    return reinterpret_cast<const RouteServiceAnnounceRequest*>(
        &_RouteServiceAnnounceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RouteServiceAnnounceRequest& a, RouteServiceAnnounceRequest& b) { a.Swap(&b); }
  inline void Swap(RouteServiceAnnounceRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteServiceAnnounceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteServiceAnnounceRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteServiceAnnounceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteServiceAnnounceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteServiceAnnounceRequest& from) { RouteServiceAnnounceRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteServiceAnnounceRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RouteServiceAnnounceRequest"; }

 protected:
  explicit RouteServiceAnnounceRequest(::google::protobuf::Arena* arena);
  RouteServiceAnnounceRequest(::google::protobuf::Arena* arena, const RouteServiceAnnounceRequest& from);
  RouteServiceAnnounceRequest(::google::protobuf::Arena* arena, RouteServiceAnnounceRequest&& from) noexcept
      : RouteServiceAnnounceRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceIdsFieldNumber = 1,
    kFlowspecFieldNumber = 11,
    kRtbhFieldNumber = 12,
  };
  // repeated uint64 device_ids = 1 [json_name = "deviceIds"];
  int device_ids_size() const;
  private:
  int _internal_device_ids_size() const;

  public:
  void clear_device_ids() ;
  ::uint64_t device_ids(int index) const;
  void set_device_ids(int index, ::uint64_t value);
  void add_device_ids(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& device_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_device_ids();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_device_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_device_ids();

  public:
  // .kentik.ktbgp.v202501.FlowspecUpdate flowspec = 11 [json_name = "flowspec"];
  bool has_flowspec() const;
  private:
  bool _internal_has_flowspec() const;

  public:
  void clear_flowspec() ;
  const ::kentik::ktbgp::v202501::FlowspecUpdate& flowspec() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::FlowspecUpdate* release_flowspec();
  ::kentik::ktbgp::v202501::FlowspecUpdate* mutable_flowspec();
  void set_allocated_flowspec(::kentik::ktbgp::v202501::FlowspecUpdate* value);
  void unsafe_arena_set_allocated_flowspec(::kentik::ktbgp::v202501::FlowspecUpdate* value);
  ::kentik::ktbgp::v202501::FlowspecUpdate* unsafe_arena_release_flowspec();

  private:
  const ::kentik::ktbgp::v202501::FlowspecUpdate& _internal_flowspec() const;
  ::kentik::ktbgp::v202501::FlowspecUpdate* _internal_mutable_flowspec();

  public:
  // .kentik.ktbgp.v202501.RTBHUpdate rtbh = 12 [json_name = "rtbh"];
  bool has_rtbh() const;
  private:
  bool _internal_has_rtbh() const;

  public:
  void clear_rtbh() ;
  const ::kentik::ktbgp::v202501::RTBHUpdate& rtbh() const;
  PROTOBUF_NODISCARD ::kentik::ktbgp::v202501::RTBHUpdate* release_rtbh();
  ::kentik::ktbgp::v202501::RTBHUpdate* mutable_rtbh();
  void set_allocated_rtbh(::kentik::ktbgp::v202501::RTBHUpdate* value);
  void unsafe_arena_set_allocated_rtbh(::kentik::ktbgp::v202501::RTBHUpdate* value);
  ::kentik::ktbgp::v202501::RTBHUpdate* unsafe_arena_release_rtbh();

  private:
  const ::kentik::ktbgp::v202501::RTBHUpdate& _internal_rtbh() const;
  ::kentik::ktbgp::v202501::RTBHUpdate* _internal_mutable_rtbh();

  public:
  void clear_update();
  UpdateCase update_case() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RouteServiceAnnounceRequest)
 private:
  class _Internal;
  void set_has_flowspec();
  void set_has_rtbh();
  inline bool has_update() const;
  inline void clear_has_update();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteServiceAnnounceRequest& from_msg);
    ::google::protobuf::RepeatedField<::uint64_t> device_ids_;
    ::google::protobuf::internal::CachedSize _device_ids_cached_byte_size_;
    union UpdateUnion {
      constexpr UpdateUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::kentik::ktbgp::v202501::FlowspecUpdate* flowspec_;
      ::kentik::ktbgp::v202501::RTBHUpdate* rtbh_;
    } update_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FlowspecUpdates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.FlowspecUpdates) */ {
 public:
  inline FlowspecUpdates() : FlowspecUpdates(nullptr) {}
  ~FlowspecUpdates() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlowspecUpdates* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlowspecUpdates));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlowspecUpdates(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlowspecUpdates(const FlowspecUpdates& from) : FlowspecUpdates(nullptr, from) {}
  inline FlowspecUpdates(FlowspecUpdates&& from) noexcept
      : FlowspecUpdates(nullptr, std::move(from)) {}
  inline FlowspecUpdates& operator=(const FlowspecUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowspecUpdates& operator=(FlowspecUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowspecUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowspecUpdates* internal_default_instance() {
    return reinterpret_cast<const FlowspecUpdates*>(
        &_FlowspecUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(FlowspecUpdates& a, FlowspecUpdates& b) { a.Swap(&b); }
  inline void Swap(FlowspecUpdates* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowspecUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowspecUpdates* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlowspecUpdates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlowspecUpdates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlowspecUpdates& from) { FlowspecUpdates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlowspecUpdates* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.FlowspecUpdates"; }

 protected:
  explicit FlowspecUpdates(::google::protobuf::Arena* arena);
  FlowspecUpdates(::google::protobuf::Arena* arena, const FlowspecUpdates& from);
  FlowspecUpdates(::google::protobuf::Arena* arena, FlowspecUpdates&& from) noexcept
      : FlowspecUpdates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdateFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.FlowspecUpdate update = 1 [json_name = "update"];
  int update_size() const;
  private:
  int _internal_update_size() const;

  public:
  void clear_update() ;
  ::kentik::ktbgp::v202501::FlowspecUpdate* mutable_update(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>* mutable_update();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>& _internal_update() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>* _internal_mutable_update();
  public:
  const ::kentik::ktbgp::v202501::FlowspecUpdate& update(int index) const;
  ::kentik::ktbgp::v202501::FlowspecUpdate* add_update();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>& update() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.FlowspecUpdates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlowspecUpdates& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::FlowspecUpdate > update_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeviceAdverts final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.DeviceAdverts) */ {
 public:
  inline DeviceAdverts() : DeviceAdverts(nullptr) {}
  ~DeviceAdverts() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeviceAdverts* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeviceAdverts));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceAdverts(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceAdverts(const DeviceAdverts& from) : DeviceAdverts(nullptr, from) {}
  inline DeviceAdverts(DeviceAdverts&& from) noexcept
      : DeviceAdverts(nullptr, std::move(from)) {}
  inline DeviceAdverts& operator=(const DeviceAdverts& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAdverts& operator=(DeviceAdverts&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceAdverts& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAdverts* internal_default_instance() {
    return reinterpret_cast<const DeviceAdverts*>(
        &_DeviceAdverts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(DeviceAdverts& a, DeviceAdverts& b) { a.Swap(&b); }
  inline void Swap(DeviceAdverts* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAdverts* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAdverts* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeviceAdverts>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceAdverts& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceAdverts& from) { DeviceAdverts::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeviceAdverts* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.DeviceAdverts"; }

 protected:
  explicit DeviceAdverts(::google::protobuf::Arena* arena);
  DeviceAdverts(::google::protobuf::Arena* arena, const DeviceAdverts& from);
  DeviceAdverts(::google::protobuf::Arena* arena, DeviceAdverts&& from) noexcept
      : DeviceAdverts(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFlowspecFieldNumber = 2,
    kRtbhFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.FlowspecUpdate flowspec = 2 [json_name = "flowspec"];
  int flowspec_size() const;
  private:
  int _internal_flowspec_size() const;

  public:
  void clear_flowspec() ;
  ::kentik::ktbgp::v202501::FlowspecUpdate* mutable_flowspec(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>* mutable_flowspec();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>& _internal_flowspec() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>* _internal_mutable_flowspec();
  public:
  const ::kentik::ktbgp::v202501::FlowspecUpdate& flowspec(int index) const;
  ::kentik::ktbgp::v202501::FlowspecUpdate* add_flowspec();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>& flowspec() const;
  // repeated .kentik.ktbgp.v202501.RTBHUpdate rtbh = 3 [json_name = "rtbh"];
  int rtbh_size() const;
  private:
  int _internal_rtbh_size() const;

  public:
  void clear_rtbh() ;
  ::kentik::ktbgp::v202501::RTBHUpdate* mutable_rtbh(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>* mutable_rtbh();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>& _internal_rtbh() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>* _internal_mutable_rtbh();
  public:
  const ::kentik::ktbgp::v202501::RTBHUpdate& rtbh(int index) const;
  ::kentik::ktbgp::v202501::RTBHUpdate* add_rtbh();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>& rtbh() const;
  // uint64 device_id = 1 [json_name = "deviceId"];
  void clear_device_id() ;
  ::uint64_t device_id() const;
  void set_device_id(::uint64_t value);

  private:
  ::uint64_t _internal_device_id() const;
  void _internal_set_device_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.DeviceAdverts)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceAdverts& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::FlowspecUpdate > flowspec_;
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::RTBHUpdate > rtbh_;
    ::uint64_t device_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceListResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kentik.ktbgp.v202501.RouteServiceListResponse) */ {
 public:
  inline RouteServiceListResponse() : RouteServiceListResponse(nullptr) {}
  ~RouteServiceListResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteServiceListResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteServiceListResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteServiceListResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteServiceListResponse(const RouteServiceListResponse& from) : RouteServiceListResponse(nullptr, from) {}
  inline RouteServiceListResponse(RouteServiceListResponse&& from) noexcept
      : RouteServiceListResponse(nullptr, std::move(from)) {}
  inline RouteServiceListResponse& operator=(const RouteServiceListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceListResponse& operator=(RouteServiceListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteServiceListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteServiceListResponse* internal_default_instance() {
    return reinterpret_cast<const RouteServiceListResponse*>(
        &_RouteServiceListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(RouteServiceListResponse& a, RouteServiceListResponse& b) { a.Swap(&b); }
  inline void Swap(RouteServiceListResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteServiceListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteServiceListResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteServiceListResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteServiceListResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteServiceListResponse& from) { RouteServiceListResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteServiceListResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "kentik.ktbgp.v202501.RouteServiceListResponse"; }

 protected:
  explicit RouteServiceListResponse(::google::protobuf::Arena* arena);
  RouteServiceListResponse(::google::protobuf::Arena* arena, const RouteServiceListResponse& from);
  RouteServiceListResponse(::google::protobuf::Arena* arena, RouteServiceListResponse&& from) noexcept
      : RouteServiceListResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // repeated .kentik.ktbgp.v202501.DeviceAdverts result = 1 [json_name = "result"];
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  ::kentik::ktbgp::v202501::DeviceAdverts* mutable_result(int index);
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>* mutable_result();

  private:
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>& _internal_result() const;
  ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>* _internal_mutable_result();
  public:
  const ::kentik::ktbgp::v202501::DeviceAdverts& result(int index) const;
  ::kentik::ktbgp::v202501::DeviceAdverts* add_result();
  const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>& result() const;
  // @@protoc_insertion_point(class_scope:kentik.ktbgp.v202501.RouteServiceListResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteServiceListResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::kentik::ktbgp::v202501::DeviceAdverts > result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RouteServiceAnnounceRequest

// repeated uint64 device_ids = 1 [json_name = "deviceIds"];
inline int RouteServiceAnnounceRequest::_internal_device_ids_size() const {
  return _internal_device_ids().size();
}
inline int RouteServiceAnnounceRequest::device_ids_size() const {
  return _internal_device_ids_size();
}
inline void RouteServiceAnnounceRequest::clear_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_ids_.Clear();
}
inline ::uint64_t RouteServiceAnnounceRequest::device_ids(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.device_ids)
  return _internal_device_ids().Get(index);
}
inline void RouteServiceAnnounceRequest::set_device_ids(int index, ::uint64_t value) {
  _internal_mutable_device_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.device_ids)
}
inline void RouteServiceAnnounceRequest::add_device_ids(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_device_ids()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.device_ids)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& RouteServiceAnnounceRequest::device_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.device_ids)
  return _internal_device_ids();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* RouteServiceAnnounceRequest::mutable_device_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.device_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_ids();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
RouteServiceAnnounceRequest::_internal_device_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_ids_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* RouteServiceAnnounceRequest::_internal_mutable_device_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_ids_;
}

// .kentik.ktbgp.v202501.FlowspecUpdate flowspec = 11 [json_name = "flowspec"];
inline bool RouteServiceAnnounceRequest::has_flowspec() const {
  return update_case() == kFlowspec;
}
inline bool RouteServiceAnnounceRequest::_internal_has_flowspec() const {
  return update_case() == kFlowspec;
}
inline void RouteServiceAnnounceRequest::set_has_flowspec() {
  _impl_._oneof_case_[0] = kFlowspec;
}
inline void RouteServiceAnnounceRequest::clear_flowspec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kFlowspec) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.flowspec_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.flowspec_);
    }
    clear_has_update();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* RouteServiceAnnounceRequest::release_flowspec() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.flowspec)
  if (update_case() == kFlowspec) {
    clear_has_update();
    auto* temp = _impl_.update_.flowspec_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.flowspec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecUpdate& RouteServiceAnnounceRequest::_internal_flowspec() const {
  return update_case() == kFlowspec ? *_impl_.update_.flowspec_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecUpdate&>(::kentik::ktbgp::v202501::_FlowspecUpdate_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecUpdate& RouteServiceAnnounceRequest::flowspec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.flowspec)
  return _internal_flowspec();
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* RouteServiceAnnounceRequest::unsafe_arena_release_flowspec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.flowspec)
  if (update_case() == kFlowspec) {
    clear_has_update();
    auto* temp = _impl_.update_.flowspec_;
    _impl_.update_.flowspec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouteServiceAnnounceRequest::unsafe_arena_set_allocated_flowspec(::kentik::ktbgp::v202501::FlowspecUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_flowspec();
    _impl_.update_.flowspec_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.flowspec)
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* RouteServiceAnnounceRequest::_internal_mutable_flowspec() {
  if (update_case() != kFlowspec) {
    clear_update();
    set_has_flowspec();
    _impl_.update_.flowspec_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecUpdate>(GetArena());
  }
  return _impl_.update_.flowspec_;
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* RouteServiceAnnounceRequest::mutable_flowspec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecUpdate* _msg = _internal_mutable_flowspec();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.flowspec)
  return _msg;
}

// .kentik.ktbgp.v202501.RTBHUpdate rtbh = 12 [json_name = "rtbh"];
inline bool RouteServiceAnnounceRequest::has_rtbh() const {
  return update_case() == kRtbh;
}
inline bool RouteServiceAnnounceRequest::_internal_has_rtbh() const {
  return update_case() == kRtbh;
}
inline void RouteServiceAnnounceRequest::set_has_rtbh() {
  _impl_._oneof_case_[0] = kRtbh;
}
inline void RouteServiceAnnounceRequest::clear_rtbh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (update_case() == kRtbh) {
    if (GetArena() == nullptr) {
      delete _impl_.update_.rtbh_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.update_.rtbh_);
    }
    clear_has_update();
  }
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* RouteServiceAnnounceRequest::release_rtbh() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.rtbh)
  if (update_case() == kRtbh) {
    clear_has_update();
    auto* temp = _impl_.update_.rtbh_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_.rtbh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::RTBHUpdate& RouteServiceAnnounceRequest::_internal_rtbh() const {
  return update_case() == kRtbh ? *_impl_.update_.rtbh_ : reinterpret_cast<::kentik::ktbgp::v202501::RTBHUpdate&>(::kentik::ktbgp::v202501::_RTBHUpdate_default_instance_);
}
inline const ::kentik::ktbgp::v202501::RTBHUpdate& RouteServiceAnnounceRequest::rtbh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.rtbh)
  return _internal_rtbh();
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* RouteServiceAnnounceRequest::unsafe_arena_release_rtbh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.rtbh)
  if (update_case() == kRtbh) {
    clear_has_update();
    auto* temp = _impl_.update_.rtbh_;
    _impl_.update_.rtbh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouteServiceAnnounceRequest::unsafe_arena_set_allocated_rtbh(::kentik::ktbgp::v202501::RTBHUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_update();
  if (value) {
    set_has_rtbh();
    _impl_.update_.rtbh_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.rtbh)
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* RouteServiceAnnounceRequest::_internal_mutable_rtbh() {
  if (update_case() != kRtbh) {
    clear_update();
    set_has_rtbh();
    _impl_.update_.rtbh_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::RTBHUpdate>(GetArena());
  }
  return _impl_.update_.rtbh_;
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* RouteServiceAnnounceRequest::mutable_rtbh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::RTBHUpdate* _msg = _internal_mutable_rtbh();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceAnnounceRequest.rtbh)
  return _msg;
}

inline bool RouteServiceAnnounceRequest::has_update() const {
  return update_case() != UPDATE_NOT_SET;
}
inline void RouteServiceAnnounceRequest::clear_has_update() {
  _impl_._oneof_case_[0] = UPDATE_NOT_SET;
}
inline RouteServiceAnnounceRequest::UpdateCase RouteServiceAnnounceRequest::update_case() const {
  return RouteServiceAnnounceRequest::UpdateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RouteServiceAnnounceResponse

// repeated .kentik.ktbgp.v202501.UpdateResult results = 1 [json_name = "results"];
inline int RouteServiceAnnounceResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int RouteServiceAnnounceResponse::results_size() const {
  return _internal_results_size();
}
inline void RouteServiceAnnounceResponse::clear_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.results_.Clear();
}
inline ::kentik::ktbgp::v202501::UpdateResult* RouteServiceAnnounceResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceAnnounceResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>* RouteServiceAnnounceResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RouteServiceAnnounceResponse.results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_results();
}
inline const ::kentik::ktbgp::v202501::UpdateResult& RouteServiceAnnounceResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceAnnounceResponse.results)
  return _internal_results().Get(index);
}
inline ::kentik::ktbgp::v202501::UpdateResult* RouteServiceAnnounceResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::UpdateResult* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RouteServiceAnnounceResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>& RouteServiceAnnounceResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RouteServiceAnnounceResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>&
RouteServiceAnnounceResponse::_internal_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>*
RouteServiceAnnounceResponse::_internal_mutable_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.results_;
}

// -------------------------------------------------------------------

// RouteServiceWithdrawRequest

// repeated uint64 device_ids = 1 [json_name = "deviceIds"];
inline int RouteServiceWithdrawRequest::_internal_device_ids_size() const {
  return _internal_device_ids().size();
}
inline int RouteServiceWithdrawRequest::device_ids_size() const {
  return _internal_device_ids_size();
}
inline void RouteServiceWithdrawRequest::clear_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_ids_.Clear();
}
inline ::uint64_t RouteServiceWithdrawRequest::device_ids(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.device_ids)
  return _internal_device_ids().Get(index);
}
inline void RouteServiceWithdrawRequest::set_device_ids(int index, ::uint64_t value) {
  _internal_mutable_device_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.device_ids)
}
inline void RouteServiceWithdrawRequest::add_device_ids(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_device_ids()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.device_ids)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& RouteServiceWithdrawRequest::device_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.device_ids)
  return _internal_device_ids();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* RouteServiceWithdrawRequest::mutable_device_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.device_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_ids();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
RouteServiceWithdrawRequest::_internal_device_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_ids_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* RouteServiceWithdrawRequest::_internal_mutable_device_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_ids_;
}

// .kentik.ktbgp.v202501.Withdraw withdraw = 2 [json_name = "withdraw"];
inline bool RouteServiceWithdrawRequest::has_withdraw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.withdraw_ != nullptr);
  return value;
}
inline void RouteServiceWithdrawRequest::clear_withdraw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.withdraw_ != nullptr) _impl_.withdraw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::ktbgp::v202501::Withdraw& RouteServiceWithdrawRequest::_internal_withdraw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::Withdraw* p = _impl_.withdraw_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::Withdraw&>(::kentik::ktbgp::v202501::_Withdraw_default_instance_);
}
inline const ::kentik::ktbgp::v202501::Withdraw& RouteServiceWithdrawRequest::withdraw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.withdraw)
  return _internal_withdraw();
}
inline void RouteServiceWithdrawRequest::unsafe_arena_set_allocated_withdraw(::kentik::ktbgp::v202501::Withdraw* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.withdraw_);
  }
  _impl_.withdraw_ = reinterpret_cast<::kentik::ktbgp::v202501::Withdraw*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.withdraw)
}
inline ::kentik::ktbgp::v202501::Withdraw* RouteServiceWithdrawRequest::release_withdraw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::Withdraw* released = _impl_.withdraw_;
  _impl_.withdraw_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::Withdraw* RouteServiceWithdrawRequest::unsafe_arena_release_withdraw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.withdraw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::Withdraw* temp = _impl_.withdraw_;
  _impl_.withdraw_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::Withdraw* RouteServiceWithdrawRequest::_internal_mutable_withdraw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.withdraw_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::Withdraw>(GetArena());
    _impl_.withdraw_ = reinterpret_cast<::kentik::ktbgp::v202501::Withdraw*>(p);
  }
  return _impl_.withdraw_;
}
inline ::kentik::ktbgp::v202501::Withdraw* RouteServiceWithdrawRequest::mutable_withdraw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::ktbgp::v202501::Withdraw* _msg = _internal_mutable_withdraw();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.withdraw)
  return _msg;
}
inline void RouteServiceWithdrawRequest::set_allocated_withdraw(::kentik::ktbgp::v202501::Withdraw* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.withdraw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.withdraw_ = reinterpret_cast<::kentik::ktbgp::v202501::Withdraw*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RouteServiceWithdrawRequest.withdraw)
}

// -------------------------------------------------------------------

// Withdraw

// .kentik.ktbgp.v202501.FlowspecMatch flowspec = 1 [json_name = "flowspec"];
inline bool Withdraw::has_flowspec() const {
  return withdraw_case() == kFlowspec;
}
inline bool Withdraw::_internal_has_flowspec() const {
  return withdraw_case() == kFlowspec;
}
inline void Withdraw::set_has_flowspec() {
  _impl_._oneof_case_[0] = kFlowspec;
}
inline void Withdraw::clear_flowspec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (withdraw_case() == kFlowspec) {
    if (GetArena() == nullptr) {
      delete _impl_.withdraw_.flowspec_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.withdraw_.flowspec_);
    }
    clear_has_withdraw();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* Withdraw::release_flowspec() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.Withdraw.flowspec)
  if (withdraw_case() == kFlowspec) {
    clear_has_withdraw();
    auto* temp = _impl_.withdraw_.flowspec_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.withdraw_.flowspec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecMatch& Withdraw::_internal_flowspec() const {
  return withdraw_case() == kFlowspec ? *_impl_.withdraw_.flowspec_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecMatch&>(::kentik::ktbgp::v202501::_FlowspecMatch_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecMatch& Withdraw::flowspec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.Withdraw.flowspec)
  return _internal_flowspec();
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* Withdraw::unsafe_arena_release_flowspec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.Withdraw.flowspec)
  if (withdraw_case() == kFlowspec) {
    clear_has_withdraw();
    auto* temp = _impl_.withdraw_.flowspec_;
    _impl_.withdraw_.flowspec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Withdraw::unsafe_arena_set_allocated_flowspec(::kentik::ktbgp::v202501::FlowspecMatch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_withdraw();
  if (value) {
    set_has_flowspec();
    _impl_.withdraw_.flowspec_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.Withdraw.flowspec)
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* Withdraw::_internal_mutable_flowspec() {
  if (withdraw_case() != kFlowspec) {
    clear_withdraw();
    set_has_flowspec();
    _impl_.withdraw_.flowspec_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecMatch>(GetArena());
  }
  return _impl_.withdraw_.flowspec_;
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* Withdraw::mutable_flowspec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecMatch* _msg = _internal_mutable_flowspec();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.Withdraw.flowspec)
  return _msg;
}

// .kentik.ktbgp.v202501.RTBHMatch rtbh = 2 [json_name = "rtbh"];
inline bool Withdraw::has_rtbh() const {
  return withdraw_case() == kRtbh;
}
inline bool Withdraw::_internal_has_rtbh() const {
  return withdraw_case() == kRtbh;
}
inline void Withdraw::set_has_rtbh() {
  _impl_._oneof_case_[0] = kRtbh;
}
inline void Withdraw::clear_rtbh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (withdraw_case() == kRtbh) {
    if (GetArena() == nullptr) {
      delete _impl_.withdraw_.rtbh_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.withdraw_.rtbh_);
    }
    clear_has_withdraw();
  }
}
inline ::kentik::ktbgp::v202501::RTBHMatch* Withdraw::release_rtbh() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.Withdraw.rtbh)
  if (withdraw_case() == kRtbh) {
    clear_has_withdraw();
    auto* temp = _impl_.withdraw_.rtbh_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.withdraw_.rtbh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::RTBHMatch& Withdraw::_internal_rtbh() const {
  return withdraw_case() == kRtbh ? *_impl_.withdraw_.rtbh_ : reinterpret_cast<::kentik::ktbgp::v202501::RTBHMatch&>(::kentik::ktbgp::v202501::_RTBHMatch_default_instance_);
}
inline const ::kentik::ktbgp::v202501::RTBHMatch& Withdraw::rtbh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.Withdraw.rtbh)
  return _internal_rtbh();
}
inline ::kentik::ktbgp::v202501::RTBHMatch* Withdraw::unsafe_arena_release_rtbh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.Withdraw.rtbh)
  if (withdraw_case() == kRtbh) {
    clear_has_withdraw();
    auto* temp = _impl_.withdraw_.rtbh_;
    _impl_.withdraw_.rtbh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Withdraw::unsafe_arena_set_allocated_rtbh(::kentik::ktbgp::v202501::RTBHMatch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_withdraw();
  if (value) {
    set_has_rtbh();
    _impl_.withdraw_.rtbh_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.Withdraw.rtbh)
}
inline ::kentik::ktbgp::v202501::RTBHMatch* Withdraw::_internal_mutable_rtbh() {
  if (withdraw_case() != kRtbh) {
    clear_withdraw();
    set_has_rtbh();
    _impl_.withdraw_.rtbh_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::RTBHMatch>(GetArena());
  }
  return _impl_.withdraw_.rtbh_;
}
inline ::kentik::ktbgp::v202501::RTBHMatch* Withdraw::mutable_rtbh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::RTBHMatch* _msg = _internal_mutable_rtbh();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.Withdraw.rtbh)
  return _msg;
}

inline bool Withdraw::has_withdraw() const {
  return withdraw_case() != WITHDRAW_NOT_SET;
}
inline void Withdraw::clear_has_withdraw() {
  _impl_._oneof_case_[0] = WITHDRAW_NOT_SET;
}
inline Withdraw::WithdrawCase Withdraw::withdraw_case() const {
  return Withdraw::WithdrawCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RouteServiceWithdrawResponse

// repeated .kentik.ktbgp.v202501.UpdateResult results = 1 [json_name = "results"];
inline int RouteServiceWithdrawResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int RouteServiceWithdrawResponse::results_size() const {
  return _internal_results_size();
}
inline void RouteServiceWithdrawResponse::clear_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.results_.Clear();
}
inline ::kentik::ktbgp::v202501::UpdateResult* RouteServiceWithdrawResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceWithdrawResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>* RouteServiceWithdrawResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RouteServiceWithdrawResponse.results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_results();
}
inline const ::kentik::ktbgp::v202501::UpdateResult& RouteServiceWithdrawResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceWithdrawResponse.results)
  return _internal_results().Get(index);
}
inline ::kentik::ktbgp::v202501::UpdateResult* RouteServiceWithdrawResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::UpdateResult* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RouteServiceWithdrawResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>& RouteServiceWithdrawResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RouteServiceWithdrawResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>&
RouteServiceWithdrawResponse::_internal_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::UpdateResult>*
RouteServiceWithdrawResponse::_internal_mutable_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.results_;
}

// -------------------------------------------------------------------

// FlowspecAction

// .kentik.ktbgp.v202501.FlowspecActionAccept accept = 1 [json_name = "accept"];
inline bool FlowspecAction::has_accept() const {
  return action_case() == kAccept;
}
inline bool FlowspecAction::_internal_has_accept() const {
  return action_case() == kAccept;
}
inline void FlowspecAction::set_has_accept() {
  _impl_._oneof_case_[0] = kAccept;
}
inline void FlowspecAction::clear_accept() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kAccept) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.accept_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.accept_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecAction::release_accept() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.accept)
  if (action_case() == kAccept) {
    clear_has_action();
    auto* temp = _impl_.action_.accept_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionAccept& FlowspecAction::_internal_accept() const {
  return action_case() == kAccept ? *_impl_.action_.accept_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionAccept&>(::kentik::ktbgp::v202501::_FlowspecActionAccept_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionAccept& FlowspecAction::accept() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.accept)
  return _internal_accept();
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecAction::unsafe_arena_release_accept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.accept)
  if (action_case() == kAccept) {
    clear_has_action();
    auto* temp = _impl_.action_.accept_;
    _impl_.action_.accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_accept(::kentik::ktbgp::v202501::FlowspecActionAccept* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_accept();
    _impl_.action_.accept_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.accept)
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecAction::_internal_mutable_accept() {
  if (action_case() != kAccept) {
    clear_action();
    set_has_accept();
    _impl_.action_.accept_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionAccept>(GetArena());
  }
  return _impl_.action_.accept_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecAction::mutable_accept() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionAccept* _msg = _internal_mutable_accept();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.accept)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionDiscard discard = 2 [json_name = "discard"];
inline bool FlowspecAction::has_discard() const {
  return action_case() == kDiscard;
}
inline bool FlowspecAction::_internal_has_discard() const {
  return action_case() == kDiscard;
}
inline void FlowspecAction::set_has_discard() {
  _impl_._oneof_case_[0] = kDiscard;
}
inline void FlowspecAction::clear_discard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kDiscard) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.discard_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.discard_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecAction::release_discard() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.discard)
  if (action_case() == kDiscard) {
    clear_has_action();
    auto* temp = _impl_.action_.discard_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.discard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionDiscard& FlowspecAction::_internal_discard() const {
  return action_case() == kDiscard ? *_impl_.action_.discard_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionDiscard&>(::kentik::ktbgp::v202501::_FlowspecActionDiscard_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionDiscard& FlowspecAction::discard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.discard)
  return _internal_discard();
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecAction::unsafe_arena_release_discard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.discard)
  if (action_case() == kDiscard) {
    clear_has_action();
    auto* temp = _impl_.action_.discard_;
    _impl_.action_.discard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_discard(::kentik::ktbgp::v202501::FlowspecActionDiscard* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_discard();
    _impl_.action_.discard_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.discard)
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecAction::_internal_mutable_discard() {
  if (action_case() != kDiscard) {
    clear_action();
    set_has_discard();
    _impl_.action_.discard_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionDiscard>(GetArena());
  }
  return _impl_.action_.discard_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecAction::mutable_discard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* _msg = _internal_mutable_discard();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.discard)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes rate_bytes = 3 [json_name = "rateBytes"];
inline bool FlowspecAction::has_rate_bytes() const {
  return action_case() == kRateBytes;
}
inline bool FlowspecAction::_internal_has_rate_bytes() const {
  return action_case() == kRateBytes;
}
inline void FlowspecAction::set_has_rate_bytes() {
  _impl_._oneof_case_[0] = kRateBytes;
}
inline void FlowspecAction::clear_rate_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRateBytes) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rate_bytes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rate_bytes_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecAction::release_rate_bytes() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.rate_bytes)
  if (action_case() == kRateBytes) {
    clear_has_action();
    auto* temp = _impl_.action_.rate_bytes_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rate_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& FlowspecAction::_internal_rate_bytes() const {
  return action_case() == kRateBytes ? *_impl_.action_.rate_bytes_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes&>(::kentik::ktbgp::v202501::_FlowspecActionTrafficRateBytes_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& FlowspecAction::rate_bytes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.rate_bytes)
  return _internal_rate_bytes();
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecAction::unsafe_arena_release_rate_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.rate_bytes)
  if (action_case() == kRateBytes) {
    clear_has_action();
    auto* temp = _impl_.action_.rate_bytes_;
    _impl_.action_.rate_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_rate_bytes(::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rate_bytes();
    _impl_.action_.rate_bytes_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.rate_bytes)
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecAction::_internal_mutable_rate_bytes() {
  if (action_case() != kRateBytes) {
    clear_action();
    set_has_rate_bytes();
    _impl_.action_.rate_bytes_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes>(GetArena());
  }
  return _impl_.action_.rate_bytes_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecAction::mutable_rate_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* _msg = _internal_mutable_rate_bytes();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.rate_bytes)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionMarkDSCP mark_dscp = 4 [json_name = "markDscp"];
inline bool FlowspecAction::has_mark_dscp() const {
  return action_case() == kMarkDscp;
}
inline bool FlowspecAction::_internal_has_mark_dscp() const {
  return action_case() == kMarkDscp;
}
inline void FlowspecAction::set_has_mark_dscp() {
  _impl_._oneof_case_[0] = kMarkDscp;
}
inline void FlowspecAction::clear_mark_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kMarkDscp) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.mark_dscp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.mark_dscp_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecAction::release_mark_dscp() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.mark_dscp)
  if (action_case() == kMarkDscp) {
    clear_has_action();
    auto* temp = _impl_.action_.mark_dscp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.mark_dscp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& FlowspecAction::_internal_mark_dscp() const {
  return action_case() == kMarkDscp ? *_impl_.action_.mark_dscp_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionMarkDSCP&>(::kentik::ktbgp::v202501::_FlowspecActionMarkDSCP_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& FlowspecAction::mark_dscp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.mark_dscp)
  return _internal_mark_dscp();
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecAction::unsafe_arena_release_mark_dscp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.mark_dscp)
  if (action_case() == kMarkDscp) {
    clear_has_action();
    auto* temp = _impl_.action_.mark_dscp_;
    _impl_.action_.mark_dscp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_mark_dscp(::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_mark_dscp();
    _impl_.action_.mark_dscp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.mark_dscp)
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecAction::_internal_mutable_mark_dscp() {
  if (action_case() != kMarkDscp) {
    clear_action();
    set_has_mark_dscp();
    _impl_.action_.mark_dscp_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionMarkDSCP>(GetArena());
  }
  return _impl_.action_.mark_dscp_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecAction::mutable_mark_dscp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* _msg = _internal_mutable_mark_dscp();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.mark_dscp)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect rt_redirect = 5 [json_name = "rtRedirect"];
inline bool FlowspecAction::has_rt_redirect() const {
  return action_case() == kRtRedirect;
}
inline bool FlowspecAction::_internal_has_rt_redirect() const {
  return action_case() == kRtRedirect;
}
inline void FlowspecAction::set_has_rt_redirect() {
  _impl_._oneof_case_[0] = kRtRedirect;
}
inline void FlowspecAction::clear_rt_redirect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRtRedirect) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rt_redirect_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rt_redirect_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecAction::release_rt_redirect() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.rt_redirect)
  if (action_case() == kRtRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_redirect_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rt_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& FlowspecAction::_internal_rt_redirect() const {
  return action_case() == kRtRedirect ? *_impl_.action_.rt_redirect_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect&>(::kentik::ktbgp::v202501::_FlowspecActionRouteTargetRedirect_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& FlowspecAction::rt_redirect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.rt_redirect)
  return _internal_rt_redirect();
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecAction::unsafe_arena_release_rt_redirect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.rt_redirect)
  if (action_case() == kRtRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_redirect_;
    _impl_.action_.rt_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_rt_redirect(::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rt_redirect();
    _impl_.action_.rt_redirect_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.rt_redirect)
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecAction::_internal_mutable_rt_redirect() {
  if (action_case() != kRtRedirect) {
    clear_action();
    set_has_rt_redirect();
    _impl_.action_.rt_redirect_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect>(GetArena());
  }
  return _impl_.action_.rt_redirect_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecAction::mutable_rt_redirect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* _msg = _internal_mutable_rt_redirect();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.rt_redirect)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect ip_redirect = 6 [json_name = "ipRedirect"];
inline bool FlowspecAction::has_ip_redirect() const {
  return action_case() == kIpRedirect;
}
inline bool FlowspecAction::_internal_has_ip_redirect() const {
  return action_case() == kIpRedirect;
}
inline void FlowspecAction::set_has_ip_redirect() {
  _impl_._oneof_case_[0] = kIpRedirect;
}
inline void FlowspecAction::clear_ip_redirect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kIpRedirect) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.ip_redirect_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.ip_redirect_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecAction::release_ip_redirect() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.ip_redirect)
  if (action_case() == kIpRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.ip_redirect_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.ip_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& FlowspecAction::_internal_ip_redirect() const {
  return action_case() == kIpRedirect ? *_impl_.action_.ip_redirect_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect&>(::kentik::ktbgp::v202501::_FlowspecActionIPNextHopRedirect_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& FlowspecAction::ip_redirect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.ip_redirect)
  return _internal_ip_redirect();
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecAction::unsafe_arena_release_ip_redirect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.ip_redirect)
  if (action_case() == kIpRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.ip_redirect_;
    _impl_.action_.ip_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_ip_redirect(::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_ip_redirect();
    _impl_.action_.ip_redirect_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.ip_redirect)
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecAction::_internal_mutable_ip_redirect() {
  if (action_case() != kIpRedirect) {
    clear_action();
    set_has_ip_redirect();
    _impl_.action_.ip_redirect_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect>(GetArena());
  }
  return _impl_.action_.ip_redirect_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecAction::mutable_ip_redirect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* _msg = _internal_mutable_ip_redirect();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.ip_redirect)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionTerminalSample action_type = 7 [json_name = "actionType"];
inline bool FlowspecAction::has_action_type() const {
  return action_case() == kActionType;
}
inline bool FlowspecAction::_internal_has_action_type() const {
  return action_case() == kActionType;
}
inline void FlowspecAction::set_has_action_type() {
  _impl_._oneof_case_[0] = kActionType;
}
inline void FlowspecAction::clear_action_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kActionType) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.action_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.action_type_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecAction::release_action_type() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.action_type)
  if (action_case() == kActionType) {
    clear_has_action();
    auto* temp = _impl_.action_.action_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.action_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& FlowspecAction::_internal_action_type() const {
  return action_case() == kActionType ? *_impl_.action_.action_type_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionTerminalSample&>(::kentik::ktbgp::v202501::_FlowspecActionTerminalSample_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& FlowspecAction::action_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.action_type)
  return _internal_action_type();
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecAction::unsafe_arena_release_action_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.action_type)
  if (action_case() == kActionType) {
    clear_has_action();
    auto* temp = _impl_.action_.action_type_;
    _impl_.action_.action_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_action_type(::kentik::ktbgp::v202501::FlowspecActionTerminalSample* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_action_type();
    _impl_.action_.action_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.action_type)
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecAction::_internal_mutable_action_type() {
  if (action_case() != kActionType) {
    clear_action();
    set_has_action_type();
    _impl_.action_.action_type_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionTerminalSample>(GetArena());
  }
  return _impl_.action_.action_type_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecAction::mutable_action_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* _msg = _internal_mutable_action_type();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.action_type)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy rt_copy = 8 [json_name = "rtCopy"];
inline bool FlowspecAction::has_rt_copy() const {
  return action_case() == kRtCopy;
}
inline bool FlowspecAction::_internal_has_rt_copy() const {
  return action_case() == kRtCopy;
}
inline void FlowspecAction::set_has_rt_copy() {
  _impl_._oneof_case_[0] = kRtCopy;
}
inline void FlowspecAction::clear_rt_copy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRtCopy) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rt_copy_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rt_copy_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecAction::release_rt_copy() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.rt_copy)
  if (action_case() == kRtCopy) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_copy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rt_copy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& FlowspecAction::_internal_rt_copy() const {
  return action_case() == kRtCopy ? *_impl_.action_.rt_copy_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy&>(::kentik::ktbgp::v202501::_FlowspecActionIPNextHopCopy_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& FlowspecAction::rt_copy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.rt_copy)
  return _internal_rt_copy();
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecAction::unsafe_arena_release_rt_copy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.rt_copy)
  if (action_case() == kRtCopy) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_copy_;
    _impl_.action_.rt_copy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_rt_copy(::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rt_copy();
    _impl_.action_.rt_copy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.rt_copy)
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecAction::_internal_mutable_rt_copy() {
  if (action_case() != kRtCopy) {
    clear_action();
    set_has_rt_copy();
    _impl_.action_.rt_copy_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy>(GetArena());
  }
  return _impl_.action_.rt_copy_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecAction::mutable_rt_copy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* _msg = _internal_mutable_rt_copy();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.rt_copy)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionRegularCommunity regular_community = 9 [json_name = "regularCommunity"];
inline bool FlowspecAction::has_regular_community() const {
  return action_case() == kRegularCommunity;
}
inline bool FlowspecAction::_internal_has_regular_community() const {
  return action_case() == kRegularCommunity;
}
inline void FlowspecAction::set_has_regular_community() {
  _impl_._oneof_case_[0] = kRegularCommunity;
}
inline void FlowspecAction::clear_regular_community() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRegularCommunity) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.regular_community_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.regular_community_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecAction::release_regular_community() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.regular_community)
  if (action_case() == kRegularCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.regular_community_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.regular_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& FlowspecAction::_internal_regular_community() const {
  return action_case() == kRegularCommunity ? *_impl_.action_.regular_community_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionRegularCommunity&>(::kentik::ktbgp::v202501::_FlowspecActionRegularCommunity_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& FlowspecAction::regular_community() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.regular_community)
  return _internal_regular_community();
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecAction::unsafe_arena_release_regular_community() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.regular_community)
  if (action_case() == kRegularCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.regular_community_;
    _impl_.action_.regular_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_regular_community(::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_regular_community();
    _impl_.action_.regular_community_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.regular_community)
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecAction::_internal_mutable_regular_community() {
  if (action_case() != kRegularCommunity) {
    clear_action();
    set_has_regular_community();
    _impl_.action_.regular_community_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionRegularCommunity>(GetArena());
  }
  return _impl_.action_.regular_community_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecAction::mutable_regular_community() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* _msg = _internal_mutable_regular_community();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.regular_community)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionExtendedCommunity extended_community = 10 [json_name = "extendedCommunity"];
inline bool FlowspecAction::has_extended_community() const {
  return action_case() == kExtendedCommunity;
}
inline bool FlowspecAction::_internal_has_extended_community() const {
  return action_case() == kExtendedCommunity;
}
inline void FlowspecAction::set_has_extended_community() {
  _impl_._oneof_case_[0] = kExtendedCommunity;
}
inline void FlowspecAction::clear_extended_community() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kExtendedCommunity) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.extended_community_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.extended_community_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecAction::release_extended_community() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.extended_community)
  if (action_case() == kExtendedCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.extended_community_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.extended_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& FlowspecAction::_internal_extended_community() const {
  return action_case() == kExtendedCommunity ? *_impl_.action_.extended_community_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity&>(::kentik::ktbgp::v202501::_FlowspecActionExtendedCommunity_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& FlowspecAction::extended_community() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.extended_community)
  return _internal_extended_community();
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecAction::unsafe_arena_release_extended_community() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.extended_community)
  if (action_case() == kExtendedCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.extended_community_;
    _impl_.action_.extended_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_extended_community(::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_extended_community();
    _impl_.action_.extended_community_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.extended_community)
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecAction::_internal_mutable_extended_community() {
  if (action_case() != kExtendedCommunity) {
    clear_action();
    set_has_extended_community();
    _impl_.action_.extended_community_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity>(GetArena());
  }
  return _impl_.action_.extended_community_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecAction::mutable_extended_community() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* _msg = _internal_mutable_extended_community();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.extended_community)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionLargeCommunity large_community = 11 [json_name = "largeCommunity"];
inline bool FlowspecAction::has_large_community() const {
  return action_case() == kLargeCommunity;
}
inline bool FlowspecAction::_internal_has_large_community() const {
  return action_case() == kLargeCommunity;
}
inline void FlowspecAction::set_has_large_community() {
  _impl_._oneof_case_[0] = kLargeCommunity;
}
inline void FlowspecAction::clear_large_community() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kLargeCommunity) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.large_community_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.large_community_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecAction::release_large_community() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecAction.large_community)
  if (action_case() == kLargeCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.large_community_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.large_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& FlowspecAction::_internal_large_community() const {
  return action_case() == kLargeCommunity ? *_impl_.action_.large_community_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionLargeCommunity&>(::kentik::ktbgp::v202501::_FlowspecActionLargeCommunity_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& FlowspecAction::large_community() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecAction.large_community)
  return _internal_large_community();
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecAction::unsafe_arena_release_large_community() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecAction.large_community)
  if (action_case() == kLargeCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.large_community_;
    _impl_.action_.large_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecAction::unsafe_arena_set_allocated_large_community(::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_large_community();
    _impl_.action_.large_community_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecAction.large_community)
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecAction::_internal_mutable_large_community() {
  if (action_case() != kLargeCommunity) {
    clear_action();
    set_has_large_community();
    _impl_.action_.large_community_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionLargeCommunity>(GetArena());
  }
  return _impl_.action_.large_community_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecAction::mutable_large_community() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* _msg = _internal_mutable_large_community();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecAction.large_community)
  return _msg;
}

inline bool FlowspecAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void FlowspecAction::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline FlowspecAction::ActionCase FlowspecAction::action_case() const {
  return FlowspecAction::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FlowspecUpdate

// .kentik.ktbgp.v202501.FlowspecMatch match = 1 [json_name = "match"];
inline bool FlowspecUpdate::has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline void FlowspecUpdate::clear_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::ktbgp::v202501::FlowspecMatch& FlowspecUpdate::_internal_match() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::FlowspecMatch* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::FlowspecMatch&>(::kentik::ktbgp::v202501::_FlowspecMatch_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecMatch& FlowspecUpdate::match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.match)
  return _internal_match();
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_match(::kentik::ktbgp::v202501::FlowspecMatch* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = reinterpret_cast<::kentik::ktbgp::v202501::FlowspecMatch*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.match)
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* FlowspecUpdate::release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::FlowspecMatch* released = _impl_.match_;
  _impl_.match_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* FlowspecUpdate::unsafe_arena_release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.match)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::FlowspecMatch* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* FlowspecUpdate::_internal_mutable_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecMatch>(GetArena());
    _impl_.match_ = reinterpret_cast<::kentik::ktbgp::v202501::FlowspecMatch*>(p);
  }
  return _impl_.match_;
}
inline ::kentik::ktbgp::v202501::FlowspecMatch* FlowspecUpdate::mutable_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::ktbgp::v202501::FlowspecMatch* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.match)
  return _msg;
}
inline void FlowspecUpdate::set_allocated_match(::kentik::ktbgp::v202501::FlowspecMatch* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.match_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.match_ = reinterpret_cast<::kentik::ktbgp::v202501::FlowspecMatch*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.match)
}

// .google.protobuf.Timestamp creation_time = 2 [json_name = "creationTime"];
inline bool FlowspecUpdate::has_creation_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creation_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& FlowspecUpdate::_internal_creation_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.creation_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& FlowspecUpdate::creation_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.creation_time)
  return _internal_creation_time();
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }
  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.creation_time)
}
inline ::google::protobuf::Timestamp* FlowspecUpdate::release_creation_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* FlowspecUpdate::unsafe_arena_release_creation_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.creation_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* FlowspecUpdate::_internal_mutable_creation_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.creation_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.creation_time_;
}
inline ::google::protobuf::Timestamp* FlowspecUpdate::mutable_creation_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_creation_time();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.creation_time)
  return _msg;
}
inline void FlowspecUpdate::set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.creation_time)
}

// string inet = 3 [json_name = "inet", deprecated = true];
inline void FlowspecUpdate::clear_inet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.ClearToEmpty();
}
inline const std::string& FlowspecUpdate::inet() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.inet)
  return _internal_inet();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowspecUpdate::set_inet(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecUpdate.inet)
}
inline std::string* FlowspecUpdate::mutable_inet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_inet();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.inet)
  return _s;
}
inline const std::string& FlowspecUpdate::_internal_inet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inet_.Get();
}
inline void FlowspecUpdate::_internal_set_inet(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.Set(value, GetArena());
}
inline std::string* FlowspecUpdate::_internal_mutable_inet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.inet_.Mutable( GetArena());
}
inline std::string* FlowspecUpdate::release_inet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.inet)
  return _impl_.inet_.Release();
}
inline void FlowspecUpdate::set_allocated_inet(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.inet_.IsDefault()) {
    _impl_.inet_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.inet)
}

// .kentik.ktbgp.v202501.InetType inet_type = 6 [json_name = "inetType"];
inline void FlowspecUpdate::clear_inet_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_type_ = 0;
}
inline ::kentik::ktbgp::v202501::InetType FlowspecUpdate::inet_type() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.inet_type)
  return _internal_inet_type();
}
inline void FlowspecUpdate::set_inet_type(::kentik::ktbgp::v202501::InetType value) {
  _internal_set_inet_type(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecUpdate.inet_type)
}
inline ::kentik::ktbgp::v202501::InetType FlowspecUpdate::_internal_inet_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::InetType>(_impl_.inet_type_);
}
inline void FlowspecUpdate::_internal_set_inet_type(::kentik::ktbgp::v202501::InetType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_type_ = value;
}

// string key = 7 [json_name = "key"];
inline void FlowspecUpdate::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& FlowspecUpdate::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowspecUpdate::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecUpdate.key)
}
inline std::string* FlowspecUpdate::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.key)
  return _s;
}
inline const std::string& FlowspecUpdate::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void FlowspecUpdate::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* FlowspecUpdate::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* FlowspecUpdate::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.key)
  return _impl_.key_.Release();
}
inline void FlowspecUpdate::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.key)
}

// .kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes rate_bytes = 11 [json_name = "rateBytes"];
inline bool FlowspecUpdate::has_rate_bytes() const {
  return action_case() == kRateBytes;
}
inline bool FlowspecUpdate::_internal_has_rate_bytes() const {
  return action_case() == kRateBytes;
}
inline void FlowspecUpdate::set_has_rate_bytes() {
  _impl_._oneof_case_[0] = kRateBytes;
}
inline void FlowspecUpdate::clear_rate_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRateBytes) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rate_bytes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rate_bytes_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecUpdate::release_rate_bytes() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.rate_bytes)
  if (action_case() == kRateBytes) {
    clear_has_action();
    auto* temp = _impl_.action_.rate_bytes_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rate_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& FlowspecUpdate::_internal_rate_bytes() const {
  return action_case() == kRateBytes ? *_impl_.action_.rate_bytes_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes&>(::kentik::ktbgp::v202501::_FlowspecActionTrafficRateBytes_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes& FlowspecUpdate::rate_bytes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.rate_bytes)
  return _internal_rate_bytes();
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecUpdate::unsafe_arena_release_rate_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.rate_bytes)
  if (action_case() == kRateBytes) {
    clear_has_action();
    auto* temp = _impl_.action_.rate_bytes_;
    _impl_.action_.rate_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_rate_bytes(::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rate_bytes();
    _impl_.action_.rate_bytes_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.rate_bytes)
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecUpdate::_internal_mutable_rate_bytes() {
  if (action_case() != kRateBytes) {
    clear_action();
    set_has_rate_bytes();
    _impl_.action_.rate_bytes_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes>(GetArena());
  }
  return _impl_.action_.rate_bytes_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* FlowspecUpdate::mutable_rate_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionTrafficRateBytes* _msg = _internal_mutable_rate_bytes();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.rate_bytes)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionDiscard discard = 12 [json_name = "discard"];
inline bool FlowspecUpdate::has_discard() const {
  return action_case() == kDiscard;
}
inline bool FlowspecUpdate::_internal_has_discard() const {
  return action_case() == kDiscard;
}
inline void FlowspecUpdate::set_has_discard() {
  _impl_._oneof_case_[0] = kDiscard;
}
inline void FlowspecUpdate::clear_discard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kDiscard) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.discard_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.discard_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecUpdate::release_discard() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.discard)
  if (action_case() == kDiscard) {
    clear_has_action();
    auto* temp = _impl_.action_.discard_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.discard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionDiscard& FlowspecUpdate::_internal_discard() const {
  return action_case() == kDiscard ? *_impl_.action_.discard_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionDiscard&>(::kentik::ktbgp::v202501::_FlowspecActionDiscard_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionDiscard& FlowspecUpdate::discard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.discard)
  return _internal_discard();
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecUpdate::unsafe_arena_release_discard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.discard)
  if (action_case() == kDiscard) {
    clear_has_action();
    auto* temp = _impl_.action_.discard_;
    _impl_.action_.discard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_discard(::kentik::ktbgp::v202501::FlowspecActionDiscard* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_discard();
    _impl_.action_.discard_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.discard)
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecUpdate::_internal_mutable_discard() {
  if (action_case() != kDiscard) {
    clear_action();
    set_has_discard();
    _impl_.action_.discard_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionDiscard>(GetArena());
  }
  return _impl_.action_.discard_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionDiscard* FlowspecUpdate::mutable_discard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionDiscard* _msg = _internal_mutable_discard();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.discard)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionMarkDSCP mark_dscp = 13 [json_name = "markDscp"];
inline bool FlowspecUpdate::has_mark_dscp() const {
  return action_case() == kMarkDscp;
}
inline bool FlowspecUpdate::_internal_has_mark_dscp() const {
  return action_case() == kMarkDscp;
}
inline void FlowspecUpdate::set_has_mark_dscp() {
  _impl_._oneof_case_[0] = kMarkDscp;
}
inline void FlowspecUpdate::clear_mark_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kMarkDscp) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.mark_dscp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.mark_dscp_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecUpdate::release_mark_dscp() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.mark_dscp)
  if (action_case() == kMarkDscp) {
    clear_has_action();
    auto* temp = _impl_.action_.mark_dscp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.mark_dscp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& FlowspecUpdate::_internal_mark_dscp() const {
  return action_case() == kMarkDscp ? *_impl_.action_.mark_dscp_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionMarkDSCP&>(::kentik::ktbgp::v202501::_FlowspecActionMarkDSCP_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP& FlowspecUpdate::mark_dscp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.mark_dscp)
  return _internal_mark_dscp();
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecUpdate::unsafe_arena_release_mark_dscp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.mark_dscp)
  if (action_case() == kMarkDscp) {
    clear_has_action();
    auto* temp = _impl_.action_.mark_dscp_;
    _impl_.action_.mark_dscp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_mark_dscp(::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_mark_dscp();
    _impl_.action_.mark_dscp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.mark_dscp)
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecUpdate::_internal_mutable_mark_dscp() {
  if (action_case() != kMarkDscp) {
    clear_action();
    set_has_mark_dscp();
    _impl_.action_.mark_dscp_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionMarkDSCP>(GetArena());
  }
  return _impl_.action_.mark_dscp_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* FlowspecUpdate::mutable_mark_dscp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionMarkDSCP* _msg = _internal_mutable_mark_dscp();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.mark_dscp)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect rt_redirect = 14 [json_name = "rtRedirect"];
inline bool FlowspecUpdate::has_rt_redirect() const {
  return action_case() == kRtRedirect;
}
inline bool FlowspecUpdate::_internal_has_rt_redirect() const {
  return action_case() == kRtRedirect;
}
inline void FlowspecUpdate::set_has_rt_redirect() {
  _impl_._oneof_case_[0] = kRtRedirect;
}
inline void FlowspecUpdate::clear_rt_redirect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRtRedirect) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rt_redirect_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rt_redirect_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecUpdate::release_rt_redirect() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.rt_redirect)
  if (action_case() == kRtRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_redirect_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rt_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& FlowspecUpdate::_internal_rt_redirect() const {
  return action_case() == kRtRedirect ? *_impl_.action_.rt_redirect_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect&>(::kentik::ktbgp::v202501::_FlowspecActionRouteTargetRedirect_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect& FlowspecUpdate::rt_redirect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.rt_redirect)
  return _internal_rt_redirect();
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecUpdate::unsafe_arena_release_rt_redirect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.rt_redirect)
  if (action_case() == kRtRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_redirect_;
    _impl_.action_.rt_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_rt_redirect(::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rt_redirect();
    _impl_.action_.rt_redirect_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.rt_redirect)
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecUpdate::_internal_mutable_rt_redirect() {
  if (action_case() != kRtRedirect) {
    clear_action();
    set_has_rt_redirect();
    _impl_.action_.rt_redirect_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect>(GetArena());
  }
  return _impl_.action_.rt_redirect_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* FlowspecUpdate::mutable_rt_redirect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionRouteTargetRedirect* _msg = _internal_mutable_rt_redirect();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.rt_redirect)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect ip_redirect = 15 [json_name = "ipRedirect"];
inline bool FlowspecUpdate::has_ip_redirect() const {
  return action_case() == kIpRedirect;
}
inline bool FlowspecUpdate::_internal_has_ip_redirect() const {
  return action_case() == kIpRedirect;
}
inline void FlowspecUpdate::set_has_ip_redirect() {
  _impl_._oneof_case_[0] = kIpRedirect;
}
inline void FlowspecUpdate::clear_ip_redirect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kIpRedirect) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.ip_redirect_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.ip_redirect_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecUpdate::release_ip_redirect() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.ip_redirect)
  if (action_case() == kIpRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.ip_redirect_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.ip_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& FlowspecUpdate::_internal_ip_redirect() const {
  return action_case() == kIpRedirect ? *_impl_.action_.ip_redirect_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect&>(::kentik::ktbgp::v202501::_FlowspecActionIPNextHopRedirect_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect& FlowspecUpdate::ip_redirect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.ip_redirect)
  return _internal_ip_redirect();
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecUpdate::unsafe_arena_release_ip_redirect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.ip_redirect)
  if (action_case() == kIpRedirect) {
    clear_has_action();
    auto* temp = _impl_.action_.ip_redirect_;
    _impl_.action_.ip_redirect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_ip_redirect(::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_ip_redirect();
    _impl_.action_.ip_redirect_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.ip_redirect)
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecUpdate::_internal_mutable_ip_redirect() {
  if (action_case() != kIpRedirect) {
    clear_action();
    set_has_ip_redirect();
    _impl_.action_.ip_redirect_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect>(GetArena());
  }
  return _impl_.action_.ip_redirect_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* FlowspecUpdate::mutable_ip_redirect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopRedirect* _msg = _internal_mutable_ip_redirect();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.ip_redirect)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionAccept accept = 16 [json_name = "accept"];
inline bool FlowspecUpdate::has_accept() const {
  return action_case() == kAccept;
}
inline bool FlowspecUpdate::_internal_has_accept() const {
  return action_case() == kAccept;
}
inline void FlowspecUpdate::set_has_accept() {
  _impl_._oneof_case_[0] = kAccept;
}
inline void FlowspecUpdate::clear_accept() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kAccept) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.accept_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.accept_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecUpdate::release_accept() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.accept)
  if (action_case() == kAccept) {
    clear_has_action();
    auto* temp = _impl_.action_.accept_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionAccept& FlowspecUpdate::_internal_accept() const {
  return action_case() == kAccept ? *_impl_.action_.accept_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionAccept&>(::kentik::ktbgp::v202501::_FlowspecActionAccept_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionAccept& FlowspecUpdate::accept() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.accept)
  return _internal_accept();
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecUpdate::unsafe_arena_release_accept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.accept)
  if (action_case() == kAccept) {
    clear_has_action();
    auto* temp = _impl_.action_.accept_;
    _impl_.action_.accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_accept(::kentik::ktbgp::v202501::FlowspecActionAccept* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_accept();
    _impl_.action_.accept_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.accept)
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecUpdate::_internal_mutable_accept() {
  if (action_case() != kAccept) {
    clear_action();
    set_has_accept();
    _impl_.action_.accept_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionAccept>(GetArena());
  }
  return _impl_.action_.accept_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionAccept* FlowspecUpdate::mutable_accept() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionAccept* _msg = _internal_mutable_accept();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.accept)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionTerminalSample action_type = 17 [json_name = "actionType"];
inline bool FlowspecUpdate::has_action_type() const {
  return action_case() == kActionType;
}
inline bool FlowspecUpdate::_internal_has_action_type() const {
  return action_case() == kActionType;
}
inline void FlowspecUpdate::set_has_action_type() {
  _impl_._oneof_case_[0] = kActionType;
}
inline void FlowspecUpdate::clear_action_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kActionType) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.action_type_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.action_type_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecUpdate::release_action_type() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.action_type)
  if (action_case() == kActionType) {
    clear_has_action();
    auto* temp = _impl_.action_.action_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.action_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& FlowspecUpdate::_internal_action_type() const {
  return action_case() == kActionType ? *_impl_.action_.action_type_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionTerminalSample&>(::kentik::ktbgp::v202501::_FlowspecActionTerminalSample_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionTerminalSample& FlowspecUpdate::action_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.action_type)
  return _internal_action_type();
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecUpdate::unsafe_arena_release_action_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.action_type)
  if (action_case() == kActionType) {
    clear_has_action();
    auto* temp = _impl_.action_.action_type_;
    _impl_.action_.action_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_action_type(::kentik::ktbgp::v202501::FlowspecActionTerminalSample* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_action_type();
    _impl_.action_.action_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.action_type)
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecUpdate::_internal_mutable_action_type() {
  if (action_case() != kActionType) {
    clear_action();
    set_has_action_type();
    _impl_.action_.action_type_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionTerminalSample>(GetArena());
  }
  return _impl_.action_.action_type_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* FlowspecUpdate::mutable_action_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionTerminalSample* _msg = _internal_mutable_action_type();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.action_type)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy rt_copy = 18 [json_name = "rtCopy"];
inline bool FlowspecUpdate::has_rt_copy() const {
  return action_case() == kRtCopy;
}
inline bool FlowspecUpdate::_internal_has_rt_copy() const {
  return action_case() == kRtCopy;
}
inline void FlowspecUpdate::set_has_rt_copy() {
  _impl_._oneof_case_[0] = kRtCopy;
}
inline void FlowspecUpdate::clear_rt_copy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRtCopy) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.rt_copy_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.rt_copy_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecUpdate::release_rt_copy() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.rt_copy)
  if (action_case() == kRtCopy) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_copy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.rt_copy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& FlowspecUpdate::_internal_rt_copy() const {
  return action_case() == kRtCopy ? *_impl_.action_.rt_copy_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy&>(::kentik::ktbgp::v202501::_FlowspecActionIPNextHopCopy_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy& FlowspecUpdate::rt_copy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.rt_copy)
  return _internal_rt_copy();
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecUpdate::unsafe_arena_release_rt_copy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.rt_copy)
  if (action_case() == kRtCopy) {
    clear_has_action();
    auto* temp = _impl_.action_.rt_copy_;
    _impl_.action_.rt_copy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_rt_copy(::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_rt_copy();
    _impl_.action_.rt_copy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.rt_copy)
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecUpdate::_internal_mutable_rt_copy() {
  if (action_case() != kRtCopy) {
    clear_action();
    set_has_rt_copy();
    _impl_.action_.rt_copy_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy>(GetArena());
  }
  return _impl_.action_.rt_copy_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* FlowspecUpdate::mutable_rt_copy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionIPNextHopCopy* _msg = _internal_mutable_rt_copy();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.rt_copy)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionRegularCommunity regular_community = 19 [json_name = "regularCommunity"];
inline bool FlowspecUpdate::has_regular_community() const {
  return action_case() == kRegularCommunity;
}
inline bool FlowspecUpdate::_internal_has_regular_community() const {
  return action_case() == kRegularCommunity;
}
inline void FlowspecUpdate::set_has_regular_community() {
  _impl_._oneof_case_[0] = kRegularCommunity;
}
inline void FlowspecUpdate::clear_regular_community() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kRegularCommunity) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.regular_community_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.regular_community_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecUpdate::release_regular_community() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.regular_community)
  if (action_case() == kRegularCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.regular_community_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.regular_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& FlowspecUpdate::_internal_regular_community() const {
  return action_case() == kRegularCommunity ? *_impl_.action_.regular_community_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionRegularCommunity&>(::kentik::ktbgp::v202501::_FlowspecActionRegularCommunity_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity& FlowspecUpdate::regular_community() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.regular_community)
  return _internal_regular_community();
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecUpdate::unsafe_arena_release_regular_community() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.regular_community)
  if (action_case() == kRegularCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.regular_community_;
    _impl_.action_.regular_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_regular_community(::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_regular_community();
    _impl_.action_.regular_community_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.regular_community)
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecUpdate::_internal_mutable_regular_community() {
  if (action_case() != kRegularCommunity) {
    clear_action();
    set_has_regular_community();
    _impl_.action_.regular_community_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionRegularCommunity>(GetArena());
  }
  return _impl_.action_.regular_community_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* FlowspecUpdate::mutable_regular_community() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionRegularCommunity* _msg = _internal_mutable_regular_community();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.regular_community)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionExtendedCommunity extended_community = 20 [json_name = "extendedCommunity"];
inline bool FlowspecUpdate::has_extended_community() const {
  return action_case() == kExtendedCommunity;
}
inline bool FlowspecUpdate::_internal_has_extended_community() const {
  return action_case() == kExtendedCommunity;
}
inline void FlowspecUpdate::set_has_extended_community() {
  _impl_._oneof_case_[0] = kExtendedCommunity;
}
inline void FlowspecUpdate::clear_extended_community() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kExtendedCommunity) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.extended_community_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.extended_community_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecUpdate::release_extended_community() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.extended_community)
  if (action_case() == kExtendedCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.extended_community_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.extended_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& FlowspecUpdate::_internal_extended_community() const {
  return action_case() == kExtendedCommunity ? *_impl_.action_.extended_community_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity&>(::kentik::ktbgp::v202501::_FlowspecActionExtendedCommunity_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity& FlowspecUpdate::extended_community() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.extended_community)
  return _internal_extended_community();
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecUpdate::unsafe_arena_release_extended_community() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.extended_community)
  if (action_case() == kExtendedCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.extended_community_;
    _impl_.action_.extended_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_extended_community(::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_extended_community();
    _impl_.action_.extended_community_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.extended_community)
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecUpdate::_internal_mutable_extended_community() {
  if (action_case() != kExtendedCommunity) {
    clear_action();
    set_has_extended_community();
    _impl_.action_.extended_community_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity>(GetArena());
  }
  return _impl_.action_.extended_community_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* FlowspecUpdate::mutable_extended_community() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionExtendedCommunity* _msg = _internal_mutable_extended_community();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.extended_community)
  return _msg;
}

// .kentik.ktbgp.v202501.FlowspecActionLargeCommunity large_community = 21 [json_name = "largeCommunity"];
inline bool FlowspecUpdate::has_large_community() const {
  return action_case() == kLargeCommunity;
}
inline bool FlowspecUpdate::_internal_has_large_community() const {
  return action_case() == kLargeCommunity;
}
inline void FlowspecUpdate::set_has_large_community() {
  _impl_._oneof_case_[0] = kLargeCommunity;
}
inline void FlowspecUpdate::clear_large_community() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (action_case() == kLargeCommunity) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.large_community_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.action_.large_community_);
    }
    clear_has_action();
  }
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecUpdate::release_large_community() {
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecUpdate.large_community)
  if (action_case() == kLargeCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.large_community_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.large_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& FlowspecUpdate::_internal_large_community() const {
  return action_case() == kLargeCommunity ? *_impl_.action_.large_community_ : reinterpret_cast<::kentik::ktbgp::v202501::FlowspecActionLargeCommunity&>(::kentik::ktbgp::v202501::_FlowspecActionLargeCommunity_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity& FlowspecUpdate::large_community() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.large_community)
  return _internal_large_community();
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecUpdate::unsafe_arena_release_large_community() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.ktbgp.v202501.FlowspecUpdate.large_community)
  if (action_case() == kLargeCommunity) {
    clear_has_action();
    auto* temp = _impl_.action_.large_community_;
    _impl_.action_.large_community_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowspecUpdate::unsafe_arena_set_allocated_large_community(::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_large_community();
    _impl_.action_.large_community_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecUpdate.large_community)
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecUpdate::_internal_mutable_large_community() {
  if (action_case() != kLargeCommunity) {
    clear_action();
    set_has_large_community();
    _impl_.action_.large_community_ =
        ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FlowspecActionLargeCommunity>(GetArena());
  }
  return _impl_.action_.large_community_;
}
inline ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* FlowspecUpdate::mutable_large_community() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::kentik::ktbgp::v202501::FlowspecActionLargeCommunity* _msg = _internal_mutable_large_community();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.large_community)
  return _msg;
}

// repeated .kentik.ktbgp.v202501.FlowspecAction actions = 8 [json_name = "actions"];
inline int FlowspecUpdate::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int FlowspecUpdate::actions_size() const {
  return _internal_actions_size();
}
inline void FlowspecUpdate::clear_actions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actions_.Clear();
}
inline ::kentik::ktbgp::v202501::FlowspecAction* FlowspecUpdate::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdate.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>* FlowspecUpdate::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.FlowspecUpdate.actions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_actions();
}
inline const ::kentik::ktbgp::v202501::FlowspecAction& FlowspecUpdate::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.actions)
  return _internal_actions().Get(index);
}
inline ::kentik::ktbgp::v202501::FlowspecAction* FlowspecUpdate::add_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::FlowspecAction* _add = _internal_mutable_actions()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.FlowspecUpdate.actions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>& FlowspecUpdate::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.FlowspecUpdate.actions)
  return _internal_actions();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>&
FlowspecUpdate::_internal_actions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecAction>*
FlowspecUpdate::_internal_mutable_actions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.actions_;
}

// bool terminal = 4 [json_name = "terminal", deprecated = true];
inline void FlowspecUpdate::clear_terminal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminal_ = false;
}
inline bool FlowspecUpdate::terminal() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.terminal)
  return _internal_terminal();
}
inline void FlowspecUpdate::set_terminal(bool value) {
  _internal_set_terminal(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecUpdate.terminal)
}
inline bool FlowspecUpdate::_internal_terminal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.terminal_;
}
inline void FlowspecUpdate::_internal_set_terminal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminal_ = value;
}

// bool sample = 5 [json_name = "sample", deprecated = true];
inline void FlowspecUpdate::clear_sample() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_ = false;
}
inline bool FlowspecUpdate::sample() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdate.sample)
  return _internal_sample();
}
inline void FlowspecUpdate::set_sample(bool value) {
  _internal_set_sample(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecUpdate.sample)
}
inline bool FlowspecUpdate::_internal_sample() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_;
}
inline void FlowspecUpdate::_internal_set_sample(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_ = value;
}

inline bool FlowspecUpdate::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void FlowspecUpdate::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline FlowspecUpdate::ActionCase FlowspecUpdate::action_case() const {
  return FlowspecUpdate::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FlowspecUpdates

// repeated .kentik.ktbgp.v202501.FlowspecUpdate update = 1 [json_name = "update"];
inline int FlowspecUpdates::_internal_update_size() const {
  return _internal_update().size();
}
inline int FlowspecUpdates::update_size() const {
  return _internal_update_size();
}
inline void FlowspecUpdates::clear_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_.Clear();
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* FlowspecUpdates::mutable_update(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecUpdates.update)
  return _internal_mutable_update()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>* FlowspecUpdates::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.FlowspecUpdates.update)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_update();
}
inline const ::kentik::ktbgp::v202501::FlowspecUpdate& FlowspecUpdates::update(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecUpdates.update)
  return _internal_update().Get(index);
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* FlowspecUpdates::add_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::FlowspecUpdate* _add = _internal_mutable_update()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.FlowspecUpdates.update)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>& FlowspecUpdates::update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.FlowspecUpdates.update)
  return _internal_update();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>&
FlowspecUpdates::_internal_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>*
FlowspecUpdates::_internal_mutable_update() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.update_;
}

// -------------------------------------------------------------------

// RTBHUpdate

// .kentik.ktbgp.v202501.RTBHMatch match = 1 [json_name = "match"];
inline bool RTBHUpdate::has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline void RTBHUpdate::clear_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::ktbgp::v202501::RTBHMatch& RTBHUpdate::_internal_match() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::RTBHMatch* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::RTBHMatch&>(::kentik::ktbgp::v202501::_RTBHMatch_default_instance_);
}
inline const ::kentik::ktbgp::v202501::RTBHMatch& RTBHUpdate::match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdate.match)
  return _internal_match();
}
inline void RTBHUpdate::unsafe_arena_set_allocated_match(::kentik::ktbgp::v202501::RTBHMatch* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = reinterpret_cast<::kentik::ktbgp::v202501::RTBHMatch*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.match)
}
inline ::kentik::ktbgp::v202501::RTBHMatch* RTBHUpdate::release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::RTBHMatch* released = _impl_.match_;
  _impl_.match_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::RTBHMatch* RTBHUpdate::unsafe_arena_release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHUpdate.match)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::RTBHMatch* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::RTBHMatch* RTBHUpdate::_internal_mutable_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::RTBHMatch>(GetArena());
    _impl_.match_ = reinterpret_cast<::kentik::ktbgp::v202501::RTBHMatch*>(p);
  }
  return _impl_.match_;
}
inline ::kentik::ktbgp::v202501::RTBHMatch* RTBHUpdate::mutable_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::ktbgp::v202501::RTBHMatch* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHUpdate.match)
  return _msg;
}
inline void RTBHUpdate::set_allocated_match(::kentik::ktbgp::v202501::RTBHMatch* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.match_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.match_ = reinterpret_cast<::kentik::ktbgp::v202501::RTBHMatch*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.match)
}

// .kentik.ktbgp.v202501.RTBHAction action = 2 [json_name = "action"];
inline bool RTBHUpdate::has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.action_ != nullptr);
  return value;
}
inline void RTBHUpdate::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.action_ != nullptr) _impl_.action_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::ktbgp::v202501::RTBHAction& RTBHUpdate::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::RTBHAction* p = _impl_.action_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::RTBHAction&>(::kentik::ktbgp::v202501::_RTBHAction_default_instance_);
}
inline const ::kentik::ktbgp::v202501::RTBHAction& RTBHUpdate::action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdate.action)
  return _internal_action();
}
inline void RTBHUpdate::unsafe_arena_set_allocated_action(::kentik::ktbgp::v202501::RTBHAction* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.action_);
  }
  _impl_.action_ = reinterpret_cast<::kentik::ktbgp::v202501::RTBHAction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.action)
}
inline ::kentik::ktbgp::v202501::RTBHAction* RTBHUpdate::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::ktbgp::v202501::RTBHAction* released = _impl_.action_;
  _impl_.action_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::RTBHAction* RTBHUpdate::unsafe_arena_release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHUpdate.action)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::ktbgp::v202501::RTBHAction* temp = _impl_.action_;
  _impl_.action_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::RTBHAction* RTBHUpdate::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.action_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::RTBHAction>(GetArena());
    _impl_.action_ = reinterpret_cast<::kentik::ktbgp::v202501::RTBHAction*>(p);
  }
  return _impl_.action_;
}
inline ::kentik::ktbgp::v202501::RTBHAction* RTBHUpdate::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::ktbgp::v202501::RTBHAction* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHUpdate.action)
  return _msg;
}
inline void RTBHUpdate::set_allocated_action(::kentik::ktbgp::v202501::RTBHAction* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.action_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.action_ = reinterpret_cast<::kentik::ktbgp::v202501::RTBHAction*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.action)
}

// .google.protobuf.Timestamp creation_time = 3 [json_name = "creationTime"];
inline bool RTBHUpdate::has_creation_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creation_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RTBHUpdate::_internal_creation_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.creation_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RTBHUpdate::creation_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdate.creation_time)
  return _internal_creation_time();
}
inline void RTBHUpdate::unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }
  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.creation_time)
}
inline ::google::protobuf::Timestamp* RTBHUpdate::release_creation_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* RTBHUpdate::unsafe_arena_release_creation_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHUpdate.creation_time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RTBHUpdate::_internal_mutable_creation_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.creation_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.creation_time_;
}
inline ::google::protobuf::Timestamp* RTBHUpdate::mutable_creation_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_creation_time();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHUpdate.creation_time)
  return _msg;
}
inline void RTBHUpdate::set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.creation_time)
}

// string inet = 4 [json_name = "inet", deprecated = true];
inline void RTBHUpdate::clear_inet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.ClearToEmpty();
}
inline const std::string& RTBHUpdate::inet() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdate.inet)
  return _internal_inet();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RTBHUpdate::set_inet(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHUpdate.inet)
}
inline std::string* RTBHUpdate::mutable_inet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_inet();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHUpdate.inet)
  return _s;
}
inline const std::string& RTBHUpdate::_internal_inet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inet_.Get();
}
inline void RTBHUpdate::_internal_set_inet(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.Set(value, GetArena());
}
inline std::string* RTBHUpdate::_internal_mutable_inet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.inet_.Mutable( GetArena());
}
inline std::string* RTBHUpdate::release_inet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHUpdate.inet)
  return _impl_.inet_.Release();
}
inline void RTBHUpdate::set_allocated_inet(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.inet_.IsDefault()) {
    _impl_.inet_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.inet)
}

// .kentik.ktbgp.v202501.InetType inet_type = 5 [json_name = "inetType"];
inline void RTBHUpdate::clear_inet_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_type_ = 0;
}
inline ::kentik::ktbgp::v202501::InetType RTBHUpdate::inet_type() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdate.inet_type)
  return _internal_inet_type();
}
inline void RTBHUpdate::set_inet_type(::kentik::ktbgp::v202501::InetType value) {
  _internal_set_inet_type(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHUpdate.inet_type)
}
inline ::kentik::ktbgp::v202501::InetType RTBHUpdate::_internal_inet_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::InetType>(_impl_.inet_type_);
}
inline void RTBHUpdate::_internal_set_inet_type(::kentik::ktbgp::v202501::InetType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inet_type_ = value;
}

// string key = 6 [json_name = "key"];
inline void RTBHUpdate::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RTBHUpdate::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdate.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RTBHUpdate::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHUpdate.key)
}
inline std::string* RTBHUpdate::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHUpdate.key)
  return _s;
}
inline const std::string& RTBHUpdate::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void RTBHUpdate::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* RTBHUpdate::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* RTBHUpdate::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHUpdate.key)
  return _impl_.key_.Release();
}
inline void RTBHUpdate::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHUpdate.key)
}

// -------------------------------------------------------------------

// RTBHUpdates

// repeated .kentik.ktbgp.v202501.RTBHUpdate update = 1 [json_name = "update"];
inline int RTBHUpdates::_internal_update_size() const {
  return _internal_update().size();
}
inline int RTBHUpdates::update_size() const {
  return _internal_update_size();
}
inline void RTBHUpdates::clear_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_.Clear();
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* RTBHUpdates::mutable_update(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHUpdates.update)
  return _internal_mutable_update()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>* RTBHUpdates::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RTBHUpdates.update)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_update();
}
inline const ::kentik::ktbgp::v202501::RTBHUpdate& RTBHUpdates::update(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHUpdates.update)
  return _internal_update().Get(index);
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* RTBHUpdates::add_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::RTBHUpdate* _add = _internal_mutable_update()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RTBHUpdates.update)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>& RTBHUpdates::update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RTBHUpdates.update)
  return _internal_update();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>&
RTBHUpdates::_internal_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>*
RTBHUpdates::_internal_mutable_update() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.update_;
}

// -------------------------------------------------------------------

// FlowspecMatch

// string dst_prefix = 1 [json_name = "dstPrefix"];
inline void FlowspecMatch::clear_dst_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_prefix_.ClearToEmpty();
}
inline const std::string& FlowspecMatch::dst_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.dst_prefix)
  return _internal_dst_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowspecMatch::set_dst_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecMatch.dst_prefix)
}
inline std::string* FlowspecMatch::mutable_dst_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dst_prefix();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.dst_prefix)
  return _s;
}
inline const std::string& FlowspecMatch::_internal_dst_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dst_prefix_.Get();
}
inline void FlowspecMatch::_internal_set_dst_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_prefix_.Set(value, GetArena());
}
inline std::string* FlowspecMatch::_internal_mutable_dst_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dst_prefix_.Mutable( GetArena());
}
inline std::string* FlowspecMatch::release_dst_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.dst_prefix)
  return _impl_.dst_prefix_.Release();
}
inline void FlowspecMatch::set_allocated_dst_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dst_prefix_.IsDefault()) {
    _impl_.dst_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.dst_prefix)
}

// string src_prefix = 2 [json_name = "srcPrefix"];
inline void FlowspecMatch::clear_src_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.ClearToEmpty();
}
inline const std::string& FlowspecMatch::src_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.src_prefix)
  return _internal_src_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowspecMatch::set_src_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecMatch.src_prefix)
}
inline std::string* FlowspecMatch::mutable_src_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_prefix();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.src_prefix)
  return _s;
}
inline const std::string& FlowspecMatch::_internal_src_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_prefix_.Get();
}
inline void FlowspecMatch::_internal_set_src_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.Set(value, GetArena());
}
inline std::string* FlowspecMatch::_internal_mutable_src_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.src_prefix_.Mutable( GetArena());
}
inline std::string* FlowspecMatch::release_src_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.src_prefix)
  return _impl_.src_prefix_.Release();
}
inline void FlowspecMatch::set_allocated_src_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.src_prefix_.IsDefault()) {
    _impl_.src_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.src_prefix)
}

// .kentik.ktbgp.v202501.NumericFormula ip_protocol = 3 [json_name = "ipProtocol"];
inline bool FlowspecMatch::has_ip_protocol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ip_protocol_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_ip_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ip_protocol_ != nullptr) _impl_.ip_protocol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_ip_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.ip_protocol_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::ip_protocol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.ip_protocol)
  return _internal_ip_protocol();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_ip_protocol(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ip_protocol_);
  }
  _impl_.ip_protocol_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.ip_protocol)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_ip_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.ip_protocol_;
  _impl_.ip_protocol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_ip_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.ip_protocol)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.ip_protocol_;
  _impl_.ip_protocol_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_ip_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ip_protocol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.ip_protocol_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.ip_protocol_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_ip_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_ip_protocol();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.ip_protocol)
  return _msg;
}
inline void FlowspecMatch::set_allocated_ip_protocol(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ip_protocol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ip_protocol_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.ip_protocol)
}

// .kentik.ktbgp.v202501.NumericFormula dst_port = 5 [json_name = "dstPort"];
inline bool FlowspecMatch::has_dst_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_port_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_dst_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dst_port_ != nullptr) _impl_.dst_port_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_dst_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.dst_port_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::dst_port() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.dst_port)
  return _internal_dst_port();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_dst_port(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dst_port_);
  }
  _impl_.dst_port_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.dst_port)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_dst_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.dst_port_;
  _impl_.dst_port_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_dst_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.dst_port)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.dst_port_;
  _impl_.dst_port_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_dst_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dst_port_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.dst_port_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.dst_port_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_dst_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_dst_port();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.dst_port)
  return _msg;
}
inline void FlowspecMatch::set_allocated_dst_port(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dst_port_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dst_port_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.dst_port)
}

// .kentik.ktbgp.v202501.NumericFormula src_port = 6 [json_name = "srcPort"];
inline bool FlowspecMatch::has_src_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_port_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_src_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.src_port_ != nullptr) _impl_.src_port_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_src_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.src_port_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::src_port() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.src_port)
  return _internal_src_port();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_src_port(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.src_port_);
  }
  _impl_.src_port_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.src_port)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_src_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.src_port_;
  _impl_.src_port_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_src_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.src_port)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.src_port_;
  _impl_.src_port_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_src_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.src_port_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.src_port_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.src_port_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_src_port() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_src_port();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.src_port)
  return _msg;
}
inline void FlowspecMatch::set_allocated_src_port(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.src_port_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.src_port_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.src_port)
}

// .kentik.ktbgp.v202501.NumericFormula icmp_type = 7 [json_name = "icmpType"];
inline bool FlowspecMatch::has_icmp_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.icmp_type_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_icmp_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.icmp_type_ != nullptr) _impl_.icmp_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_icmp_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.icmp_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::icmp_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.icmp_type)
  return _internal_icmp_type();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_icmp_type(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.icmp_type_);
  }
  _impl_.icmp_type_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.icmp_type)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_icmp_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.icmp_type_;
  _impl_.icmp_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_icmp_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.icmp_type)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.icmp_type_;
  _impl_.icmp_type_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_icmp_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.icmp_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.icmp_type_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.icmp_type_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_icmp_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_icmp_type();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.icmp_type)
  return _msg;
}
inline void FlowspecMatch::set_allocated_icmp_type(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.icmp_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.icmp_type_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.icmp_type)
}

// .kentik.ktbgp.v202501.NumericFormula icmp_code = 8 [json_name = "icmpCode"];
inline bool FlowspecMatch::has_icmp_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.icmp_code_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_icmp_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.icmp_code_ != nullptr) _impl_.icmp_code_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_icmp_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.icmp_code_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::icmp_code() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.icmp_code)
  return _internal_icmp_code();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_icmp_code(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.icmp_code_);
  }
  _impl_.icmp_code_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.icmp_code)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_icmp_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.icmp_code_;
  _impl_.icmp_code_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_icmp_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.icmp_code)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.icmp_code_;
  _impl_.icmp_code_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_icmp_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.icmp_code_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.icmp_code_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.icmp_code_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_icmp_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_icmp_code();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.icmp_code)
  return _msg;
}
inline void FlowspecMatch::set_allocated_icmp_code(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.icmp_code_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.icmp_code_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.icmp_code)
}

// .kentik.ktbgp.v202501.TCPFlagsFormula tcp_flags = 9 [json_name = "tcpFlags"];
inline bool FlowspecMatch::has_tcp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tcp_flags_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_tcp_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tcp_flags_ != nullptr) _impl_.tcp_flags_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::kentik::ktbgp::v202501::TCPFlagsFormula& FlowspecMatch::_internal_tcp_flags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::TCPFlagsFormula* p = _impl_.tcp_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::TCPFlagsFormula&>(::kentik::ktbgp::v202501::_TCPFlagsFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::TCPFlagsFormula& FlowspecMatch::tcp_flags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.tcp_flags)
  return _internal_tcp_flags();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_tcp_flags(::kentik::ktbgp::v202501::TCPFlagsFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tcp_flags_);
  }
  _impl_.tcp_flags_ = reinterpret_cast<::kentik::ktbgp::v202501::TCPFlagsFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.tcp_flags)
}
inline ::kentik::ktbgp::v202501::TCPFlagsFormula* FlowspecMatch::release_tcp_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::kentik::ktbgp::v202501::TCPFlagsFormula* released = _impl_.tcp_flags_;
  _impl_.tcp_flags_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::TCPFlagsFormula* FlowspecMatch::unsafe_arena_release_tcp_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.tcp_flags)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::kentik::ktbgp::v202501::TCPFlagsFormula* temp = _impl_.tcp_flags_;
  _impl_.tcp_flags_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::TCPFlagsFormula* FlowspecMatch::_internal_mutable_tcp_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tcp_flags_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::TCPFlagsFormula>(GetArena());
    _impl_.tcp_flags_ = reinterpret_cast<::kentik::ktbgp::v202501::TCPFlagsFormula*>(p);
  }
  return _impl_.tcp_flags_;
}
inline ::kentik::ktbgp::v202501::TCPFlagsFormula* FlowspecMatch::mutable_tcp_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::kentik::ktbgp::v202501::TCPFlagsFormula* _msg = _internal_mutable_tcp_flags();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.tcp_flags)
  return _msg;
}
inline void FlowspecMatch::set_allocated_tcp_flags(::kentik::ktbgp::v202501::TCPFlagsFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tcp_flags_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.tcp_flags_ = reinterpret_cast<::kentik::ktbgp::v202501::TCPFlagsFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.tcp_flags)
}

// .kentik.ktbgp.v202501.NumericFormula packet_length = 10 [json_name = "packetLength"];
inline bool FlowspecMatch::has_packet_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_length_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_packet_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.packet_length_ != nullptr) _impl_.packet_length_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_packet_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.packet_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::packet_length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.packet_length)
  return _internal_packet_length();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_packet_length(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_length_);
  }
  _impl_.packet_length_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.packet_length)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_packet_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_packet_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.packet_length)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_packet_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.packet_length_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.packet_length_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.packet_length_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_packet_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_packet_length();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.packet_length)
  return _msg;
}
inline void FlowspecMatch::set_allocated_packet_length(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.packet_length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.packet_length_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.packet_length)
}

// .kentik.ktbgp.v202501.NumericFormula dscp = 11 [json_name = "dscp"];
inline bool FlowspecMatch::has_dscp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dscp_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dscp_ != nullptr) _impl_.dscp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::_internal_dscp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::NumericFormula* p = _impl_.dscp_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::NumericFormula&>(::kentik::ktbgp::v202501::_NumericFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::NumericFormula& FlowspecMatch::dscp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.dscp)
  return _internal_dscp();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_dscp(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dscp_);
  }
  _impl_.dscp_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.dscp)
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::release_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::kentik::ktbgp::v202501::NumericFormula* released = _impl_.dscp_;
  _impl_.dscp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::unsafe_arena_release_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.dscp)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::kentik::ktbgp::v202501::NumericFormula* temp = _impl_.dscp_;
  _impl_.dscp_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::_internal_mutable_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dscp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::NumericFormula>(GetArena());
    _impl_.dscp_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(p);
  }
  return _impl_.dscp_;
}
inline ::kentik::ktbgp::v202501::NumericFormula* FlowspecMatch::mutable_dscp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::kentik::ktbgp::v202501::NumericFormula* _msg = _internal_mutable_dscp();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.dscp)
  return _msg;
}
inline void FlowspecMatch::set_allocated_dscp(::kentik::ktbgp::v202501::NumericFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dscp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.dscp_ = reinterpret_cast<::kentik::ktbgp::v202501::NumericFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.dscp)
}

// .kentik.ktbgp.v202501.FragmentFormula fragments = 12 [json_name = "fragments"];
inline bool FlowspecMatch::has_fragments() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fragments_ != nullptr);
  return value;
}
inline void FlowspecMatch::clear_fragments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fragments_ != nullptr) _impl_.fragments_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::kentik::ktbgp::v202501::FragmentFormula& FlowspecMatch::_internal_fragments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::FragmentFormula* p = _impl_.fragments_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::FragmentFormula&>(::kentik::ktbgp::v202501::_FragmentFormula_default_instance_);
}
inline const ::kentik::ktbgp::v202501::FragmentFormula& FlowspecMatch::fragments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecMatch.fragments)
  return _internal_fragments();
}
inline void FlowspecMatch::unsafe_arena_set_allocated_fragments(::kentik::ktbgp::v202501::FragmentFormula* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fragments_);
  }
  _impl_.fragments_ = reinterpret_cast<::kentik::ktbgp::v202501::FragmentFormula*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.fragments)
}
inline ::kentik::ktbgp::v202501::FragmentFormula* FlowspecMatch::release_fragments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::kentik::ktbgp::v202501::FragmentFormula* released = _impl_.fragments_;
  _impl_.fragments_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::FragmentFormula* FlowspecMatch::unsafe_arena_release_fragments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecMatch.fragments)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::kentik::ktbgp::v202501::FragmentFormula* temp = _impl_.fragments_;
  _impl_.fragments_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::FragmentFormula* FlowspecMatch::_internal_mutable_fragments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fragments_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::FragmentFormula>(GetArena());
    _impl_.fragments_ = reinterpret_cast<::kentik::ktbgp::v202501::FragmentFormula*>(p);
  }
  return _impl_.fragments_;
}
inline ::kentik::ktbgp::v202501::FragmentFormula* FlowspecMatch::mutable_fragments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::kentik::ktbgp::v202501::FragmentFormula* _msg = _internal_mutable_fragments();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecMatch.fragments)
  return _msg;
}
inline void FlowspecMatch::set_allocated_fragments(::kentik::ktbgp::v202501::FragmentFormula* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.fragments_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.fragments_ = reinterpret_cast<::kentik::ktbgp::v202501::FragmentFormula*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecMatch.fragments)
}

// -------------------------------------------------------------------

// FlowspecActionTrafficRateBytes

// float bytes_per_second = 1 [json_name = "bytesPerSecond"];
inline void FlowspecActionTrafficRateBytes::clear_bytes_per_second() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bytes_per_second_ = 0;
}
inline float FlowspecActionTrafficRateBytes::bytes_per_second() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes.bytes_per_second)
  return _internal_bytes_per_second();
}
inline void FlowspecActionTrafficRateBytes::set_bytes_per_second(float value) {
  _internal_set_bytes_per_second(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionTrafficRateBytes.bytes_per_second)
}
inline float FlowspecActionTrafficRateBytes::_internal_bytes_per_second() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bytes_per_second_;
}
inline void FlowspecActionTrafficRateBytes::_internal_set_bytes_per_second(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bytes_per_second_ = value;
}

// -------------------------------------------------------------------

// FlowspecActionAccept

// -------------------------------------------------------------------

// FlowspecActionDiscard

// -------------------------------------------------------------------

// FlowspecActionTerminalSample

// bool terminal = 1 [json_name = "terminal"];
inline void FlowspecActionTerminalSample::clear_terminal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminal_ = false;
}
inline bool FlowspecActionTerminalSample::terminal() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionTerminalSample.terminal)
  return _internal_terminal();
}
inline void FlowspecActionTerminalSample::set_terminal(bool value) {
  _internal_set_terminal(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionTerminalSample.terminal)
}
inline bool FlowspecActionTerminalSample::_internal_terminal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.terminal_;
}
inline void FlowspecActionTerminalSample::_internal_set_terminal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminal_ = value;
}

// bool sample = 2 [json_name = "sample"];
inline void FlowspecActionTerminalSample::clear_sample() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_ = false;
}
inline bool FlowspecActionTerminalSample::sample() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionTerminalSample.sample)
  return _internal_sample();
}
inline void FlowspecActionTerminalSample::set_sample(bool value) {
  _internal_set_sample(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionTerminalSample.sample)
}
inline bool FlowspecActionTerminalSample::_internal_sample() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_;
}
inline void FlowspecActionTerminalSample::_internal_set_sample(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_ = value;
}

// -------------------------------------------------------------------

// FlowspecActionMarkDSCP

// uint32 dscp = 1 [json_name = "dscp"];
inline void FlowspecActionMarkDSCP::clear_dscp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dscp_ = 0u;
}
inline ::uint32_t FlowspecActionMarkDSCP::dscp() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionMarkDSCP.dscp)
  return _internal_dscp();
}
inline void FlowspecActionMarkDSCP::set_dscp(::uint32_t value) {
  _internal_set_dscp(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionMarkDSCP.dscp)
}
inline ::uint32_t FlowspecActionMarkDSCP::_internal_dscp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dscp_;
}
inline void FlowspecActionMarkDSCP::_internal_set_dscp(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dscp_ = value;
}

// -------------------------------------------------------------------

// FlowspecActionRouteTargetRedirect

// uint32 asn = 1 [json_name = "asn"];
inline void FlowspecActionRouteTargetRedirect::clear_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = 0u;
}
inline ::uint32_t FlowspecActionRouteTargetRedirect::asn() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect.asn)
  return _internal_asn();
}
inline void FlowspecActionRouteTargetRedirect::set_asn(::uint32_t value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect.asn)
}
inline ::uint32_t FlowspecActionRouteTargetRedirect::_internal_asn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn_;
}
inline void FlowspecActionRouteTargetRedirect::_internal_set_asn(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = value;
}

// uint32 route_target = 2 [json_name = "routeTarget"];
inline void FlowspecActionRouteTargetRedirect::clear_route_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_target_ = 0u;
}
inline ::uint32_t FlowspecActionRouteTargetRedirect::route_target() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect.route_target)
  return _internal_route_target();
}
inline void FlowspecActionRouteTargetRedirect::set_route_target(::uint32_t value) {
  _internal_set_route_target(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionRouteTargetRedirect.route_target)
}
inline ::uint32_t FlowspecActionRouteTargetRedirect::_internal_route_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.route_target_;
}
inline void FlowspecActionRouteTargetRedirect::_internal_set_route_target(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_target_ = value;
}

// -------------------------------------------------------------------

// FlowspecActionIPNextHopRedirect

// string next_hop = 1 [json_name = "nextHop"];
inline void FlowspecActionIPNextHopRedirect::clear_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.ClearToEmpty();
}
inline const std::string& FlowspecActionIPNextHopRedirect::next_hop() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect.next_hop)
  return _internal_next_hop();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowspecActionIPNextHopRedirect::set_next_hop(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect.next_hop)
}
inline std::string* FlowspecActionIPNextHopRedirect::mutable_next_hop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_hop();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect.next_hop)
  return _s;
}
inline const std::string& FlowspecActionIPNextHopRedirect::_internal_next_hop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_hop_.Get();
}
inline void FlowspecActionIPNextHopRedirect::_internal_set_next_hop(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.Set(value, GetArena());
}
inline std::string* FlowspecActionIPNextHopRedirect::_internal_mutable_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_hop_.Mutable( GetArena());
}
inline std::string* FlowspecActionIPNextHopRedirect::release_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect.next_hop)
  return _impl_.next_hop_.Release();
}
inline void FlowspecActionIPNextHopRedirect::set_allocated_next_hop(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_hop_.IsDefault()) {
    _impl_.next_hop_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecActionIPNextHopRedirect.next_hop)
}

// -------------------------------------------------------------------

// FlowspecActionIPNextHopCopy

// string next_hop = 1 [json_name = "nextHop"];
inline void FlowspecActionIPNextHopCopy::clear_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.ClearToEmpty();
}
inline const std::string& FlowspecActionIPNextHopCopy::next_hop() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy.next_hop)
  return _internal_next_hop();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowspecActionIPNextHopCopy::set_next_hop(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy.next_hop)
}
inline std::string* FlowspecActionIPNextHopCopy::mutable_next_hop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_hop();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy.next_hop)
  return _s;
}
inline const std::string& FlowspecActionIPNextHopCopy::_internal_next_hop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_hop_.Get();
}
inline void FlowspecActionIPNextHopCopy::_internal_set_next_hop(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.Set(value, GetArena());
}
inline std::string* FlowspecActionIPNextHopCopy::_internal_mutable_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_hop_.Mutable( GetArena());
}
inline std::string* FlowspecActionIPNextHopCopy::release_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy.next_hop)
  return _impl_.next_hop_.Release();
}
inline void FlowspecActionIPNextHopCopy::set_allocated_next_hop(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_hop_.IsDefault()) {
    _impl_.next_hop_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.FlowspecActionIPNextHopCopy.next_hop)
}

// -------------------------------------------------------------------

// FlowspecActionRegularCommunity

// uint32 asn1 = 1 [json_name = "asn1"];
inline void FlowspecActionRegularCommunity::clear_asn1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn1_ = 0u;
}
inline ::uint32_t FlowspecActionRegularCommunity::asn1() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionRegularCommunity.asn1)
  return _internal_asn1();
}
inline void FlowspecActionRegularCommunity::set_asn1(::uint32_t value) {
  _internal_set_asn1(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionRegularCommunity.asn1)
}
inline ::uint32_t FlowspecActionRegularCommunity::_internal_asn1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn1_;
}
inline void FlowspecActionRegularCommunity::_internal_set_asn1(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn1_ = value;
}

// uint32 asn2 = 2 [json_name = "asn2"];
inline void FlowspecActionRegularCommunity::clear_asn2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn2_ = 0u;
}
inline ::uint32_t FlowspecActionRegularCommunity::asn2() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionRegularCommunity.asn2)
  return _internal_asn2();
}
inline void FlowspecActionRegularCommunity::set_asn2(::uint32_t value) {
  _internal_set_asn2(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionRegularCommunity.asn2)
}
inline ::uint32_t FlowspecActionRegularCommunity::_internal_asn2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn2_;
}
inline void FlowspecActionRegularCommunity::_internal_set_asn2(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn2_ = value;
}

// -------------------------------------------------------------------

// FlowspecActionExtendedCommunity

// .kentik.ktbgp.v202501.ExtendedCommunityRouteType route_type = 1 [json_name = "routeType"];
inline void FlowspecActionExtendedCommunity::clear_route_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_type_ = 0;
}
inline ::kentik::ktbgp::v202501::ExtendedCommunityRouteType FlowspecActionExtendedCommunity::route_type() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity.route_type)
  return _internal_route_type();
}
inline void FlowspecActionExtendedCommunity::set_route_type(::kentik::ktbgp::v202501::ExtendedCommunityRouteType value) {
  _internal_set_route_type(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity.route_type)
}
inline ::kentik::ktbgp::v202501::ExtendedCommunityRouteType FlowspecActionExtendedCommunity::_internal_route_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::ExtendedCommunityRouteType>(_impl_.route_type_);
}
inline void FlowspecActionExtendedCommunity::_internal_set_route_type(::kentik::ktbgp::v202501::ExtendedCommunityRouteType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_type_ = value;
}

// uint32 asn1 = 2 [json_name = "asn1"];
inline void FlowspecActionExtendedCommunity::clear_asn1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn1_ = 0u;
}
inline ::uint32_t FlowspecActionExtendedCommunity::asn1() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity.asn1)
  return _internal_asn1();
}
inline void FlowspecActionExtendedCommunity::set_asn1(::uint32_t value) {
  _internal_set_asn1(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity.asn1)
}
inline ::uint32_t FlowspecActionExtendedCommunity::_internal_asn1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn1_;
}
inline void FlowspecActionExtendedCommunity::_internal_set_asn1(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn1_ = value;
}

// uint32 asn2 = 3 [json_name = "asn2"];
inline void FlowspecActionExtendedCommunity::clear_asn2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn2_ = 0u;
}
inline ::uint32_t FlowspecActionExtendedCommunity::asn2() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity.asn2)
  return _internal_asn2();
}
inline void FlowspecActionExtendedCommunity::set_asn2(::uint32_t value) {
  _internal_set_asn2(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionExtendedCommunity.asn2)
}
inline ::uint32_t FlowspecActionExtendedCommunity::_internal_asn2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn2_;
}
inline void FlowspecActionExtendedCommunity::_internal_set_asn2(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn2_ = value;
}

// -------------------------------------------------------------------

// FlowspecActionLargeCommunity

// uint32 asn = 1 [json_name = "asn"];
inline void FlowspecActionLargeCommunity::clear_asn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = 0u;
}
inline ::uint32_t FlowspecActionLargeCommunity::asn() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionLargeCommunity.asn)
  return _internal_asn();
}
inline void FlowspecActionLargeCommunity::set_asn(::uint32_t value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionLargeCommunity.asn)
}
inline ::uint32_t FlowspecActionLargeCommunity::_internal_asn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asn_;
}
inline void FlowspecActionLargeCommunity::_internal_set_asn(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asn_ = value;
}

// uint32 data1 = 2 [json_name = "data1"];
inline void FlowspecActionLargeCommunity::clear_data1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data1_ = 0u;
}
inline ::uint32_t FlowspecActionLargeCommunity::data1() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionLargeCommunity.data1)
  return _internal_data1();
}
inline void FlowspecActionLargeCommunity::set_data1(::uint32_t value) {
  _internal_set_data1(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionLargeCommunity.data1)
}
inline ::uint32_t FlowspecActionLargeCommunity::_internal_data1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data1_;
}
inline void FlowspecActionLargeCommunity::_internal_set_data1(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data1_ = value;
}

// uint32 data2 = 3 [json_name = "data2"];
inline void FlowspecActionLargeCommunity::clear_data2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data2_ = 0u;
}
inline ::uint32_t FlowspecActionLargeCommunity::data2() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FlowspecActionLargeCommunity.data2)
  return _internal_data2();
}
inline void FlowspecActionLargeCommunity::set_data2(::uint32_t value) {
  _internal_set_data2(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FlowspecActionLargeCommunity.data2)
}
inline ::uint32_t FlowspecActionLargeCommunity::_internal_data2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data2_;
}
inline void FlowspecActionLargeCommunity::_internal_set_data2(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data2_ = value;
}

// -------------------------------------------------------------------

// RTBHMatch

// string src_prefix = 1 [json_name = "srcPrefix"];
inline void RTBHMatch::clear_src_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.ClearToEmpty();
}
inline const std::string& RTBHMatch::src_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHMatch.src_prefix)
  return _internal_src_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RTBHMatch::set_src_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHMatch.src_prefix)
}
inline std::string* RTBHMatch::mutable_src_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_prefix();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHMatch.src_prefix)
  return _s;
}
inline const std::string& RTBHMatch::_internal_src_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_prefix_.Get();
}
inline void RTBHMatch::_internal_set_src_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.Set(value, GetArena());
}
inline std::string* RTBHMatch::_internal_mutable_src_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.src_prefix_.Mutable( GetArena());
}
inline std::string* RTBHMatch::release_src_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHMatch.src_prefix)
  return _impl_.src_prefix_.Release();
}
inline void RTBHMatch::set_allocated_src_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.src_prefix_.IsDefault()) {
    _impl_.src_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHMatch.src_prefix)
}

// -------------------------------------------------------------------

// RTBHAction

// repeated uint32 bgp_communities = 1 [json_name = "bgpCommunities"];
inline int RTBHAction::_internal_bgp_communities_size() const {
  return _internal_bgp_communities().size();
}
inline int RTBHAction::bgp_communities_size() const {
  return _internal_bgp_communities_size();
}
inline void RTBHAction::clear_bgp_communities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bgp_communities_.Clear();
}
inline ::uint32_t RTBHAction::bgp_communities(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHAction.bgp_communities)
  return _internal_bgp_communities().Get(index);
}
inline void RTBHAction::set_bgp_communities(int index, ::uint32_t value) {
  _internal_mutable_bgp_communities()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHAction.bgp_communities)
}
inline void RTBHAction::add_bgp_communities(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_bgp_communities()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RTBHAction.bgp_communities)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& RTBHAction::bgp_communities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RTBHAction.bgp_communities)
  return _internal_bgp_communities();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* RTBHAction::mutable_bgp_communities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RTBHAction.bgp_communities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bgp_communities();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
RTBHAction::_internal_bgp_communities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bgp_communities_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* RTBHAction::_internal_mutable_bgp_communities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bgp_communities_;
}

// string next_hop = 2 [json_name = "nextHop"];
inline void RTBHAction::clear_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.ClearToEmpty();
}
inline const std::string& RTBHAction::next_hop() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHAction.next_hop)
  return _internal_next_hop();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RTBHAction::set_next_hop(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHAction.next_hop)
}
inline std::string* RTBHAction::mutable_next_hop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_hop();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RTBHAction.next_hop)
  return _s;
}
inline const std::string& RTBHAction::_internal_next_hop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_hop_.Get();
}
inline void RTBHAction::_internal_set_next_hop(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.Set(value, GetArena());
}
inline std::string* RTBHAction::_internal_mutable_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_hop_.Mutable( GetArena());
}
inline std::string* RTBHAction::release_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RTBHAction.next_hop)
  return _impl_.next_hop_.Release();
}
inline void RTBHAction::set_allocated_next_hop(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_hop_.IsDefault()) {
    _impl_.next_hop_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RTBHAction.next_hop)
}

// uint32 local_preference = 3 [json_name = "localPreference"];
inline void RTBHAction::clear_local_preference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_preference_ = 0u;
}
inline ::uint32_t RTBHAction::local_preference() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RTBHAction.local_preference)
  return _internal_local_preference();
}
inline void RTBHAction::set_local_preference(::uint32_t value) {
  _internal_set_local_preference(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RTBHAction.local_preference)
}
inline ::uint32_t RTBHAction::_internal_local_preference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_preference_;
}
inline void RTBHAction::_internal_set_local_preference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_preference_ = value;
}

// -------------------------------------------------------------------

// NumericFormula

// repeated .kentik.ktbgp.v202501.NumericPredicateGroup or = 1 [json_name = "or"];
inline int NumericFormula::_internal_or__size() const {
  return _internal_or_().size();
}
inline int NumericFormula::or__size() const {
  return _internal_or__size();
}
inline void NumericFormula::clear_or_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.or__.Clear();
}
inline ::kentik::ktbgp::v202501::NumericPredicateGroup* NumericFormula::mutable_or_(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.NumericFormula.or)
  return _internal_mutable_or_()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>* NumericFormula::mutable_or_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.NumericFormula.or)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_or_();
}
inline const ::kentik::ktbgp::v202501::NumericPredicateGroup& NumericFormula::or_(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.NumericFormula.or)
  return _internal_or_().Get(index);
}
inline ::kentik::ktbgp::v202501::NumericPredicateGroup* NumericFormula::add_or_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::NumericPredicateGroup* _add = _internal_mutable_or_()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.NumericFormula.or)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>& NumericFormula::or_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.NumericFormula.or)
  return _internal_or_();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>&
NumericFormula::_internal_or_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.or__;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicateGroup>*
NumericFormula::_internal_mutable_or_() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.or__;
}

// -------------------------------------------------------------------

// NumericPredicateGroup

// repeated .kentik.ktbgp.v202501.NumericPredicate and = 1 [json_name = "and"];
inline int NumericPredicateGroup::_internal_and__size() const {
  return _internal_and_().size();
}
inline int NumericPredicateGroup::and__size() const {
  return _internal_and__size();
}
inline void NumericPredicateGroup::clear_and_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.and__.Clear();
}
inline ::kentik::ktbgp::v202501::NumericPredicate* NumericPredicateGroup::mutable_and_(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.NumericPredicateGroup.and)
  return _internal_mutable_and_()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>* NumericPredicateGroup::mutable_and_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.NumericPredicateGroup.and)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_and_();
}
inline const ::kentik::ktbgp::v202501::NumericPredicate& NumericPredicateGroup::and_(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.NumericPredicateGroup.and)
  return _internal_and_().Get(index);
}
inline ::kentik::ktbgp::v202501::NumericPredicate* NumericPredicateGroup::add_and_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::NumericPredicate* _add = _internal_mutable_and_()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.NumericPredicateGroup.and)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>& NumericPredicateGroup::and_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.NumericPredicateGroup.and)
  return _internal_and_();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>&
NumericPredicateGroup::_internal_and_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.and__;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::NumericPredicate>*
NumericPredicateGroup::_internal_mutable_and_() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.and__;
}

// -------------------------------------------------------------------

// NumericPredicate

// .kentik.ktbgp.v202501.NumericOp operator = 1 [json_name = "operator"];
inline void NumericPredicate::clear_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__ = 0;
}
inline ::kentik::ktbgp::v202501::NumericOp NumericPredicate::operator_() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.NumericPredicate.operator)
  return _internal_operator_();
}
inline void NumericPredicate::set_operator_(::kentik::ktbgp::v202501::NumericOp value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.NumericPredicate.operator)
}
inline ::kentik::ktbgp::v202501::NumericOp NumericPredicate::_internal_operator_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::NumericOp>(_impl_.operator__);
}
inline void NumericPredicate::_internal_set_operator_(::kentik::ktbgp::v202501::NumericOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__ = value;
}

// uint64 value = 2 [json_name = "value"];
inline void NumericPredicate::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = ::uint64_t{0u};
}
inline ::uint64_t NumericPredicate::value() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.NumericPredicate.value)
  return _internal_value();
}
inline void NumericPredicate::set_value(::uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.NumericPredicate.value)
}
inline ::uint64_t NumericPredicate::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void NumericPredicate::_internal_set_value(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// FragmentFormula

// repeated .kentik.ktbgp.v202501.FragmentPredicateGroup or = 1 [json_name = "or"];
inline int FragmentFormula::_internal_or__size() const {
  return _internal_or_().size();
}
inline int FragmentFormula::or__size() const {
  return _internal_or__size();
}
inline void FragmentFormula::clear_or_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.or__.Clear();
}
inline ::kentik::ktbgp::v202501::FragmentPredicateGroup* FragmentFormula::mutable_or_(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FragmentFormula.or)
  return _internal_mutable_or_()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>* FragmentFormula::mutable_or_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.FragmentFormula.or)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_or_();
}
inline const ::kentik::ktbgp::v202501::FragmentPredicateGroup& FragmentFormula::or_(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FragmentFormula.or)
  return _internal_or_().Get(index);
}
inline ::kentik::ktbgp::v202501::FragmentPredicateGroup* FragmentFormula::add_or_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::FragmentPredicateGroup* _add = _internal_mutable_or_()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.FragmentFormula.or)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>& FragmentFormula::or_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.FragmentFormula.or)
  return _internal_or_();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>&
FragmentFormula::_internal_or_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.or__;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicateGroup>*
FragmentFormula::_internal_mutable_or_() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.or__;
}

// -------------------------------------------------------------------

// FragmentPredicateGroup

// repeated .kentik.ktbgp.v202501.FragmentPredicate and = 1 [json_name = "and"];
inline int FragmentPredicateGroup::_internal_and__size() const {
  return _internal_and_().size();
}
inline int FragmentPredicateGroup::and__size() const {
  return _internal_and__size();
}
inline void FragmentPredicateGroup::clear_and_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.and__.Clear();
}
inline ::kentik::ktbgp::v202501::FragmentPredicate* FragmentPredicateGroup::mutable_and_(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.FragmentPredicateGroup.and)
  return _internal_mutable_and_()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>* FragmentPredicateGroup::mutable_and_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.FragmentPredicateGroup.and)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_and_();
}
inline const ::kentik::ktbgp::v202501::FragmentPredicate& FragmentPredicateGroup::and_(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FragmentPredicateGroup.and)
  return _internal_and_().Get(index);
}
inline ::kentik::ktbgp::v202501::FragmentPredicate* FragmentPredicateGroup::add_and_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::FragmentPredicate* _add = _internal_mutable_and_()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.FragmentPredicateGroup.and)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>& FragmentPredicateGroup::and_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.FragmentPredicateGroup.and)
  return _internal_and_();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>&
FragmentPredicateGroup::_internal_and_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.and__;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FragmentPredicate>*
FragmentPredicateGroup::_internal_mutable_and_() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.and__;
}

// -------------------------------------------------------------------

// FragmentPredicate

// .kentik.ktbgp.v202501.BitwiseOp operator = 1 [json_name = "operator"];
inline void FragmentPredicate::clear_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__ = 0;
}
inline ::kentik::ktbgp::v202501::BitwiseOp FragmentPredicate::operator_() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FragmentPredicate.operator)
  return _internal_operator_();
}
inline void FragmentPredicate::set_operator_(::kentik::ktbgp::v202501::BitwiseOp value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FragmentPredicate.operator)
}
inline ::kentik::ktbgp::v202501::BitwiseOp FragmentPredicate::_internal_operator_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::BitwiseOp>(_impl_.operator__);
}
inline void FragmentPredicate::_internal_set_operator_(::kentik::ktbgp::v202501::BitwiseOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__ = value;
}

// repeated .kentik.ktbgp.v202501.Fragment values = 2 [json_name = "values"];
inline int FragmentPredicate::_internal_values_size() const {
  return _internal_values().size();
}
inline int FragmentPredicate::values_size() const {
  return _internal_values_size();
}
inline void FragmentPredicate::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::kentik::ktbgp::v202501::Fragment FragmentPredicate::values(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.FragmentPredicate.values)
  return static_cast<::kentik::ktbgp::v202501::Fragment>(_internal_values().Get(index));
}
inline void FragmentPredicate::set_values(int index, ::kentik::ktbgp::v202501::Fragment value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.FragmentPredicate.values)
}
inline void FragmentPredicate::add_values(::kentik::ktbgp::v202501::Fragment value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.FragmentPredicate.values)
}
inline const ::google::protobuf::RepeatedField<int>& FragmentPredicate::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.FragmentPredicate.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<int>* FragmentPredicate::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.FragmentPredicate.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<int>& FragmentPredicate::_internal_values()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<int>* FragmentPredicate::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// TCPFlagsFormula

// repeated .kentik.ktbgp.v202501.TCPFlagsPredicateGroup or = 1 [json_name = "or"];
inline int TCPFlagsFormula::_internal_or__size() const {
  return _internal_or_().size();
}
inline int TCPFlagsFormula::or__size() const {
  return _internal_or__size();
}
inline void TCPFlagsFormula::clear_or_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.or__.Clear();
}
inline ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup* TCPFlagsFormula::mutable_or_(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.TCPFlagsFormula.or)
  return _internal_mutable_or_()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>* TCPFlagsFormula::mutable_or_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.TCPFlagsFormula.or)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_or_();
}
inline const ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup& TCPFlagsFormula::or_(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.TCPFlagsFormula.or)
  return _internal_or_().Get(index);
}
inline ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup* TCPFlagsFormula::add_or_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::TCPFlagsPredicateGroup* _add = _internal_mutable_or_()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.TCPFlagsFormula.or)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>& TCPFlagsFormula::or_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.TCPFlagsFormula.or)
  return _internal_or_();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>&
TCPFlagsFormula::_internal_or_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.or__;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicateGroup>*
TCPFlagsFormula::_internal_mutable_or_() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.or__;
}

// -------------------------------------------------------------------

// TCPFlagsPredicateGroup

// repeated .kentik.ktbgp.v202501.TCPFlagsPredicate and = 1 [json_name = "and"];
inline int TCPFlagsPredicateGroup::_internal_and__size() const {
  return _internal_and_().size();
}
inline int TCPFlagsPredicateGroup::and__size() const {
  return _internal_and__size();
}
inline void TCPFlagsPredicateGroup::clear_and_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.and__.Clear();
}
inline ::kentik::ktbgp::v202501::TCPFlagsPredicate* TCPFlagsPredicateGroup::mutable_and_(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.TCPFlagsPredicateGroup.and)
  return _internal_mutable_and_()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>* TCPFlagsPredicateGroup::mutable_and_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.TCPFlagsPredicateGroup.and)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_and_();
}
inline const ::kentik::ktbgp::v202501::TCPFlagsPredicate& TCPFlagsPredicateGroup::and_(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.TCPFlagsPredicateGroup.and)
  return _internal_and_().Get(index);
}
inline ::kentik::ktbgp::v202501::TCPFlagsPredicate* TCPFlagsPredicateGroup::add_and_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::TCPFlagsPredicate* _add = _internal_mutable_and_()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.TCPFlagsPredicateGroup.and)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>& TCPFlagsPredicateGroup::and_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.TCPFlagsPredicateGroup.and)
  return _internal_and_();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>&
TCPFlagsPredicateGroup::_internal_and_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.and__;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::TCPFlagsPredicate>*
TCPFlagsPredicateGroup::_internal_mutable_and_() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.and__;
}

// -------------------------------------------------------------------

// TCPFlagsPredicate

// .kentik.ktbgp.v202501.BitwiseOp operator = 1 [json_name = "operator"];
inline void TCPFlagsPredicate::clear_operator_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__ = 0;
}
inline ::kentik::ktbgp::v202501::BitwiseOp TCPFlagsPredicate::operator_() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.TCPFlagsPredicate.operator)
  return _internal_operator_();
}
inline void TCPFlagsPredicate::set_operator_(::kentik::ktbgp::v202501::BitwiseOp value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.TCPFlagsPredicate.operator)
}
inline ::kentik::ktbgp::v202501::BitwiseOp TCPFlagsPredicate::_internal_operator_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::BitwiseOp>(_impl_.operator__);
}
inline void TCPFlagsPredicate::_internal_set_operator_(::kentik::ktbgp::v202501::BitwiseOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator__ = value;
}

// repeated .kentik.ktbgp.v202501.TCPFlag values = 2 [json_name = "values"];
inline int TCPFlagsPredicate::_internal_values_size() const {
  return _internal_values().size();
}
inline int TCPFlagsPredicate::values_size() const {
  return _internal_values_size();
}
inline void TCPFlagsPredicate::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::kentik::ktbgp::v202501::TCPFlag TCPFlagsPredicate::values(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.TCPFlagsPredicate.values)
  return static_cast<::kentik::ktbgp::v202501::TCPFlag>(_internal_values().Get(index));
}
inline void TCPFlagsPredicate::set_values(int index, ::kentik::ktbgp::v202501::TCPFlag value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.TCPFlagsPredicate.values)
}
inline void TCPFlagsPredicate::add_values(::kentik::ktbgp::v202501::TCPFlag value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.TCPFlagsPredicate.values)
}
inline const ::google::protobuf::RepeatedField<int>& TCPFlagsPredicate::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.TCPFlagsPredicate.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<int>* TCPFlagsPredicate::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.TCPFlagsPredicate.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<int>& TCPFlagsPredicate::_internal_values()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<int>* TCPFlagsPredicate::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// UpdateResult

// uint64 device_id = 1 [json_name = "deviceId"];
inline void UpdateResult::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_ = ::uint64_t{0u};
}
inline ::uint64_t UpdateResult::device_id() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.UpdateResult.device_id)
  return _internal_device_id();
}
inline void UpdateResult::set_device_id(::uint64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.UpdateResult.device_id)
}
inline ::uint64_t UpdateResult::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_;
}
inline void UpdateResult::_internal_set_device_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_ = value;
}

// .kentik.ktbgp.v202501.AdvertStatus status = 2 [json_name = "status"];
inline void UpdateResult::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::kentik::ktbgp::v202501::AdvertStatus UpdateResult::status() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.UpdateResult.status)
  return _internal_status();
}
inline void UpdateResult::set_status(::kentik::ktbgp::v202501::AdvertStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.UpdateResult.status)
}
inline ::kentik::ktbgp::v202501::AdvertStatus UpdateResult::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::kentik::ktbgp::v202501::AdvertStatus>(_impl_.status_);
}
inline void UpdateResult::_internal_set_status(::kentik::ktbgp::v202501::AdvertStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string message = 3 [json_name = "message"];
inline void UpdateResult::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateResult::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.UpdateResult.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateResult::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.UpdateResult.message)
}
inline std::string* UpdateResult::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.UpdateResult.message)
  return _s;
}
inline const std::string& UpdateResult::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void UpdateResult::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UpdateResult::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UpdateResult::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.UpdateResult.message)
  return _impl_.message_.Release();
}
inline void UpdateResult::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.UpdateResult.message)
}

// -------------------------------------------------------------------

// RouteServiceListRequest

// .kentik.ktbgp.v202501.RoutesFilter filters = 1 [json_name = "filters"];
inline bool RouteServiceListRequest::has_filters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filters_ != nullptr);
  return value;
}
inline void RouteServiceListRequest::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filters_ != nullptr) _impl_.filters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kentik::ktbgp::v202501::RoutesFilter& RouteServiceListRequest::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::kentik::ktbgp::v202501::RoutesFilter* p = _impl_.filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::kentik::ktbgp::v202501::RoutesFilter&>(::kentik::ktbgp::v202501::_RoutesFilter_default_instance_);
}
inline const ::kentik::ktbgp::v202501::RoutesFilter& RouteServiceListRequest::filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceListRequest.filters)
  return _internal_filters();
}
inline void RouteServiceListRequest::unsafe_arena_set_allocated_filters(::kentik::ktbgp::v202501::RoutesFilter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filters_);
  }
  _impl_.filters_ = reinterpret_cast<::kentik::ktbgp::v202501::RoutesFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.ktbgp.v202501.RouteServiceListRequest.filters)
}
inline ::kentik::ktbgp::v202501::RoutesFilter* RouteServiceListRequest::release_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::RoutesFilter* released = _impl_.filters_;
  _impl_.filters_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::kentik::ktbgp::v202501::RoutesFilter* RouteServiceListRequest::unsafe_arena_release_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:kentik.ktbgp.v202501.RouteServiceListRequest.filters)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kentik::ktbgp::v202501::RoutesFilter* temp = _impl_.filters_;
  _impl_.filters_ = nullptr;
  return temp;
}
inline ::kentik::ktbgp::v202501::RoutesFilter* RouteServiceListRequest::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filters_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kentik::ktbgp::v202501::RoutesFilter>(GetArena());
    _impl_.filters_ = reinterpret_cast<::kentik::ktbgp::v202501::RoutesFilter*>(p);
  }
  return _impl_.filters_;
}
inline ::kentik::ktbgp::v202501::RoutesFilter* RouteServiceListRequest::mutable_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kentik::ktbgp::v202501::RoutesFilter* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceListRequest.filters)
  return _msg;
}
inline void RouteServiceListRequest::set_allocated_filters(::kentik::ktbgp::v202501::RoutesFilter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.filters_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.filters_ = reinterpret_cast<::kentik::ktbgp::v202501::RoutesFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:kentik.ktbgp.v202501.RouteServiceListRequest.filters)
}

// -------------------------------------------------------------------

// RoutesFilter

// repeated uint64 device_ids = 1 [json_name = "deviceIds"];
inline int RoutesFilter::_internal_device_ids_size() const {
  return _internal_device_ids().size();
}
inline int RoutesFilter::device_ids_size() const {
  return _internal_device_ids_size();
}
inline void RoutesFilter::clear_device_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_ids_.Clear();
}
inline ::uint64_t RoutesFilter::device_ids(int index) const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RoutesFilter.device_ids)
  return _internal_device_ids().Get(index);
}
inline void RoutesFilter::set_device_ids(int index, ::uint64_t value) {
  _internal_mutable_device_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.RoutesFilter.device_ids)
}
inline void RoutesFilter::add_device_ids(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_device_ids()->Add(value);
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RoutesFilter.device_ids)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& RoutesFilter::device_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RoutesFilter.device_ids)
  return _internal_device_ids();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* RoutesFilter::mutable_device_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RoutesFilter.device_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_device_ids();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
RoutesFilter::_internal_device_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_ids_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* RoutesFilter::_internal_mutable_device_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.device_ids_;
}

// -------------------------------------------------------------------

// RouteServiceListResponse

// repeated .kentik.ktbgp.v202501.DeviceAdverts result = 1 [json_name = "result"];
inline int RouteServiceListResponse::_internal_result_size() const {
  return _internal_result().size();
}
inline int RouteServiceListResponse::result_size() const {
  return _internal_result_size();
}
inline void RouteServiceListResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_.Clear();
}
inline ::kentik::ktbgp::v202501::DeviceAdverts* RouteServiceListResponse::mutable_result(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.RouteServiceListResponse.result)
  return _internal_mutable_result()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>* RouteServiceListResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.RouteServiceListResponse.result)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_result();
}
inline const ::kentik::ktbgp::v202501::DeviceAdverts& RouteServiceListResponse::result(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.RouteServiceListResponse.result)
  return _internal_result().Get(index);
}
inline ::kentik::ktbgp::v202501::DeviceAdverts* RouteServiceListResponse::add_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::DeviceAdverts* _add = _internal_mutable_result()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.RouteServiceListResponse.result)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>& RouteServiceListResponse::result() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.RouteServiceListResponse.result)
  return _internal_result();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>&
RouteServiceListResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::DeviceAdverts>*
RouteServiceListResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.result_;
}

// -------------------------------------------------------------------

// DeviceAdverts

// uint64 device_id = 1 [json_name = "deviceId"];
inline void DeviceAdverts::clear_device_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_ = ::uint64_t{0u};
}
inline ::uint64_t DeviceAdverts::device_id() const {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.DeviceAdverts.device_id)
  return _internal_device_id();
}
inline void DeviceAdverts::set_device_id(::uint64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:kentik.ktbgp.v202501.DeviceAdverts.device_id)
}
inline ::uint64_t DeviceAdverts::_internal_device_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_id_;
}
inline void DeviceAdverts::_internal_set_device_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_id_ = value;
}

// repeated .kentik.ktbgp.v202501.FlowspecUpdate flowspec = 2 [json_name = "flowspec"];
inline int DeviceAdverts::_internal_flowspec_size() const {
  return _internal_flowspec().size();
}
inline int DeviceAdverts::flowspec_size() const {
  return _internal_flowspec_size();
}
inline void DeviceAdverts::clear_flowspec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flowspec_.Clear();
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* DeviceAdverts::mutable_flowspec(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.DeviceAdverts.flowspec)
  return _internal_mutable_flowspec()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>* DeviceAdverts::mutable_flowspec()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.DeviceAdverts.flowspec)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_flowspec();
}
inline const ::kentik::ktbgp::v202501::FlowspecUpdate& DeviceAdverts::flowspec(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.DeviceAdverts.flowspec)
  return _internal_flowspec().Get(index);
}
inline ::kentik::ktbgp::v202501::FlowspecUpdate* DeviceAdverts::add_flowspec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::FlowspecUpdate* _add = _internal_mutable_flowspec()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.DeviceAdverts.flowspec)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>& DeviceAdverts::flowspec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.DeviceAdverts.flowspec)
  return _internal_flowspec();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>&
DeviceAdverts::_internal_flowspec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flowspec_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::FlowspecUpdate>*
DeviceAdverts::_internal_mutable_flowspec() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.flowspec_;
}

// repeated .kentik.ktbgp.v202501.RTBHUpdate rtbh = 3 [json_name = "rtbh"];
inline int DeviceAdverts::_internal_rtbh_size() const {
  return _internal_rtbh().size();
}
inline int DeviceAdverts::rtbh_size() const {
  return _internal_rtbh_size();
}
inline void DeviceAdverts::clear_rtbh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtbh_.Clear();
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* DeviceAdverts::mutable_rtbh(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kentik.ktbgp.v202501.DeviceAdverts.rtbh)
  return _internal_mutable_rtbh()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>* DeviceAdverts::mutable_rtbh()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kentik.ktbgp.v202501.DeviceAdverts.rtbh)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rtbh();
}
inline const ::kentik::ktbgp::v202501::RTBHUpdate& DeviceAdverts::rtbh(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kentik.ktbgp.v202501.DeviceAdverts.rtbh)
  return _internal_rtbh().Get(index);
}
inline ::kentik::ktbgp::v202501::RTBHUpdate* DeviceAdverts::add_rtbh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::kentik::ktbgp::v202501::RTBHUpdate* _add = _internal_mutable_rtbh()->Add();
  // @@protoc_insertion_point(field_add:kentik.ktbgp.v202501.DeviceAdverts.rtbh)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>& DeviceAdverts::rtbh() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kentik.ktbgp.v202501.DeviceAdverts.rtbh)
  return _internal_rtbh();
}
inline const ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>&
DeviceAdverts::_internal_rtbh() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rtbh_;
}
inline ::google::protobuf::RepeatedPtrField<::kentik::ktbgp::v202501::RTBHUpdate>*
DeviceAdverts::_internal_mutable_rtbh() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rtbh_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v202501
}  // namespace ktbgp
}  // namespace kentik


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::kentik::ktbgp::v202501::InetType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::InetType>() {
  return ::kentik::ktbgp::v202501::InetType_descriptor();
}
template <>
struct is_proto_enum<::kentik::ktbgp::v202501::ExtendedCommunityRouteType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::ExtendedCommunityRouteType>() {
  return ::kentik::ktbgp::v202501::ExtendedCommunityRouteType_descriptor();
}
template <>
struct is_proto_enum<::kentik::ktbgp::v202501::Fragment> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::Fragment>() {
  return ::kentik::ktbgp::v202501::Fragment_descriptor();
}
template <>
struct is_proto_enum<::kentik::ktbgp::v202501::TCPFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::TCPFlag>() {
  return ::kentik::ktbgp::v202501::TCPFlag_descriptor();
}
template <>
struct is_proto_enum<::kentik::ktbgp::v202501::NumericOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::NumericOp>() {
  return ::kentik::ktbgp::v202501::NumericOp_descriptor();
}
template <>
struct is_proto_enum<::kentik::ktbgp::v202501::BitwiseOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::BitwiseOp>() {
  return ::kentik::ktbgp::v202501::BitwiseOp_descriptor();
}
template <>
struct is_proto_enum<::kentik::ktbgp::v202501::AdvertStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::kentik::ktbgp::v202501::AdvertStatus>() {
  return ::kentik::ktbgp::v202501::AdvertStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // kentik_2fktbgp_2fv202501_2froute_5fservice_2eproto_2epb_2eh
