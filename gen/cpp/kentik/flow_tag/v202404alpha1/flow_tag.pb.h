// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kentik/flow_tag/v202404alpha1/flow_tag.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "kentik/core/v202303/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
namespace kentik {
namespace flow_tag {
namespace v202404alpha1 {
class AddressInfo;
class AddressInfoDefaultTypeInternal;
extern AddressInfoDefaultTypeInternal _AddressInfo_default_instance_;
class CreateFlowTagRequest;
class CreateFlowTagRequestDefaultTypeInternal;
extern CreateFlowTagRequestDefaultTypeInternal _CreateFlowTagRequest_default_instance_;
class CreateFlowTagResponse;
class CreateFlowTagResponseDefaultTypeInternal;
extern CreateFlowTagResponseDefaultTypeInternal _CreateFlowTagResponse_default_instance_;
class DeleteFlowTagRequest;
class DeleteFlowTagRequestDefaultTypeInternal;
extern DeleteFlowTagRequestDefaultTypeInternal _DeleteFlowTagRequest_default_instance_;
class DeleteFlowTagResponse;
class DeleteFlowTagResponseDefaultTypeInternal;
extern DeleteFlowTagResponseDefaultTypeInternal _DeleteFlowTagResponse_default_instance_;
class FlowTag;
class FlowTagDefaultTypeInternal;
extern FlowTagDefaultTypeInternal _FlowTag_default_instance_;
class FlowTagSearch;
class FlowTagSearchDefaultTypeInternal;
extern FlowTagSearchDefaultTypeInternal _FlowTagSearch_default_instance_;
class GetFlowTagRequest;
class GetFlowTagRequestDefaultTypeInternal;
extern GetFlowTagRequestDefaultTypeInternal _GetFlowTagRequest_default_instance_;
class GetFlowTagResponse;
class GetFlowTagResponseDefaultTypeInternal;
extern GetFlowTagResponseDefaultTypeInternal _GetFlowTagResponse_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class OrderField;
class OrderFieldDefaultTypeInternal;
extern OrderFieldDefaultTypeInternal _OrderField_default_instance_;
class SearchFlowTagRequest;
class SearchFlowTagRequestDefaultTypeInternal;
extern SearchFlowTagRequestDefaultTypeInternal _SearchFlowTagRequest_default_instance_;
class SearchFlowTagResponse;
class SearchFlowTagResponseDefaultTypeInternal;
extern SearchFlowTagResponseDefaultTypeInternal _SearchFlowTagResponse_default_instance_;
class UpdateFlowTagRequest;
class UpdateFlowTagRequestDefaultTypeInternal;
extern UpdateFlowTagRequestDefaultTypeInternal _UpdateFlowTagRequest_default_instance_;
class UpdateFlowTagResponse;
class UpdateFlowTagResponseDefaultTypeInternal;
extern UpdateFlowTagResponseDefaultTypeInternal _UpdateFlowTagResponse_default_instance_;
}  // namespace v202404alpha1
}  // namespace flow_tag
}  // namespace kentik
PROTOBUF_NAMESPACE_OPEN
template<> ::kentik::flow_tag::v202404alpha1::AddressInfo* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::AddressInfo>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::CreateFlowTagRequest* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::CreateFlowTagRequest>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::CreateFlowTagResponse* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::CreateFlowTagResponse>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::DeleteFlowTagRequest* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::DeleteFlowTagRequest>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::DeleteFlowTagResponse* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::DeleteFlowTagResponse>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::FlowTag* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTag>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::FlowTagSearch* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTagSearch>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::GetFlowTagRequest* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::GetFlowTagRequest>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::GetFlowTagResponse* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::GetFlowTagResponse>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::Model* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::Model>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::OrderField* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::OrderField>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::SearchFlowTagRequest* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::SearchFlowTagRequest>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::SearchFlowTagResponse* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::SearchFlowTagResponse>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::UpdateFlowTagRequest* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::UpdateFlowTagRequest>(Arena*);
template<> ::kentik::flow_tag::v202404alpha1::UpdateFlowTagResponse* Arena::CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::UpdateFlowTagResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kentik {
namespace flow_tag {
namespace v202404alpha1 {

enum ModelType : int {
  MODEL_TYPE_UNSPECIFIED = 0,
  MODEL_TYPE_POPULATORS = 1,
  MODEL_TYPE_TAGS = 2,
  MODEL_TYPE_IP_ADDRESSES = 3,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = MODEL_TYPE_UNSPECIFIED;
constexpr ModelType ModelType_MAX = MODEL_TYPE_IP_ADDRESSES;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    const std::string& name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum LookupField : int {
  LOOKUP_FIELD_UNSPECIFIED = 0,
  LOOKUP_FIELD_VALUE = 1,
  LookupField_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LookupField_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LookupField_IsValid(int value);
constexpr LookupField LookupField_MIN = LOOKUP_FIELD_UNSPECIFIED;
constexpr LookupField LookupField_MAX = LOOKUP_FIELD_VALUE;
constexpr int LookupField_ARRAYSIZE = LookupField_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LookupField_descriptor();
template<typename T>
inline const std::string& LookupField_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LookupField>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LookupField_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LookupField_descriptor(), enum_t_value);
}
inline bool LookupField_Parse(
    const std::string& name, LookupField* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LookupField>(
    LookupField_descriptor(), name, value);
}
enum OrderDirection : int {
  ORDER_DIRECTION_UNSPECIFIED = 0,
  ORDER_DIRECTION_ASC = 1,
  ORDER_DIRECTION_DESC = 2,
  OrderDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OrderDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OrderDirection_IsValid(int value);
constexpr OrderDirection OrderDirection_MIN = ORDER_DIRECTION_UNSPECIFIED;
constexpr OrderDirection OrderDirection_MAX = ORDER_DIRECTION_DESC;
constexpr int OrderDirection_ARRAYSIZE = OrderDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderDirection_descriptor();
template<typename T>
inline const std::string& OrderDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderDirection_descriptor(), enum_t_value);
}
inline bool OrderDirection_Parse(
    const std::string& name, OrderDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderDirection>(
    OrderDirection_descriptor(), name, value);
}
// ===================================================================

class Model PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.Model) */ {
 public:
  inline Model() : Model(nullptr) {};
  virtual ~Model();

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(nullptr);
  }

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.ModelType type = 1[json_name = "type"];
  void clear_type();
  ::kentik::flow_tag::v202404alpha1::ModelType type() const;
  void set_type(::kentik::flow_tag::v202404alpha1::ModelType value);
  private:
  ::kentik::flow_tag::v202404alpha1::ModelType _internal_type() const;
  void _internal_set_type(::kentik::flow_tag::v202404alpha1::ModelType value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class OrderField PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.OrderField) */ {
 public:
  inline OrderField() : OrderField(nullptr) {};
  virtual ~OrderField();

  OrderField(const OrderField& from);
  OrderField(OrderField&& from) noexcept
    : OrderField() {
    *this = ::std::move(from);
  }

  inline OrderField& operator=(const OrderField& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderField& operator=(OrderField&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderField* internal_default_instance() {
    return reinterpret_cast<const OrderField*>(
               &_OrderField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OrderField& a, OrderField& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderField* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderField* New() const final {
    return CreateMaybeMessage<OrderField>(nullptr);
  }

  OrderField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderField>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderField& from);
  void MergeFrom(const OrderField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.OrderField";
  }
  protected:
  explicit OrderField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // .kentik.flow_tag.v202404alpha1.LookupField field = 1[json_name = "field"];
  void clear_field();
  ::kentik::flow_tag::v202404alpha1::LookupField field() const;
  void set_field(::kentik::flow_tag::v202404alpha1::LookupField value);
  private:
  ::kentik::flow_tag::v202404alpha1::LookupField _internal_field() const;
  void _internal_set_field(::kentik::flow_tag::v202404alpha1::LookupField value);
  public:

  // .kentik.flow_tag.v202404alpha1.OrderDirection direction = 2[json_name = "direction"];
  void clear_direction();
  ::kentik::flow_tag::v202404alpha1::OrderDirection direction() const;
  void set_direction(::kentik::flow_tag::v202404alpha1::OrderDirection value);
  private:
  ::kentik::flow_tag::v202404alpha1::OrderDirection _internal_direction() const;
  void _internal_set_direction(::kentik::flow_tag::v202404alpha1::OrderDirection value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.OrderField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int field_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class FlowTagSearch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.FlowTagSearch) */ {
 public:
  inline FlowTagSearch() : FlowTagSearch(nullptr) {};
  virtual ~FlowTagSearch();

  FlowTagSearch(const FlowTagSearch& from);
  FlowTagSearch(FlowTagSearch&& from) noexcept
    : FlowTagSearch() {
    *this = ::std::move(from);
  }

  inline FlowTagSearch& operator=(const FlowTagSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowTagSearch& operator=(FlowTagSearch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlowTagSearch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowTagSearch* internal_default_instance() {
    return reinterpret_cast<const FlowTagSearch*>(
               &_FlowTagSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FlowTagSearch& a, FlowTagSearch& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowTagSearch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowTagSearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowTagSearch* New() const final {
    return CreateMaybeMessage<FlowTagSearch>(nullptr);
  }

  FlowTagSearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowTagSearch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlowTagSearch& from);
  void MergeFrom(const FlowTagSearch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowTagSearch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.FlowTagSearch";
  }
  protected:
  explicit FlowTagSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLookupFieldsFieldNumber = 3,
    kLookupValuesFieldNumber = 4,
    kOrderByFieldNumber = 5,
    kLimitFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kFieldLimitFieldNumber = 6,
  };
  // repeated .kentik.flow_tag.v202404alpha1.LookupField lookup_fields = 3[json_name = "lookupFields"];
  int lookup_fields_size() const;
  private:
  int _internal_lookup_fields_size() const;
  public:
  void clear_lookup_fields();
  private:
  ::kentik::flow_tag::v202404alpha1::LookupField _internal_lookup_fields(int index) const;
  void _internal_add_lookup_fields(::kentik::flow_tag::v202404alpha1::LookupField value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_lookup_fields();
  public:
  ::kentik::flow_tag::v202404alpha1::LookupField lookup_fields(int index) const;
  void set_lookup_fields(int index, ::kentik::flow_tag::v202404alpha1::LookupField value);
  void add_lookup_fields(::kentik::flow_tag::v202404alpha1::LookupField value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& lookup_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_lookup_fields();

  // repeated string lookup_values = 4[json_name = "lookupValues"];
  int lookup_values_size() const;
  private:
  int _internal_lookup_values_size() const;
  public:
  void clear_lookup_values();
  const std::string& lookup_values(int index) const;
  std::string* mutable_lookup_values(int index);
  void set_lookup_values(int index, const std::string& value);
  void set_lookup_values(int index, std::string&& value);
  void set_lookup_values(int index, const char* value);
  void set_lookup_values(int index, const char* value, size_t size);
  std::string* add_lookup_values();
  void add_lookup_values(const std::string& value);
  void add_lookup_values(std::string&& value);
  void add_lookup_values(const char* value);
  void add_lookup_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lookup_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lookup_values();
  private:
  const std::string& _internal_lookup_values(int index) const;
  std::string* _internal_add_lookup_values();
  public:

  // repeated .kentik.flow_tag.v202404alpha1.OrderField order_by = 5[json_name = "orderBy"];
  int order_by_size() const;
  private:
  int _internal_order_by_size() const;
  public:
  void clear_order_by();
  ::kentik::flow_tag::v202404alpha1::OrderField* mutable_order_by(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::OrderField >*
      mutable_order_by();
  private:
  const ::kentik::flow_tag::v202404alpha1::OrderField& _internal_order_by(int index) const;
  ::kentik::flow_tag::v202404alpha1::OrderField* _internal_add_order_by();
  public:
  const ::kentik::flow_tag::v202404alpha1::OrderField& order_by(int index) const;
  ::kentik::flow_tag::v202404alpha1::OrderField* add_order_by();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::OrderField >&
      order_by() const;

  // int32 limit = 1[json_name = "limit"];
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 offset = 2[json_name = "offset"];
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 field_limit = 6[json_name = "fieldLimit"];
  void clear_field_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 field_limit() const;
  void set_field_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_limit() const;
  void _internal_set_field_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.FlowTagSearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> lookup_fields_;
  mutable std::atomic<int> _lookup_fields_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lookup_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::OrderField > order_by_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_;
  ::PROTOBUF_NAMESPACE_ID::int32 offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class AddressInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.AddressInfo) */ {
 public:
  inline AddressInfo() : AddressInfo(nullptr) {};
  virtual ~AddressInfo();

  AddressInfo(const AddressInfo& from);
  AddressInfo(AddressInfo&& from) noexcept
    : AddressInfo() {
    *this = ::std::move(from);
  }

  inline AddressInfo& operator=(const AddressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressInfo& operator=(AddressInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddressInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddressInfo* internal_default_instance() {
    return reinterpret_cast<const AddressInfo*>(
               &_AddressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AddressInfo& a, AddressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressInfo* New() const final {
    return CreateMaybeMessage<AddressInfo>(nullptr);
  }

  AddressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddressInfo& from);
  void MergeFrom(const AddressInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.AddressInfo";
  }
  protected:
  explicit AddressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 1,
    kTotalCountFieldNumber = 2,
  };
  // repeated string addresses = 1[json_name = "addresses"];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // int32 total_count = 2[json_name = "totalCount"];
  void clear_total_count();
  ::PROTOBUF_NAMESPACE_ID::int32 total_count() const;
  void set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_count() const;
  void _internal_set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.AddressInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class FlowTag PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.FlowTag) */ {
 public:
  inline FlowTag() : FlowTag(nullptr) {};
  virtual ~FlowTag();

  FlowTag(const FlowTag& from);
  FlowTag(FlowTag&& from) noexcept
    : FlowTag() {
    *this = ::std::move(from);
  }

  inline FlowTag& operator=(const FlowTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowTag& operator=(FlowTag&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlowTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowTag* internal_default_instance() {
    return reinterpret_cast<const FlowTag*>(
               &_FlowTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FlowTag& a, FlowTag& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowTag* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowTag* New() const final {
    return CreateMaybeMessage<FlowTag>(nullptr);
  }

  FlowTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowTag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlowTag& from);
  void MergeFrom(const FlowTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowTag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.FlowTag";
  }
  protected:
  explicit FlowTag(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 8,
    kProtocolFieldNumber = 10,
    kDeviceNameFieldNumber = 11,
    kDeviceTypeFieldNumber = 12,
    kSiteFieldNumber = 13,
    kInterfaceNameFieldNumber = 14,
    kAsnFieldNumber = 15,
    kLasthopAsNameFieldNumber = 16,
    kNexthopAsnFieldNumber = 17,
    kNexthopAsNameFieldNumber = 18,
    kNexthopFieldNumber = 19,
    kBgpAspathFieldNumber = 20,
    kBgpCommunityFieldNumber = 21,
    kCountryFieldNumber = 23,
    kVlansFieldNumber = 24,
    kIdFieldNumber = 1,
    kNameFieldNumber = 3,
    kEditedByFieldNumber = 4,
    kCreatedByFieldNumber = 25,
    kCdateFieldNumber = 5,
    kEdateFieldNumber = 6,
    kIpFieldNumber = 7,
    kMacFieldNumber = 22,
    kTcpFlagsFieldNumber = 9,
  };
  // repeated string port = 8[json_name = "port", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int port_size() const;
  private:
  int _internal_port_size() const;
  public:
  void clear_port();
  const std::string& port(int index) const;
  std::string* mutable_port(int index);
  void set_port(int index, const std::string& value);
  void set_port(int index, std::string&& value);
  void set_port(int index, const char* value);
  void set_port(int index, const char* value, size_t size);
  std::string* add_port();
  void add_port(const std::string& value);
  void add_port(std::string&& value);
  void add_port(const char* value);
  void add_port(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& port() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_port();
  private:
  const std::string& _internal_port(int index) const;
  std::string* _internal_add_port();
  public:

  // repeated uint32 protocol = 10[json_name = "protocol", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int protocol_size() const;
  private:
  int _internal_protocol_size() const;
  public:
  void clear_protocol();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_protocol(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_protocol() const;
  void _internal_add_protocol(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_protocol();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol(int index) const;
  void set_protocol(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_protocol(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      protocol() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_protocol();

  // repeated string device_name = 11[json_name = "deviceName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int device_name_size() const;
  private:
  int _internal_device_name_size() const;
  public:
  void clear_device_name();
  const std::string& device_name(int index) const;
  std::string* mutable_device_name(int index);
  void set_device_name(int index, const std::string& value);
  void set_device_name(int index, std::string&& value);
  void set_device_name(int index, const char* value);
  void set_device_name(int index, const char* value, size_t size);
  std::string* add_device_name();
  void add_device_name(const std::string& value);
  void add_device_name(std::string&& value);
  void add_device_name(const char* value);
  void add_device_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_name();
  private:
  const std::string& _internal_device_name(int index) const;
  std::string* _internal_add_device_name();
  public:

  // repeated string device_type = 12[json_name = "deviceType", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int device_type_size() const;
  private:
  int _internal_device_type_size() const;
  public:
  void clear_device_type();
  const std::string& device_type(int index) const;
  std::string* mutable_device_type(int index);
  void set_device_type(int index, const std::string& value);
  void set_device_type(int index, std::string&& value);
  void set_device_type(int index, const char* value);
  void set_device_type(int index, const char* value, size_t size);
  std::string* add_device_type();
  void add_device_type(const std::string& value);
  void add_device_type(std::string&& value);
  void add_device_type(const char* value);
  void add_device_type(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_type();
  private:
  const std::string& _internal_device_type(int index) const;
  std::string* _internal_add_device_type();
  public:

  // repeated string site = 13[json_name = "site", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int site_size() const;
  private:
  int _internal_site_size() const;
  public:
  void clear_site();
  const std::string& site(int index) const;
  std::string* mutable_site(int index);
  void set_site(int index, const std::string& value);
  void set_site(int index, std::string&& value);
  void set_site(int index, const char* value);
  void set_site(int index, const char* value, size_t size);
  std::string* add_site();
  void add_site(const std::string& value);
  void add_site(std::string&& value);
  void add_site(const char* value);
  void add_site(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& site() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_site();
  private:
  const std::string& _internal_site(int index) const;
  std::string* _internal_add_site();
  public:

  // repeated string interface_name = 14[json_name = "interfaceName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int interface_name_size() const;
  private:
  int _internal_interface_name_size() const;
  public:
  void clear_interface_name();
  const std::string& interface_name(int index) const;
  std::string* mutable_interface_name(int index);
  void set_interface_name(int index, const std::string& value);
  void set_interface_name(int index, std::string&& value);
  void set_interface_name(int index, const char* value);
  void set_interface_name(int index, const char* value, size_t size);
  std::string* add_interface_name();
  void add_interface_name(const std::string& value);
  void add_interface_name(std::string&& value);
  void add_interface_name(const char* value);
  void add_interface_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& interface_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_interface_name();
  private:
  const std::string& _internal_interface_name(int index) const;
  std::string* _internal_add_interface_name();
  public:

  // repeated string asn = 15[json_name = "asn", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int asn_size() const;
  private:
  int _internal_asn_size() const;
  public:
  void clear_asn();
  const std::string& asn(int index) const;
  std::string* mutable_asn(int index);
  void set_asn(int index, const std::string& value);
  void set_asn(int index, std::string&& value);
  void set_asn(int index, const char* value);
  void set_asn(int index, const char* value, size_t size);
  std::string* add_asn();
  void add_asn(const std::string& value);
  void add_asn(std::string&& value);
  void add_asn(const char* value);
  void add_asn(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& asn() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_asn();
  private:
  const std::string& _internal_asn(int index) const;
  std::string* _internal_add_asn();
  public:

  // repeated string lasthop_as_name = 16[json_name = "lasthopAsName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int lasthop_as_name_size() const;
  private:
  int _internal_lasthop_as_name_size() const;
  public:
  void clear_lasthop_as_name();
  const std::string& lasthop_as_name(int index) const;
  std::string* mutable_lasthop_as_name(int index);
  void set_lasthop_as_name(int index, const std::string& value);
  void set_lasthop_as_name(int index, std::string&& value);
  void set_lasthop_as_name(int index, const char* value);
  void set_lasthop_as_name(int index, const char* value, size_t size);
  std::string* add_lasthop_as_name();
  void add_lasthop_as_name(const std::string& value);
  void add_lasthop_as_name(std::string&& value);
  void add_lasthop_as_name(const char* value);
  void add_lasthop_as_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lasthop_as_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lasthop_as_name();
  private:
  const std::string& _internal_lasthop_as_name(int index) const;
  std::string* _internal_add_lasthop_as_name();
  public:

  // repeated string nexthop_asn = 17[json_name = "nexthopAsn", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int nexthop_asn_size() const;
  private:
  int _internal_nexthop_asn_size() const;
  public:
  void clear_nexthop_asn();
  const std::string& nexthop_asn(int index) const;
  std::string* mutable_nexthop_asn(int index);
  void set_nexthop_asn(int index, const std::string& value);
  void set_nexthop_asn(int index, std::string&& value);
  void set_nexthop_asn(int index, const char* value);
  void set_nexthop_asn(int index, const char* value, size_t size);
  std::string* add_nexthop_asn();
  void add_nexthop_asn(const std::string& value);
  void add_nexthop_asn(std::string&& value);
  void add_nexthop_asn(const char* value);
  void add_nexthop_asn(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nexthop_asn() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nexthop_asn();
  private:
  const std::string& _internal_nexthop_asn(int index) const;
  std::string* _internal_add_nexthop_asn();
  public:

  // repeated string nexthop_as_name = 18[json_name = "nexthopAsName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int nexthop_as_name_size() const;
  private:
  int _internal_nexthop_as_name_size() const;
  public:
  void clear_nexthop_as_name();
  const std::string& nexthop_as_name(int index) const;
  std::string* mutable_nexthop_as_name(int index);
  void set_nexthop_as_name(int index, const std::string& value);
  void set_nexthop_as_name(int index, std::string&& value);
  void set_nexthop_as_name(int index, const char* value);
  void set_nexthop_as_name(int index, const char* value, size_t size);
  std::string* add_nexthop_as_name();
  void add_nexthop_as_name(const std::string& value);
  void add_nexthop_as_name(std::string&& value);
  void add_nexthop_as_name(const char* value);
  void add_nexthop_as_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nexthop_as_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nexthop_as_name();
  private:
  const std::string& _internal_nexthop_as_name(int index) const;
  std::string* _internal_add_nexthop_as_name();
  public:

  // repeated string nexthop = 19[json_name = "nexthop", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int nexthop_size() const;
  private:
  int _internal_nexthop_size() const;
  public:
  void clear_nexthop();
  const std::string& nexthop(int index) const;
  std::string* mutable_nexthop(int index);
  void set_nexthop(int index, const std::string& value);
  void set_nexthop(int index, std::string&& value);
  void set_nexthop(int index, const char* value);
  void set_nexthop(int index, const char* value, size_t size);
  std::string* add_nexthop();
  void add_nexthop(const std::string& value);
  void add_nexthop(std::string&& value);
  void add_nexthop(const char* value);
  void add_nexthop(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nexthop() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nexthop();
  private:
  const std::string& _internal_nexthop(int index) const;
  std::string* _internal_add_nexthop();
  public:

  // repeated string bgp_aspath = 20[json_name = "bgpAspath", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int bgp_aspath_size() const;
  private:
  int _internal_bgp_aspath_size() const;
  public:
  void clear_bgp_aspath();
  const std::string& bgp_aspath(int index) const;
  std::string* mutable_bgp_aspath(int index);
  void set_bgp_aspath(int index, const std::string& value);
  void set_bgp_aspath(int index, std::string&& value);
  void set_bgp_aspath(int index, const char* value);
  void set_bgp_aspath(int index, const char* value, size_t size);
  std::string* add_bgp_aspath();
  void add_bgp_aspath(const std::string& value);
  void add_bgp_aspath(std::string&& value);
  void add_bgp_aspath(const char* value);
  void add_bgp_aspath(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bgp_aspath() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bgp_aspath();
  private:
  const std::string& _internal_bgp_aspath(int index) const;
  std::string* _internal_add_bgp_aspath();
  public:

  // repeated string bgp_community = 21[json_name = "bgpCommunity", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int bgp_community_size() const;
  private:
  int _internal_bgp_community_size() const;
  public:
  void clear_bgp_community();
  const std::string& bgp_community(int index) const;
  std::string* mutable_bgp_community(int index);
  void set_bgp_community(int index, const std::string& value);
  void set_bgp_community(int index, std::string&& value);
  void set_bgp_community(int index, const char* value);
  void set_bgp_community(int index, const char* value, size_t size);
  std::string* add_bgp_community();
  void add_bgp_community(const std::string& value);
  void add_bgp_community(std::string&& value);
  void add_bgp_community(const char* value);
  void add_bgp_community(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bgp_community() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bgp_community();
  private:
  const std::string& _internal_bgp_community(int index) const;
  std::string* _internal_add_bgp_community();
  public:

  // repeated string country = 23[json_name = "country", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int country_size() const;
  private:
  int _internal_country_size() const;
  public:
  void clear_country();
  const std::string& country(int index) const;
  std::string* mutable_country(int index);
  void set_country(int index, const std::string& value);
  void set_country(int index, std::string&& value);
  void set_country(int index, const char* value);
  void set_country(int index, const char* value, size_t size);
  std::string* add_country();
  void add_country(const std::string& value);
  void add_country(std::string&& value);
  void add_country(const char* value);
  void add_country(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& country() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_country();
  private:
  const std::string& _internal_country(int index) const;
  std::string* _internal_add_country();
  public:

  // repeated string vlans = 24[json_name = "vlans", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int vlans_size() const;
  private:
  int _internal_vlans_size() const;
  public:
  void clear_vlans();
  const std::string& vlans(int index) const;
  std::string* mutable_vlans(int index);
  void set_vlans(int index, const std::string& value);
  void set_vlans(int index, std::string&& value);
  void set_vlans(int index, const char* value);
  void set_vlans(int index, const char* value, size_t size);
  std::string* add_vlans();
  void add_vlans(const std::string& value);
  void add_vlans(std::string&& value);
  void add_vlans(const char* value);
  void add_vlans(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vlans() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vlans();
  private:
  const std::string& _internal_vlans(int index) const;
  std::string* _internal_add_vlans();
  public:

  // string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 3[json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string edited_by = 4[json_name = "editedBy", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_edited_by();
  const std::string& edited_by() const;
  void set_edited_by(const std::string& value);
  void set_edited_by(std::string&& value);
  void set_edited_by(const char* value);
  void set_edited_by(const char* value, size_t size);
  std::string* mutable_edited_by();
  std::string* release_edited_by();
  void set_allocated_edited_by(std::string* edited_by);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_edited_by();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_edited_by(
      std::string* edited_by);
  private:
  const std::string& _internal_edited_by() const;
  void _internal_set_edited_by(const std::string& value);
  std::string* _internal_mutable_edited_by();
  public:

  // string created_by = 25[json_name = "createdBy", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_created_by();
  const std::string& created_by() const;
  void set_created_by(const std::string& value);
  void set_created_by(std::string&& value);
  void set_created_by(const char* value);
  void set_created_by(const char* value, size_t size);
  std::string* mutable_created_by();
  std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_created_by();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_created_by(
      std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // .google.protobuf.Timestamp cdate = 5[json_name = "cdate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_cdate() const;
  private:
  bool _internal_has_cdate() const;
  public:
  void clear_cdate();
  const PROTOBUF_NAMESPACE_ID::Timestamp& cdate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_cdate();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cdate();
  void set_allocated_cdate(PROTOBUF_NAMESPACE_ID::Timestamp* cdate);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cdate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cdate();
  public:
  void unsafe_arena_set_allocated_cdate(
      PROTOBUF_NAMESPACE_ID::Timestamp* cdate);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cdate();

  // .google.protobuf.Timestamp edate = 6[json_name = "edate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_edate() const;
  private:
  bool _internal_has_edate() const;
  public:
  void clear_edate();
  const PROTOBUF_NAMESPACE_ID::Timestamp& edate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_edate();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_edate();
  void set_allocated_edate(PROTOBUF_NAMESPACE_ID::Timestamp* edate);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_edate() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_edate();
  public:
  void unsafe_arena_set_allocated_edate(
      PROTOBUF_NAMESPACE_ID::Timestamp* edate);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_edate();

  // .kentik.flow_tag.v202404alpha1.AddressInfo ip = 7[json_name = "ip", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const ::kentik::flow_tag::v202404alpha1::AddressInfo& ip() const;
  ::kentik::flow_tag::v202404alpha1::AddressInfo* release_ip();
  ::kentik::flow_tag::v202404alpha1::AddressInfo* mutable_ip();
  void set_allocated_ip(::kentik::flow_tag::v202404alpha1::AddressInfo* ip);
  private:
  const ::kentik::flow_tag::v202404alpha1::AddressInfo& _internal_ip() const;
  ::kentik::flow_tag::v202404alpha1::AddressInfo* _internal_mutable_ip();
  public:
  void unsafe_arena_set_allocated_ip(
      ::kentik::flow_tag::v202404alpha1::AddressInfo* ip);
  ::kentik::flow_tag::v202404alpha1::AddressInfo* unsafe_arena_release_ip();

  // .kentik.flow_tag.v202404alpha1.AddressInfo mac = 22[json_name = "mac", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_mac() const;
  private:
  bool _internal_has_mac() const;
  public:
  void clear_mac();
  const ::kentik::flow_tag::v202404alpha1::AddressInfo& mac() const;
  ::kentik::flow_tag::v202404alpha1::AddressInfo* release_mac();
  ::kentik::flow_tag::v202404alpha1::AddressInfo* mutable_mac();
  void set_allocated_mac(::kentik::flow_tag::v202404alpha1::AddressInfo* mac);
  private:
  const ::kentik::flow_tag::v202404alpha1::AddressInfo& _internal_mac() const;
  ::kentik::flow_tag::v202404alpha1::AddressInfo* _internal_mutable_mac();
  public:
  void unsafe_arena_set_allocated_mac(
      ::kentik::flow_tag::v202404alpha1::AddressInfo* mac);
  ::kentik::flow_tag::v202404alpha1::AddressInfo* unsafe_arena_release_mac();

  // uint32 tcp_flags = 9[json_name = "tcpFlags", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_tcp_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_flags() const;
  void set_tcp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tcp_flags() const;
  void _internal_set_tcp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.FlowTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> port_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > protocol_;
  mutable std::atomic<int> _protocol_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_type_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> site_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> interface_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> asn_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lasthop_as_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nexthop_asn_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nexthop_as_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nexthop_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bgp_aspath_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bgp_community_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> country_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vlans_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edited_by_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
  PROTOBUF_NAMESPACE_ID::Timestamp* cdate_;
  PROTOBUF_NAMESPACE_ID::Timestamp* edate_;
  ::kentik::flow_tag::v202404alpha1::AddressInfo* ip_;
  ::kentik::flow_tag::v202404alpha1::AddressInfo* mac_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class GetFlowTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.GetFlowTagRequest) */ {
 public:
  inline GetFlowTagRequest() : GetFlowTagRequest(nullptr) {};
  virtual ~GetFlowTagRequest();

  GetFlowTagRequest(const GetFlowTagRequest& from);
  GetFlowTagRequest(GetFlowTagRequest&& from) noexcept
    : GetFlowTagRequest() {
    *this = ::std::move(from);
  }

  inline GetFlowTagRequest& operator=(const GetFlowTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlowTagRequest& operator=(GetFlowTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlowTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlowTagRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlowTagRequest*>(
               &_GetFlowTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetFlowTagRequest& a, GetFlowTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlowTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlowTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlowTagRequest* New() const final {
    return CreateMaybeMessage<GetFlowTagRequest>(nullptr);
  }

  GetFlowTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlowTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlowTagRequest& from);
  void MergeFrom(const GetFlowTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlowTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.GetFlowTagRequest";
  }
  protected:
  explicit GetFlowTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.GetFlowTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class GetFlowTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.GetFlowTagResponse) */ {
 public:
  inline GetFlowTagResponse() : GetFlowTagResponse(nullptr) {};
  virtual ~GetFlowTagResponse();

  GetFlowTagResponse(const GetFlowTagResponse& from);
  GetFlowTagResponse(GetFlowTagResponse&& from) noexcept
    : GetFlowTagResponse() {
    *this = ::std::move(from);
  }

  inline GetFlowTagResponse& operator=(const GetFlowTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlowTagResponse& operator=(GetFlowTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetFlowTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFlowTagResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlowTagResponse*>(
               &_GetFlowTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetFlowTagResponse& a, GetFlowTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlowTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlowTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlowTagResponse* New() const final {
    return CreateMaybeMessage<GetFlowTagResponse>(nullptr);
  }

  GetFlowTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlowTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetFlowTagResponse& from);
  void MergeFrom(const GetFlowTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlowTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.GetFlowTagResponse";
  }
  protected:
  explicit GetFlowTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowTagFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
  bool has_flow_tag() const;
  private:
  bool _internal_has_flow_tag() const;
  public:
  void clear_flow_tag();
  const ::kentik::flow_tag::v202404alpha1::FlowTag& flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* release_flow_tag();
  ::kentik::flow_tag::v202404alpha1::FlowTag* mutable_flow_tag();
  void set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& _internal_flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* _internal_mutable_flow_tag();
  public:
  void unsafe_arena_set_allocated_flow_tag(
      ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  ::kentik::flow_tag::v202404alpha1::FlowTag* unsafe_arena_release_flow_tag();

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.GetFlowTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class SearchFlowTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest) */ {
 public:
  inline SearchFlowTagRequest() : SearchFlowTagRequest(nullptr) {};
  virtual ~SearchFlowTagRequest();

  SearchFlowTagRequest(const SearchFlowTagRequest& from);
  SearchFlowTagRequest(SearchFlowTagRequest&& from) noexcept
    : SearchFlowTagRequest() {
    *this = ::std::move(from);
  }

  inline SearchFlowTagRequest& operator=(const SearchFlowTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchFlowTagRequest& operator=(SearchFlowTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchFlowTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchFlowTagRequest* internal_default_instance() {
    return reinterpret_cast<const SearchFlowTagRequest*>(
               &_SearchFlowTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SearchFlowTagRequest& a, SearchFlowTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchFlowTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchFlowTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchFlowTagRequest* New() const final {
    return CreateMaybeMessage<SearchFlowTagRequest>(nullptr);
  }

  SearchFlowTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchFlowTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchFlowTagRequest& from);
  void MergeFrom(const SearchFlowTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchFlowTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.SearchFlowTagRequest";
  }
  protected:
  explicit SearchFlowTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.FlowTagSearch search = 1[json_name = "search"];
  bool has_search() const;
  private:
  bool _internal_has_search() const;
  public:
  void clear_search();
  const ::kentik::flow_tag::v202404alpha1::FlowTagSearch& search() const;
  ::kentik::flow_tag::v202404alpha1::FlowTagSearch* release_search();
  ::kentik::flow_tag::v202404alpha1::FlowTagSearch* mutable_search();
  void set_allocated_search(::kentik::flow_tag::v202404alpha1::FlowTagSearch* search);
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTagSearch& _internal_search() const;
  ::kentik::flow_tag::v202404alpha1::FlowTagSearch* _internal_mutable_search();
  public:
  void unsafe_arena_set_allocated_search(
      ::kentik::flow_tag::v202404alpha1::FlowTagSearch* search);
  ::kentik::flow_tag::v202404alpha1::FlowTagSearch* unsafe_arena_release_search();

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::flow_tag::v202404alpha1::FlowTagSearch* search_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class SearchFlowTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse) */ {
 public:
  inline SearchFlowTagResponse() : SearchFlowTagResponse(nullptr) {};
  virtual ~SearchFlowTagResponse();

  SearchFlowTagResponse(const SearchFlowTagResponse& from);
  SearchFlowTagResponse(SearchFlowTagResponse&& from) noexcept
    : SearchFlowTagResponse() {
    *this = ::std::move(from);
  }

  inline SearchFlowTagResponse& operator=(const SearchFlowTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchFlowTagResponse& operator=(SearchFlowTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchFlowTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchFlowTagResponse* internal_default_instance() {
    return reinterpret_cast<const SearchFlowTagResponse*>(
               &_SearchFlowTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SearchFlowTagResponse& a, SearchFlowTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchFlowTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchFlowTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchFlowTagResponse* New() const final {
    return CreateMaybeMessage<SearchFlowTagResponse>(nullptr);
  }

  SearchFlowTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchFlowTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchFlowTagResponse& from);
  void MergeFrom(const SearchFlowTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchFlowTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.SearchFlowTagResponse";
  }
  protected:
  explicit SearchFlowTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowTagsFieldNumber = 1,
    kTotalCountFieldNumber = 2,
    kInvalidCountFieldNumber = 3,
  };
  // repeated .kentik.flow_tag.v202404alpha1.FlowTag flow_tags = 1[json_name = "flowTags"];
  int flow_tags_size() const;
  private:
  int _internal_flow_tags_size() const;
  public:
  void clear_flow_tags();
  ::kentik::flow_tag::v202404alpha1::FlowTag* mutable_flow_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::FlowTag >*
      mutable_flow_tags();
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& _internal_flow_tags(int index) const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* _internal_add_flow_tags();
  public:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& flow_tags(int index) const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* add_flow_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::FlowTag >&
      flow_tags() const;

  // uint32 total_count = 2[json_name = "totalCount"];
  void clear_total_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_count() const;
  void set_total_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_count() const;
  void _internal_set_total_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 invalid_count = 3[json_name = "invalidCount"];
  void clear_invalid_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 invalid_count() const;
  void set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_invalid_count() const;
  void _internal_set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::FlowTag > flow_tags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 invalid_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class CreateFlowTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest) */ {
 public:
  inline CreateFlowTagRequest() : CreateFlowTagRequest(nullptr) {};
  virtual ~CreateFlowTagRequest();

  CreateFlowTagRequest(const CreateFlowTagRequest& from);
  CreateFlowTagRequest(CreateFlowTagRequest&& from) noexcept
    : CreateFlowTagRequest() {
    *this = ::std::move(from);
  }

  inline CreateFlowTagRequest& operator=(const CreateFlowTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlowTagRequest& operator=(CreateFlowTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateFlowTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateFlowTagRequest* internal_default_instance() {
    return reinterpret_cast<const CreateFlowTagRequest*>(
               &_CreateFlowTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateFlowTagRequest& a, CreateFlowTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlowTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlowTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateFlowTagRequest* New() const final {
    return CreateMaybeMessage<CreateFlowTagRequest>(nullptr);
  }

  CreateFlowTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateFlowTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateFlowTagRequest& from);
  void MergeFrom(const CreateFlowTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlowTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.CreateFlowTagRequest";
  }
  protected:
  explicit CreateFlowTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowTagFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
  bool has_flow_tag() const;
  private:
  bool _internal_has_flow_tag() const;
  public:
  void clear_flow_tag();
  const ::kentik::flow_tag::v202404alpha1::FlowTag& flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* release_flow_tag();
  ::kentik::flow_tag::v202404alpha1::FlowTag* mutable_flow_tag();
  void set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& _internal_flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* _internal_mutable_flow_tag();
  public:
  void unsafe_arena_set_allocated_flow_tag(
      ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  ::kentik::flow_tag::v202404alpha1::FlowTag* unsafe_arena_release_flow_tag();

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class CreateFlowTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse) */ {
 public:
  inline CreateFlowTagResponse() : CreateFlowTagResponse(nullptr) {};
  virtual ~CreateFlowTagResponse();

  CreateFlowTagResponse(const CreateFlowTagResponse& from);
  CreateFlowTagResponse(CreateFlowTagResponse&& from) noexcept
    : CreateFlowTagResponse() {
    *this = ::std::move(from);
  }

  inline CreateFlowTagResponse& operator=(const CreateFlowTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlowTagResponse& operator=(CreateFlowTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateFlowTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateFlowTagResponse* internal_default_instance() {
    return reinterpret_cast<const CreateFlowTagResponse*>(
               &_CreateFlowTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateFlowTagResponse& a, CreateFlowTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlowTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlowTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateFlowTagResponse* New() const final {
    return CreateMaybeMessage<CreateFlowTagResponse>(nullptr);
  }

  CreateFlowTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateFlowTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateFlowTagResponse& from);
  void MergeFrom(const CreateFlowTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlowTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.CreateFlowTagResponse";
  }
  protected:
  explicit CreateFlowTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowTagFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
  bool has_flow_tag() const;
  private:
  bool _internal_has_flow_tag() const;
  public:
  void clear_flow_tag();
  const ::kentik::flow_tag::v202404alpha1::FlowTag& flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* release_flow_tag();
  ::kentik::flow_tag::v202404alpha1::FlowTag* mutable_flow_tag();
  void set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& _internal_flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* _internal_mutable_flow_tag();
  public:
  void unsafe_arena_set_allocated_flow_tag(
      ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  ::kentik::flow_tag::v202404alpha1::FlowTag* unsafe_arena_release_flow_tag();

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class UpdateFlowTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest) */ {
 public:
  inline UpdateFlowTagRequest() : UpdateFlowTagRequest(nullptr) {};
  virtual ~UpdateFlowTagRequest();

  UpdateFlowTagRequest(const UpdateFlowTagRequest& from);
  UpdateFlowTagRequest(UpdateFlowTagRequest&& from) noexcept
    : UpdateFlowTagRequest() {
    *this = ::std::move(from);
  }

  inline UpdateFlowTagRequest& operator=(const UpdateFlowTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFlowTagRequest& operator=(UpdateFlowTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateFlowTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateFlowTagRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateFlowTagRequest*>(
               &_UpdateFlowTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateFlowTagRequest& a, UpdateFlowTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFlowTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFlowTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateFlowTagRequest* New() const final {
    return CreateMaybeMessage<UpdateFlowTagRequest>(nullptr);
  }

  UpdateFlowTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateFlowTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateFlowTagRequest& from);
  void MergeFrom(const UpdateFlowTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFlowTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest";
  }
  protected:
  explicit UpdateFlowTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowTagFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
  bool has_flow_tag() const;
  private:
  bool _internal_has_flow_tag() const;
  public:
  void clear_flow_tag();
  const ::kentik::flow_tag::v202404alpha1::FlowTag& flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* release_flow_tag();
  ::kentik::flow_tag::v202404alpha1::FlowTag* mutable_flow_tag();
  void set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& _internal_flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* _internal_mutable_flow_tag();
  public:
  void unsafe_arena_set_allocated_flow_tag(
      ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  ::kentik::flow_tag::v202404alpha1::FlowTag* unsafe_arena_release_flow_tag();

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class UpdateFlowTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse) */ {
 public:
  inline UpdateFlowTagResponse() : UpdateFlowTagResponse(nullptr) {};
  virtual ~UpdateFlowTagResponse();

  UpdateFlowTagResponse(const UpdateFlowTagResponse& from);
  UpdateFlowTagResponse(UpdateFlowTagResponse&& from) noexcept
    : UpdateFlowTagResponse() {
    *this = ::std::move(from);
  }

  inline UpdateFlowTagResponse& operator=(const UpdateFlowTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFlowTagResponse& operator=(UpdateFlowTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateFlowTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateFlowTagResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateFlowTagResponse*>(
               &_UpdateFlowTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateFlowTagResponse& a, UpdateFlowTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFlowTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFlowTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateFlowTagResponse* New() const final {
    return CreateMaybeMessage<UpdateFlowTagResponse>(nullptr);
  }

  UpdateFlowTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateFlowTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateFlowTagResponse& from);
  void MergeFrom(const UpdateFlowTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFlowTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse";
  }
  protected:
  explicit UpdateFlowTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowTagFieldNumber = 1,
  };
  // .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
  bool has_flow_tag() const;
  private:
  bool _internal_has_flow_tag() const;
  public:
  void clear_flow_tag();
  const ::kentik::flow_tag::v202404alpha1::FlowTag& flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* release_flow_tag();
  ::kentik::flow_tag::v202404alpha1::FlowTag* mutable_flow_tag();
  void set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  private:
  const ::kentik::flow_tag::v202404alpha1::FlowTag& _internal_flow_tag() const;
  ::kentik::flow_tag::v202404alpha1::FlowTag* _internal_mutable_flow_tag();
  public:
  void unsafe_arena_set_allocated_flow_tag(
      ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag);
  ::kentik::flow_tag::v202404alpha1::FlowTag* unsafe_arena_release_flow_tag();

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class DeleteFlowTagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest) */ {
 public:
  inline DeleteFlowTagRequest() : DeleteFlowTagRequest(nullptr) {};
  virtual ~DeleteFlowTagRequest();

  DeleteFlowTagRequest(const DeleteFlowTagRequest& from);
  DeleteFlowTagRequest(DeleteFlowTagRequest&& from) noexcept
    : DeleteFlowTagRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFlowTagRequest& operator=(const DeleteFlowTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlowTagRequest& operator=(DeleteFlowTagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteFlowTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteFlowTagRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFlowTagRequest*>(
               &_DeleteFlowTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteFlowTagRequest& a, DeleteFlowTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlowTagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlowTagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteFlowTagRequest* New() const final {
    return CreateMaybeMessage<DeleteFlowTagRequest>(nullptr);
  }

  DeleteFlowTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteFlowTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteFlowTagRequest& from);
  void MergeFrom(const DeleteFlowTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFlowTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest";
  }
  protected:
  explicit DeleteFlowTagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1[json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// -------------------------------------------------------------------

class DeleteFlowTagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kentik.flow_tag.v202404alpha1.DeleteFlowTagResponse) */ {
 public:
  inline DeleteFlowTagResponse() : DeleteFlowTagResponse(nullptr) {};
  virtual ~DeleteFlowTagResponse();

  DeleteFlowTagResponse(const DeleteFlowTagResponse& from);
  DeleteFlowTagResponse(DeleteFlowTagResponse&& from) noexcept
    : DeleteFlowTagResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFlowTagResponse& operator=(const DeleteFlowTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFlowTagResponse& operator=(DeleteFlowTagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteFlowTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteFlowTagResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFlowTagResponse*>(
               &_DeleteFlowTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteFlowTagResponse& a, DeleteFlowTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFlowTagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFlowTagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteFlowTagResponse* New() const final {
    return CreateMaybeMessage<DeleteFlowTagResponse>(nullptr);
  }

  DeleteFlowTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteFlowTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteFlowTagResponse& from);
  void MergeFrom(const DeleteFlowTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFlowTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kentik.flow_tag.v202404alpha1.DeleteFlowTagResponse";
  }
  protected:
  explicit DeleteFlowTagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto);
    return ::descriptor_table_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kentik.flow_tag.v202404alpha1.DeleteFlowTagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Model

// .kentik.flow_tag.v202404alpha1.ModelType type = 1[json_name = "type"];
inline void Model::clear_type() {
  type_ = 0;
}
inline ::kentik::flow_tag::v202404alpha1::ModelType Model::_internal_type() const {
  return static_cast< ::kentik::flow_tag::v202404alpha1::ModelType >(type_);
}
inline ::kentik::flow_tag::v202404alpha1::ModelType Model::type() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.Model.type)
  return _internal_type();
}
inline void Model::_internal_set_type(::kentik::flow_tag::v202404alpha1::ModelType value) {
  
  type_ = value;
}
inline void Model::set_type(::kentik::flow_tag::v202404alpha1::ModelType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.Model.type)
}

// -------------------------------------------------------------------

// OrderField

// .kentik.flow_tag.v202404alpha1.LookupField field = 1[json_name = "field"];
inline void OrderField::clear_field() {
  field_ = 0;
}
inline ::kentik::flow_tag::v202404alpha1::LookupField OrderField::_internal_field() const {
  return static_cast< ::kentik::flow_tag::v202404alpha1::LookupField >(field_);
}
inline ::kentik::flow_tag::v202404alpha1::LookupField OrderField::field() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.OrderField.field)
  return _internal_field();
}
inline void OrderField::_internal_set_field(::kentik::flow_tag::v202404alpha1::LookupField value) {
  
  field_ = value;
}
inline void OrderField::set_field(::kentik::flow_tag::v202404alpha1::LookupField value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.OrderField.field)
}

// .kentik.flow_tag.v202404alpha1.OrderDirection direction = 2[json_name = "direction"];
inline void OrderField::clear_direction() {
  direction_ = 0;
}
inline ::kentik::flow_tag::v202404alpha1::OrderDirection OrderField::_internal_direction() const {
  return static_cast< ::kentik::flow_tag::v202404alpha1::OrderDirection >(direction_);
}
inline ::kentik::flow_tag::v202404alpha1::OrderDirection OrderField::direction() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.OrderField.direction)
  return _internal_direction();
}
inline void OrderField::_internal_set_direction(::kentik::flow_tag::v202404alpha1::OrderDirection value) {
  
  direction_ = value;
}
inline void OrderField::set_direction(::kentik::flow_tag::v202404alpha1::OrderDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.OrderField.direction)
}

// -------------------------------------------------------------------

// FlowTagSearch

// int32 limit = 1[json_name = "limit"];
inline void FlowTagSearch::clear_limit() {
  limit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowTagSearch::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowTagSearch::limit() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTagSearch.limit)
  return _internal_limit();
}
inline void FlowTagSearch::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limit_ = value;
}
inline void FlowTagSearch::set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTagSearch.limit)
}

// int32 offset = 2[json_name = "offset"];
inline void FlowTagSearch::clear_offset() {
  offset_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowTagSearch::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowTagSearch::offset() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTagSearch.offset)
  return _internal_offset();
}
inline void FlowTagSearch::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  offset_ = value;
}
inline void FlowTagSearch::set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTagSearch.offset)
}

// repeated .kentik.flow_tag.v202404alpha1.LookupField lookup_fields = 3[json_name = "lookupFields"];
inline int FlowTagSearch::_internal_lookup_fields_size() const {
  return lookup_fields_.size();
}
inline int FlowTagSearch::lookup_fields_size() const {
  return _internal_lookup_fields_size();
}
inline void FlowTagSearch::clear_lookup_fields() {
  lookup_fields_.Clear();
}
inline ::kentik::flow_tag::v202404alpha1::LookupField FlowTagSearch::_internal_lookup_fields(int index) const {
  return static_cast< ::kentik::flow_tag::v202404alpha1::LookupField >(lookup_fields_.Get(index));
}
inline ::kentik::flow_tag::v202404alpha1::LookupField FlowTagSearch::lookup_fields(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_fields)
  return _internal_lookup_fields(index);
}
inline void FlowTagSearch::set_lookup_fields(int index, ::kentik::flow_tag::v202404alpha1::LookupField value) {
  lookup_fields_.Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_fields)
}
inline void FlowTagSearch::_internal_add_lookup_fields(::kentik::flow_tag::v202404alpha1::LookupField value) {
  lookup_fields_.Add(value);
}
inline void FlowTagSearch::add_lookup_fields(::kentik::flow_tag::v202404alpha1::LookupField value) {
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_fields)
  _internal_add_lookup_fields(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
FlowTagSearch::lookup_fields() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_fields)
  return lookup_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FlowTagSearch::_internal_mutable_lookup_fields() {
  return &lookup_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FlowTagSearch::mutable_lookup_fields() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_fields)
  return _internal_mutable_lookup_fields();
}

// repeated string lookup_values = 4[json_name = "lookupValues"];
inline int FlowTagSearch::_internal_lookup_values_size() const {
  return lookup_values_.size();
}
inline int FlowTagSearch::lookup_values_size() const {
  return _internal_lookup_values_size();
}
inline void FlowTagSearch::clear_lookup_values() {
  lookup_values_.Clear();
}
inline std::string* FlowTagSearch::add_lookup_values() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  return _internal_add_lookup_values();
}
inline const std::string& FlowTagSearch::_internal_lookup_values(int index) const {
  return lookup_values_.Get(index);
}
inline const std::string& FlowTagSearch::lookup_values(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  return _internal_lookup_values(index);
}
inline std::string* FlowTagSearch::mutable_lookup_values(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  return lookup_values_.Mutable(index);
}
inline void FlowTagSearch::set_lookup_values(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  lookup_values_.Mutable(index)->assign(value);
}
inline void FlowTagSearch::set_lookup_values(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  lookup_values_.Mutable(index)->assign(std::move(value));
}
inline void FlowTagSearch::set_lookup_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lookup_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
}
inline void FlowTagSearch::set_lookup_values(int index, const char* value, size_t size) {
  lookup_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
}
inline std::string* FlowTagSearch::_internal_add_lookup_values() {
  return lookup_values_.Add();
}
inline void FlowTagSearch::add_lookup_values(const std::string& value) {
  lookup_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
}
inline void FlowTagSearch::add_lookup_values(std::string&& value) {
  lookup_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
}
inline void FlowTagSearch::add_lookup_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lookup_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
}
inline void FlowTagSearch::add_lookup_values(const char* value, size_t size) {
  lookup_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTagSearch::lookup_values() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  return lookup_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTagSearch::mutable_lookup_values() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTagSearch.lookup_values)
  return &lookup_values_;
}

// repeated .kentik.flow_tag.v202404alpha1.OrderField order_by = 5[json_name = "orderBy"];
inline int FlowTagSearch::_internal_order_by_size() const {
  return order_by_.size();
}
inline int FlowTagSearch::order_by_size() const {
  return _internal_order_by_size();
}
inline void FlowTagSearch::clear_order_by() {
  order_by_.Clear();
}
inline ::kentik::flow_tag::v202404alpha1::OrderField* FlowTagSearch::mutable_order_by(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTagSearch.order_by)
  return order_by_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::OrderField >*
FlowTagSearch::mutable_order_by() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTagSearch.order_by)
  return &order_by_;
}
inline const ::kentik::flow_tag::v202404alpha1::OrderField& FlowTagSearch::_internal_order_by(int index) const {
  return order_by_.Get(index);
}
inline const ::kentik::flow_tag::v202404alpha1::OrderField& FlowTagSearch::order_by(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTagSearch.order_by)
  return _internal_order_by(index);
}
inline ::kentik::flow_tag::v202404alpha1::OrderField* FlowTagSearch::_internal_add_order_by() {
  return order_by_.Add();
}
inline ::kentik::flow_tag::v202404alpha1::OrderField* FlowTagSearch::add_order_by() {
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTagSearch.order_by)
  return _internal_add_order_by();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::OrderField >&
FlowTagSearch::order_by() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTagSearch.order_by)
  return order_by_;
}

// int32 field_limit = 6[json_name = "fieldLimit"];
inline void FlowTagSearch::clear_field_limit() {
  field_limit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowTagSearch::_internal_field_limit() const {
  return field_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowTagSearch::field_limit() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTagSearch.field_limit)
  return _internal_field_limit();
}
inline void FlowTagSearch::_internal_set_field_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  field_limit_ = value;
}
inline void FlowTagSearch::set_field_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_limit(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTagSearch.field_limit)
}

// -------------------------------------------------------------------

// AddressInfo

// repeated string addresses = 1[json_name = "addresses"];
inline int AddressInfo::_internal_addresses_size() const {
  return addresses_.size();
}
inline int AddressInfo::addresses_size() const {
  return _internal_addresses_size();
}
inline void AddressInfo::clear_addresses() {
  addresses_.Clear();
}
inline std::string* AddressInfo::add_addresses() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  return _internal_add_addresses();
}
inline const std::string& AddressInfo::_internal_addresses(int index) const {
  return addresses_.Get(index);
}
inline const std::string& AddressInfo::addresses(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  return _internal_addresses(index);
}
inline std::string* AddressInfo::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  return addresses_.Mutable(index);
}
inline void AddressInfo::set_addresses(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  addresses_.Mutable(index)->assign(value);
}
inline void AddressInfo::set_addresses(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  addresses_.Mutable(index)->assign(std::move(value));
}
inline void AddressInfo::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
}
inline void AddressInfo::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
}
inline std::string* AddressInfo::_internal_add_addresses() {
  return addresses_.Add();
}
inline void AddressInfo::add_addresses(const std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
}
inline void AddressInfo::add_addresses(std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
}
inline void AddressInfo::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
}
inline void AddressInfo::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AddressInfo::addresses() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  return addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AddressInfo::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.AddressInfo.addresses)
  return &addresses_;
}

// int32 total_count = 2[json_name = "totalCount"];
inline void AddressInfo::clear_total_count() {
  total_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddressInfo::_internal_total_count() const {
  return total_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddressInfo::total_count() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.AddressInfo.total_count)
  return _internal_total_count();
}
inline void AddressInfo::_internal_set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  total_count_ = value;
}
inline void AddressInfo::set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.AddressInfo.total_count)
}

// -------------------------------------------------------------------

// FlowTag

// string id = 1[json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void FlowTag::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlowTag::id() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.id)
  return _internal_id();
}
inline void FlowTag::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.id)
}
inline std::string* FlowTag::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.id)
  return _internal_mutable_id();
}
inline const std::string& FlowTag::_internal_id() const {
  return id_.Get();
}
inline void FlowTag::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlowTag::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.flow_tag.v202404alpha1.FlowTag.id)
}
inline void FlowTag::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.id)
}
inline void FlowTag::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.id)
}
inline std::string* FlowTag::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlowTag::release_id() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlowTag::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.id)
}
inline std::string* FlowTag::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.flow_tag.v202404alpha1.FlowTag.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlowTag::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.id)
}

// string name = 3[json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void FlowTag::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlowTag::name() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.name)
  return _internal_name();
}
inline void FlowTag::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.name)
}
inline std::string* FlowTag::mutable_name() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.name)
  return _internal_mutable_name();
}
inline const std::string& FlowTag::_internal_name() const {
  return name_.Get();
}
inline void FlowTag::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlowTag::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.flow_tag.v202404alpha1.FlowTag.name)
}
inline void FlowTag::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.name)
}
inline void FlowTag::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.name)
}
inline std::string* FlowTag::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlowTag::release_name() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlowTag::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.name)
}
inline std::string* FlowTag::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.flow_tag.v202404alpha1.FlowTag.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlowTag::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.name)
}

// string edited_by = 4[json_name = "editedBy", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void FlowTag::clear_edited_by() {
  edited_by_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlowTag::edited_by() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
  return _internal_edited_by();
}
inline void FlowTag::set_edited_by(const std::string& value) {
  _internal_set_edited_by(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
}
inline std::string* FlowTag::mutable_edited_by() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
  return _internal_mutable_edited_by();
}
inline const std::string& FlowTag::_internal_edited_by() const {
  return edited_by_.Get();
}
inline void FlowTag::_internal_set_edited_by(const std::string& value) {
  
  edited_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlowTag::set_edited_by(std::string&& value) {
  
  edited_by_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
}
inline void FlowTag::set_edited_by(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  edited_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
}
inline void FlowTag::set_edited_by(const char* value,
    size_t size) {
  
  edited_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
}
inline std::string* FlowTag::_internal_mutable_edited_by() {
  
  return edited_by_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlowTag::release_edited_by() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
  return edited_by_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlowTag::set_allocated_edited_by(std::string* edited_by) {
  if (edited_by != nullptr) {
    
  } else {
    
  }
  edited_by_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edited_by,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
}
inline std::string* FlowTag::unsafe_arena_release_edited_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return edited_by_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlowTag::unsafe_arena_set_allocated_edited_by(
    std::string* edited_by) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (edited_by != nullptr) {
    
  } else {
    
  }
  edited_by_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      edited_by, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.edited_by)
}

// string created_by = 25[json_name = "createdBy", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void FlowTag::clear_created_by() {
  created_by_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FlowTag::created_by() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
  return _internal_created_by();
}
inline void FlowTag::set_created_by(const std::string& value) {
  _internal_set_created_by(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
}
inline std::string* FlowTag::mutable_created_by() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
  return _internal_mutable_created_by();
}
inline const std::string& FlowTag::_internal_created_by() const {
  return created_by_.Get();
}
inline void FlowTag::_internal_set_created_by(const std::string& value) {
  
  created_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FlowTag::set_created_by(std::string&& value) {
  
  created_by_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
}
inline void FlowTag::set_created_by(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  created_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
}
inline void FlowTag::set_created_by(const char* value,
    size_t size) {
  
  created_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
}
inline std::string* FlowTag::_internal_mutable_created_by() {
  
  return created_by_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FlowTag::release_created_by() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
  return created_by_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FlowTag::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  created_by_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), created_by,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
}
inline std::string* FlowTag::unsafe_arena_release_created_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return created_by_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FlowTag::unsafe_arena_set_allocated_created_by(
    std::string* created_by) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (created_by != nullptr) {
    
  } else {
    
  }
  created_by_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      created_by, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.created_by)
}

// .google.protobuf.Timestamp cdate = 5[json_name = "cdate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool FlowTag::_internal_has_cdate() const {
  return this != internal_default_instance() && cdate_ != nullptr;
}
inline bool FlowTag::has_cdate() const {
  return _internal_has_cdate();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& FlowTag::_internal_cdate() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = cdate_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& FlowTag::cdate() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.cdate)
  return _internal_cdate();
}
inline void FlowTag::unsafe_arena_set_allocated_cdate(
    PROTOBUF_NAMESPACE_ID::Timestamp* cdate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdate_);
  }
  cdate_ = cdate;
  if (cdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.cdate)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::release_cdate() {
  auto temp = unsafe_arena_release_cdate();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::unsafe_arena_release_cdate() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.cdate)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = cdate_;
  cdate_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::_internal_mutable_cdate() {
  
  if (cdate_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    cdate_ = p;
  }
  return cdate_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::mutable_cdate() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.cdate)
  return _internal_mutable_cdate();
}
inline void FlowTag::set_allocated_cdate(PROTOBUF_NAMESPACE_ID::Timestamp* cdate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdate_);
  }
  if (cdate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cdate)->GetArena();
    if (message_arena != submessage_arena) {
      cdate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cdate, submessage_arena);
    }
    
  } else {
    
  }
  cdate_ = cdate;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.cdate)
}

// .google.protobuf.Timestamp edate = 6[json_name = "edate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool FlowTag::_internal_has_edate() const {
  return this != internal_default_instance() && edate_ != nullptr;
}
inline bool FlowTag::has_edate() const {
  return _internal_has_edate();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& FlowTag::_internal_edate() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = edate_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& FlowTag::edate() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.edate)
  return _internal_edate();
}
inline void FlowTag::unsafe_arena_set_allocated_edate(
    PROTOBUF_NAMESPACE_ID::Timestamp* edate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edate_);
  }
  edate_ = edate;
  if (edate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.edate)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::release_edate() {
  auto temp = unsafe_arena_release_edate();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::unsafe_arena_release_edate() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.edate)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = edate_;
  edate_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::_internal_mutable_edate() {
  
  if (edate_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    edate_ = p;
  }
  return edate_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FlowTag::mutable_edate() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.edate)
  return _internal_mutable_edate();
}
inline void FlowTag::set_allocated_edate(PROTOBUF_NAMESPACE_ID::Timestamp* edate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(edate_);
  }
  if (edate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edate)->GetArena();
    if (message_arena != submessage_arena) {
      edate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edate, submessage_arena);
    }
    
  } else {
    
  }
  edate_ = edate;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.edate)
}

// .kentik.flow_tag.v202404alpha1.AddressInfo ip = 7[json_name = "ip", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool FlowTag::_internal_has_ip() const {
  return this != internal_default_instance() && ip_ != nullptr;
}
inline bool FlowTag::has_ip() const {
  return _internal_has_ip();
}
inline void FlowTag::clear_ip() {
  if (GetArena() == nullptr && ip_ != nullptr) {
    delete ip_;
  }
  ip_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::AddressInfo& FlowTag::_internal_ip() const {
  const ::kentik::flow_tag::v202404alpha1::AddressInfo* p = ip_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::AddressInfo*>(
      &::kentik::flow_tag::v202404alpha1::_AddressInfo_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::AddressInfo& FlowTag::ip() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.ip)
  return _internal_ip();
}
inline void FlowTag::unsafe_arena_set_allocated_ip(
    ::kentik::flow_tag::v202404alpha1::AddressInfo* ip) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  ip_ = ip;
  if (ip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.ip)
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::release_ip() {
  auto temp = unsafe_arena_release_ip();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.ip)
  
  ::kentik::flow_tag::v202404alpha1::AddressInfo* temp = ip_;
  ip_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::_internal_mutable_ip() {
  
  if (ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::AddressInfo>(GetArena());
    ip_ = p;
  }
  return ip_;
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.ip)
  return _internal_mutable_ip();
}
inline void FlowTag::set_allocated_ip(::kentik::flow_tag::v202404alpha1::AddressInfo* ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ip_;
  }
  if (ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ip);
    if (message_arena != submessage_arena) {
      ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    
  } else {
    
  }
  ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.ip)
}

// repeated string port = 8[json_name = "port", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_port_size() const {
  return port_.size();
}
inline int FlowTag::port_size() const {
  return _internal_port_size();
}
inline void FlowTag::clear_port() {
  port_.Clear();
}
inline std::string* FlowTag::add_port() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.port)
  return _internal_add_port();
}
inline const std::string& FlowTag::_internal_port(int index) const {
  return port_.Get(index);
}
inline const std::string& FlowTag::port(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.port)
  return _internal_port(index);
}
inline std::string* FlowTag::mutable_port(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.port)
  return port_.Mutable(index);
}
inline void FlowTag::set_port(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.port)
  port_.Mutable(index)->assign(value);
}
inline void FlowTag::set_port(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.port)
  port_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_port(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  port_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.port)
}
inline void FlowTag::set_port(int index, const char* value, size_t size) {
  port_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.port)
}
inline std::string* FlowTag::_internal_add_port() {
  return port_.Add();
}
inline void FlowTag::add_port(const std::string& value) {
  port_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.port)
}
inline void FlowTag::add_port(std::string&& value) {
  port_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.port)
}
inline void FlowTag::add_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  port_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.port)
}
inline void FlowTag::add_port(const char* value, size_t size) {
  port_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.port)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::port() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.port)
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_port() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.port)
  return &port_;
}

// uint32 tcp_flags = 9[json_name = "tcpFlags", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void FlowTag::clear_tcp_flags() {
  tcp_flags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowTag::_internal_tcp_flags() const {
  return tcp_flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowTag::tcp_flags() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.tcp_flags)
  return _internal_tcp_flags();
}
inline void FlowTag::_internal_set_tcp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tcp_flags_ = value;
}
inline void FlowTag::set_tcp_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tcp_flags(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.tcp_flags)
}

// repeated uint32 protocol = 10[json_name = "protocol", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_protocol_size() const {
  return protocol_.size();
}
inline int FlowTag::protocol_size() const {
  return _internal_protocol_size();
}
inline void FlowTag::clear_protocol() {
  protocol_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowTag::_internal_protocol(int index) const {
  return protocol_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowTag::protocol(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.protocol)
  return _internal_protocol(index);
}
inline void FlowTag::set_protocol(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  protocol_.Set(index, value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.protocol)
}
inline void FlowTag::_internal_add_protocol(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  protocol_.Add(value);
}
inline void FlowTag::add_protocol(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_protocol(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.protocol)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
FlowTag::_internal_protocol() const {
  return protocol_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
FlowTag::protocol() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.protocol)
  return _internal_protocol();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
FlowTag::_internal_mutable_protocol() {
  return &protocol_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
FlowTag::mutable_protocol() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.protocol)
  return _internal_mutable_protocol();
}

// repeated string device_name = 11[json_name = "deviceName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_device_name_size() const {
  return device_name_.size();
}
inline int FlowTag::device_name_size() const {
  return _internal_device_name_size();
}
inline void FlowTag::clear_device_name() {
  device_name_.Clear();
}
inline std::string* FlowTag::add_device_name() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  return _internal_add_device_name();
}
inline const std::string& FlowTag::_internal_device_name(int index) const {
  return device_name_.Get(index);
}
inline const std::string& FlowTag::device_name(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  return _internal_device_name(index);
}
inline std::string* FlowTag::mutable_device_name(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  return device_name_.Mutable(index);
}
inline void FlowTag::set_device_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  device_name_.Mutable(index)->assign(value);
}
inline void FlowTag::set_device_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  device_name_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_device_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
}
inline void FlowTag::set_device_name(int index, const char* value, size_t size) {
  device_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
}
inline std::string* FlowTag::_internal_add_device_name() {
  return device_name_.Add();
}
inline void FlowTag::add_device_name(const std::string& value) {
  device_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
}
inline void FlowTag::add_device_name(std::string&& value) {
  device_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
}
inline void FlowTag::add_device_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
}
inline void FlowTag::add_device_name(const char* value, size_t size) {
  device_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::device_name() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  return device_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_device_name() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.device_name)
  return &device_name_;
}

// repeated string device_type = 12[json_name = "deviceType", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_device_type_size() const {
  return device_type_.size();
}
inline int FlowTag::device_type_size() const {
  return _internal_device_type_size();
}
inline void FlowTag::clear_device_type() {
  device_type_.Clear();
}
inline std::string* FlowTag::add_device_type() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  return _internal_add_device_type();
}
inline const std::string& FlowTag::_internal_device_type(int index) const {
  return device_type_.Get(index);
}
inline const std::string& FlowTag::device_type(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  return _internal_device_type(index);
}
inline std::string* FlowTag::mutable_device_type(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  return device_type_.Mutable(index);
}
inline void FlowTag::set_device_type(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  device_type_.Mutable(index)->assign(value);
}
inline void FlowTag::set_device_type(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  device_type_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_device_type(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
}
inline void FlowTag::set_device_type(int index, const char* value, size_t size) {
  device_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
}
inline std::string* FlowTag::_internal_add_device_type() {
  return device_type_.Add();
}
inline void FlowTag::add_device_type(const std::string& value) {
  device_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
}
inline void FlowTag::add_device_type(std::string&& value) {
  device_type_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
}
inline void FlowTag::add_device_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
}
inline void FlowTag::add_device_type(const char* value, size_t size) {
  device_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::device_type() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  return device_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_device_type() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.device_type)
  return &device_type_;
}

// repeated string site = 13[json_name = "site", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_site_size() const {
  return site_.size();
}
inline int FlowTag::site_size() const {
  return _internal_site_size();
}
inline void FlowTag::clear_site() {
  site_.Clear();
}
inline std::string* FlowTag::add_site() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.site)
  return _internal_add_site();
}
inline const std::string& FlowTag::_internal_site(int index) const {
  return site_.Get(index);
}
inline const std::string& FlowTag::site(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.site)
  return _internal_site(index);
}
inline std::string* FlowTag::mutable_site(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.site)
  return site_.Mutable(index);
}
inline void FlowTag::set_site(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.site)
  site_.Mutable(index)->assign(value);
}
inline void FlowTag::set_site(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.site)
  site_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_site(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  site_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.site)
}
inline void FlowTag::set_site(int index, const char* value, size_t size) {
  site_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.site)
}
inline std::string* FlowTag::_internal_add_site() {
  return site_.Add();
}
inline void FlowTag::add_site(const std::string& value) {
  site_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.site)
}
inline void FlowTag::add_site(std::string&& value) {
  site_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.site)
}
inline void FlowTag::add_site(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  site_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.site)
}
inline void FlowTag::add_site(const char* value, size_t size) {
  site_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.site)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::site() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.site)
  return site_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_site() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.site)
  return &site_;
}

// repeated string interface_name = 14[json_name = "interfaceName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_interface_name_size() const {
  return interface_name_.size();
}
inline int FlowTag::interface_name_size() const {
  return _internal_interface_name_size();
}
inline void FlowTag::clear_interface_name() {
  interface_name_.Clear();
}
inline std::string* FlowTag::add_interface_name() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  return _internal_add_interface_name();
}
inline const std::string& FlowTag::_internal_interface_name(int index) const {
  return interface_name_.Get(index);
}
inline const std::string& FlowTag::interface_name(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  return _internal_interface_name(index);
}
inline std::string* FlowTag::mutable_interface_name(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  return interface_name_.Mutable(index);
}
inline void FlowTag::set_interface_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  interface_name_.Mutable(index)->assign(value);
}
inline void FlowTag::set_interface_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  interface_name_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_interface_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  interface_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
}
inline void FlowTag::set_interface_name(int index, const char* value, size_t size) {
  interface_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
}
inline std::string* FlowTag::_internal_add_interface_name() {
  return interface_name_.Add();
}
inline void FlowTag::add_interface_name(const std::string& value) {
  interface_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
}
inline void FlowTag::add_interface_name(std::string&& value) {
  interface_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
}
inline void FlowTag::add_interface_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  interface_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
}
inline void FlowTag::add_interface_name(const char* value, size_t size) {
  interface_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::interface_name() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  return interface_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_interface_name() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.interface_name)
  return &interface_name_;
}

// repeated string asn = 15[json_name = "asn", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_asn_size() const {
  return asn_.size();
}
inline int FlowTag::asn_size() const {
  return _internal_asn_size();
}
inline void FlowTag::clear_asn() {
  asn_.Clear();
}
inline std::string* FlowTag::add_asn() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  return _internal_add_asn();
}
inline const std::string& FlowTag::_internal_asn(int index) const {
  return asn_.Get(index);
}
inline const std::string& FlowTag::asn(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  return _internal_asn(index);
}
inline std::string* FlowTag::mutable_asn(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  return asn_.Mutable(index);
}
inline void FlowTag::set_asn(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  asn_.Mutable(index)->assign(value);
}
inline void FlowTag::set_asn(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  asn_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_asn(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  asn_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.asn)
}
inline void FlowTag::set_asn(int index, const char* value, size_t size) {
  asn_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.asn)
}
inline std::string* FlowTag::_internal_add_asn() {
  return asn_.Add();
}
inline void FlowTag::add_asn(const std::string& value) {
  asn_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.asn)
}
inline void FlowTag::add_asn(std::string&& value) {
  asn_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.asn)
}
inline void FlowTag::add_asn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  asn_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.asn)
}
inline void FlowTag::add_asn(const char* value, size_t size) {
  asn_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.asn)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::asn() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  return asn_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_asn() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.asn)
  return &asn_;
}

// repeated string lasthop_as_name = 16[json_name = "lasthopAsName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_lasthop_as_name_size() const {
  return lasthop_as_name_.size();
}
inline int FlowTag::lasthop_as_name_size() const {
  return _internal_lasthop_as_name_size();
}
inline void FlowTag::clear_lasthop_as_name() {
  lasthop_as_name_.Clear();
}
inline std::string* FlowTag::add_lasthop_as_name() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  return _internal_add_lasthop_as_name();
}
inline const std::string& FlowTag::_internal_lasthop_as_name(int index) const {
  return lasthop_as_name_.Get(index);
}
inline const std::string& FlowTag::lasthop_as_name(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  return _internal_lasthop_as_name(index);
}
inline std::string* FlowTag::mutable_lasthop_as_name(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  return lasthop_as_name_.Mutable(index);
}
inline void FlowTag::set_lasthop_as_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  lasthop_as_name_.Mutable(index)->assign(value);
}
inline void FlowTag::set_lasthop_as_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  lasthop_as_name_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_lasthop_as_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lasthop_as_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
}
inline void FlowTag::set_lasthop_as_name(int index, const char* value, size_t size) {
  lasthop_as_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
}
inline std::string* FlowTag::_internal_add_lasthop_as_name() {
  return lasthop_as_name_.Add();
}
inline void FlowTag::add_lasthop_as_name(const std::string& value) {
  lasthop_as_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
}
inline void FlowTag::add_lasthop_as_name(std::string&& value) {
  lasthop_as_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
}
inline void FlowTag::add_lasthop_as_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lasthop_as_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
}
inline void FlowTag::add_lasthop_as_name(const char* value, size_t size) {
  lasthop_as_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::lasthop_as_name() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  return lasthop_as_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_lasthop_as_name() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.lasthop_as_name)
  return &lasthop_as_name_;
}

// repeated string nexthop_asn = 17[json_name = "nexthopAsn", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_nexthop_asn_size() const {
  return nexthop_asn_.size();
}
inline int FlowTag::nexthop_asn_size() const {
  return _internal_nexthop_asn_size();
}
inline void FlowTag::clear_nexthop_asn() {
  nexthop_asn_.Clear();
}
inline std::string* FlowTag::add_nexthop_asn() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  return _internal_add_nexthop_asn();
}
inline const std::string& FlowTag::_internal_nexthop_asn(int index) const {
  return nexthop_asn_.Get(index);
}
inline const std::string& FlowTag::nexthop_asn(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  return _internal_nexthop_asn(index);
}
inline std::string* FlowTag::mutable_nexthop_asn(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  return nexthop_asn_.Mutable(index);
}
inline void FlowTag::set_nexthop_asn(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  nexthop_asn_.Mutable(index)->assign(value);
}
inline void FlowTag::set_nexthop_asn(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  nexthop_asn_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_nexthop_asn(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_asn_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
}
inline void FlowTag::set_nexthop_asn(int index, const char* value, size_t size) {
  nexthop_asn_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
}
inline std::string* FlowTag::_internal_add_nexthop_asn() {
  return nexthop_asn_.Add();
}
inline void FlowTag::add_nexthop_asn(const std::string& value) {
  nexthop_asn_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
}
inline void FlowTag::add_nexthop_asn(std::string&& value) {
  nexthop_asn_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
}
inline void FlowTag::add_nexthop_asn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_asn_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
}
inline void FlowTag::add_nexthop_asn(const char* value, size_t size) {
  nexthop_asn_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::nexthop_asn() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  return nexthop_asn_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_nexthop_asn() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_asn)
  return &nexthop_asn_;
}

// repeated string nexthop_as_name = 18[json_name = "nexthopAsName", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_nexthop_as_name_size() const {
  return nexthop_as_name_.size();
}
inline int FlowTag::nexthop_as_name_size() const {
  return _internal_nexthop_as_name_size();
}
inline void FlowTag::clear_nexthop_as_name() {
  nexthop_as_name_.Clear();
}
inline std::string* FlowTag::add_nexthop_as_name() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  return _internal_add_nexthop_as_name();
}
inline const std::string& FlowTag::_internal_nexthop_as_name(int index) const {
  return nexthop_as_name_.Get(index);
}
inline const std::string& FlowTag::nexthop_as_name(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  return _internal_nexthop_as_name(index);
}
inline std::string* FlowTag::mutable_nexthop_as_name(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  return nexthop_as_name_.Mutable(index);
}
inline void FlowTag::set_nexthop_as_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  nexthop_as_name_.Mutable(index)->assign(value);
}
inline void FlowTag::set_nexthop_as_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  nexthop_as_name_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_nexthop_as_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_as_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
}
inline void FlowTag::set_nexthop_as_name(int index, const char* value, size_t size) {
  nexthop_as_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
}
inline std::string* FlowTag::_internal_add_nexthop_as_name() {
  return nexthop_as_name_.Add();
}
inline void FlowTag::add_nexthop_as_name(const std::string& value) {
  nexthop_as_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
}
inline void FlowTag::add_nexthop_as_name(std::string&& value) {
  nexthop_as_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
}
inline void FlowTag::add_nexthop_as_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_as_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
}
inline void FlowTag::add_nexthop_as_name(const char* value, size_t size) {
  nexthop_as_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::nexthop_as_name() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  return nexthop_as_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_nexthop_as_name() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.nexthop_as_name)
  return &nexthop_as_name_;
}

// repeated string nexthop = 19[json_name = "nexthop", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_nexthop_size() const {
  return nexthop_.size();
}
inline int FlowTag::nexthop_size() const {
  return _internal_nexthop_size();
}
inline void FlowTag::clear_nexthop() {
  nexthop_.Clear();
}
inline std::string* FlowTag::add_nexthop() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  return _internal_add_nexthop();
}
inline const std::string& FlowTag::_internal_nexthop(int index) const {
  return nexthop_.Get(index);
}
inline const std::string& FlowTag::nexthop(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  return _internal_nexthop(index);
}
inline std::string* FlowTag::mutable_nexthop(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  return nexthop_.Mutable(index);
}
inline void FlowTag::set_nexthop(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  nexthop_.Mutable(index)->assign(value);
}
inline void FlowTag::set_nexthop(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  nexthop_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_nexthop(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
}
inline void FlowTag::set_nexthop(int index, const char* value, size_t size) {
  nexthop_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
}
inline std::string* FlowTag::_internal_add_nexthop() {
  return nexthop_.Add();
}
inline void FlowTag::add_nexthop(const std::string& value) {
  nexthop_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
}
inline void FlowTag::add_nexthop(std::string&& value) {
  nexthop_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
}
inline void FlowTag::add_nexthop(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
}
inline void FlowTag::add_nexthop(const char* value, size_t size) {
  nexthop_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::nexthop() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  return nexthop_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_nexthop() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.nexthop)
  return &nexthop_;
}

// repeated string bgp_aspath = 20[json_name = "bgpAspath", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_bgp_aspath_size() const {
  return bgp_aspath_.size();
}
inline int FlowTag::bgp_aspath_size() const {
  return _internal_bgp_aspath_size();
}
inline void FlowTag::clear_bgp_aspath() {
  bgp_aspath_.Clear();
}
inline std::string* FlowTag::add_bgp_aspath() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  return _internal_add_bgp_aspath();
}
inline const std::string& FlowTag::_internal_bgp_aspath(int index) const {
  return bgp_aspath_.Get(index);
}
inline const std::string& FlowTag::bgp_aspath(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  return _internal_bgp_aspath(index);
}
inline std::string* FlowTag::mutable_bgp_aspath(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  return bgp_aspath_.Mutable(index);
}
inline void FlowTag::set_bgp_aspath(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  bgp_aspath_.Mutable(index)->assign(value);
}
inline void FlowTag::set_bgp_aspath(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  bgp_aspath_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_bgp_aspath(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bgp_aspath_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
}
inline void FlowTag::set_bgp_aspath(int index, const char* value, size_t size) {
  bgp_aspath_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
}
inline std::string* FlowTag::_internal_add_bgp_aspath() {
  return bgp_aspath_.Add();
}
inline void FlowTag::add_bgp_aspath(const std::string& value) {
  bgp_aspath_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
}
inline void FlowTag::add_bgp_aspath(std::string&& value) {
  bgp_aspath_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
}
inline void FlowTag::add_bgp_aspath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bgp_aspath_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
}
inline void FlowTag::add_bgp_aspath(const char* value, size_t size) {
  bgp_aspath_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::bgp_aspath() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  return bgp_aspath_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_bgp_aspath() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.bgp_aspath)
  return &bgp_aspath_;
}

// repeated string bgp_community = 21[json_name = "bgpCommunity", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_bgp_community_size() const {
  return bgp_community_.size();
}
inline int FlowTag::bgp_community_size() const {
  return _internal_bgp_community_size();
}
inline void FlowTag::clear_bgp_community() {
  bgp_community_.Clear();
}
inline std::string* FlowTag::add_bgp_community() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  return _internal_add_bgp_community();
}
inline const std::string& FlowTag::_internal_bgp_community(int index) const {
  return bgp_community_.Get(index);
}
inline const std::string& FlowTag::bgp_community(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  return _internal_bgp_community(index);
}
inline std::string* FlowTag::mutable_bgp_community(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  return bgp_community_.Mutable(index);
}
inline void FlowTag::set_bgp_community(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  bgp_community_.Mutable(index)->assign(value);
}
inline void FlowTag::set_bgp_community(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  bgp_community_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_bgp_community(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bgp_community_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
}
inline void FlowTag::set_bgp_community(int index, const char* value, size_t size) {
  bgp_community_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
}
inline std::string* FlowTag::_internal_add_bgp_community() {
  return bgp_community_.Add();
}
inline void FlowTag::add_bgp_community(const std::string& value) {
  bgp_community_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
}
inline void FlowTag::add_bgp_community(std::string&& value) {
  bgp_community_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
}
inline void FlowTag::add_bgp_community(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bgp_community_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
}
inline void FlowTag::add_bgp_community(const char* value, size_t size) {
  bgp_community_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::bgp_community() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  return bgp_community_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_bgp_community() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.bgp_community)
  return &bgp_community_;
}

// .kentik.flow_tag.v202404alpha1.AddressInfo mac = 22[json_name = "mac", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool FlowTag::_internal_has_mac() const {
  return this != internal_default_instance() && mac_ != nullptr;
}
inline bool FlowTag::has_mac() const {
  return _internal_has_mac();
}
inline void FlowTag::clear_mac() {
  if (GetArena() == nullptr && mac_ != nullptr) {
    delete mac_;
  }
  mac_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::AddressInfo& FlowTag::_internal_mac() const {
  const ::kentik::flow_tag::v202404alpha1::AddressInfo* p = mac_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::AddressInfo*>(
      &::kentik::flow_tag::v202404alpha1::_AddressInfo_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::AddressInfo& FlowTag::mac() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.mac)
  return _internal_mac();
}
inline void FlowTag::unsafe_arena_set_allocated_mac(
    ::kentik::flow_tag::v202404alpha1::AddressInfo* mac) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mac_);
  }
  mac_ = mac;
  if (mac) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.mac)
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::release_mac() {
  auto temp = unsafe_arena_release_mac();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::unsafe_arena_release_mac() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.FlowTag.mac)
  
  ::kentik::flow_tag::v202404alpha1::AddressInfo* temp = mac_;
  mac_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::_internal_mutable_mac() {
  
  if (mac_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::AddressInfo>(GetArena());
    mac_ = p;
  }
  return mac_;
}
inline ::kentik::flow_tag::v202404alpha1::AddressInfo* FlowTag::mutable_mac() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.mac)
  return _internal_mutable_mac();
}
inline void FlowTag::set_allocated_mac(::kentik::flow_tag::v202404alpha1::AddressInfo* mac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mac_;
  }
  if (mac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mac);
    if (message_arena != submessage_arena) {
      mac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mac, submessage_arena);
    }
    
  } else {
    
  }
  mac_ = mac;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.FlowTag.mac)
}

// repeated string country = 23[json_name = "country", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_country_size() const {
  return country_.size();
}
inline int FlowTag::country_size() const {
  return _internal_country_size();
}
inline void FlowTag::clear_country() {
  country_.Clear();
}
inline std::string* FlowTag::add_country() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.country)
  return _internal_add_country();
}
inline const std::string& FlowTag::_internal_country(int index) const {
  return country_.Get(index);
}
inline const std::string& FlowTag::country(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.country)
  return _internal_country(index);
}
inline std::string* FlowTag::mutable_country(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.country)
  return country_.Mutable(index);
}
inline void FlowTag::set_country(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.country)
  country_.Mutable(index)->assign(value);
}
inline void FlowTag::set_country(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.country)
  country_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_country(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  country_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.country)
}
inline void FlowTag::set_country(int index, const char* value, size_t size) {
  country_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.country)
}
inline std::string* FlowTag::_internal_add_country() {
  return country_.Add();
}
inline void FlowTag::add_country(const std::string& value) {
  country_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.country)
}
inline void FlowTag::add_country(std::string&& value) {
  country_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.country)
}
inline void FlowTag::add_country(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  country_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.country)
}
inline void FlowTag::add_country(const char* value, size_t size) {
  country_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.country)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::country() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.country)
  return country_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_country() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.country)
  return &country_;
}

// repeated string vlans = 24[json_name = "vlans", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int FlowTag::_internal_vlans_size() const {
  return vlans_.size();
}
inline int FlowTag::vlans_size() const {
  return _internal_vlans_size();
}
inline void FlowTag::clear_vlans() {
  vlans_.Clear();
}
inline std::string* FlowTag::add_vlans() {
  // @@protoc_insertion_point(field_add_mutable:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  return _internal_add_vlans();
}
inline const std::string& FlowTag::_internal_vlans(int index) const {
  return vlans_.Get(index);
}
inline const std::string& FlowTag::vlans(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  return _internal_vlans(index);
}
inline std::string* FlowTag::mutable_vlans(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  return vlans_.Mutable(index);
}
inline void FlowTag::set_vlans(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  vlans_.Mutable(index)->assign(value);
}
inline void FlowTag::set_vlans(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  vlans_.Mutable(index)->assign(std::move(value));
}
inline void FlowTag::set_vlans(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vlans_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
}
inline void FlowTag::set_vlans(int index, const char* value, size_t size) {
  vlans_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
}
inline std::string* FlowTag::_internal_add_vlans() {
  return vlans_.Add();
}
inline void FlowTag::add_vlans(const std::string& value) {
  vlans_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
}
inline void FlowTag::add_vlans(std::string&& value) {
  vlans_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
}
inline void FlowTag::add_vlans(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vlans_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
}
inline void FlowTag::add_vlans(const char* value, size_t size) {
  vlans_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowTag::vlans() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  return vlans_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowTag::mutable_vlans() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.FlowTag.vlans)
  return &vlans_;
}

// -------------------------------------------------------------------

// GetFlowTagRequest

// string id = 1[json_name = "id"];
inline void GetFlowTagRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetFlowTagRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
  return _internal_id();
}
inline void GetFlowTagRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
}
inline std::string* GetFlowTagRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
  return _internal_mutable_id();
}
inline const std::string& GetFlowTagRequest::_internal_id() const {
  return id_.Get();
}
inline void GetFlowTagRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetFlowTagRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
}
inline void GetFlowTagRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
}
inline void GetFlowTagRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
}
inline std::string* GetFlowTagRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetFlowTagRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetFlowTagRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
}
inline std::string* GetFlowTagRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetFlowTagRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.GetFlowTagRequest.id)
}

// -------------------------------------------------------------------

// GetFlowTagResponse

// .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
inline bool GetFlowTagResponse::_internal_has_flow_tag() const {
  return this != internal_default_instance() && flow_tag_ != nullptr;
}
inline bool GetFlowTagResponse::has_flow_tag() const {
  return _internal_has_flow_tag();
}
inline void GetFlowTagResponse::clear_flow_tag() {
  if (GetArena() == nullptr && flow_tag_ != nullptr) {
    delete flow_tag_;
  }
  flow_tag_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& GetFlowTagResponse::_internal_flow_tag() const {
  const ::kentik::flow_tag::v202404alpha1::FlowTag* p = flow_tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::FlowTag*>(
      &::kentik::flow_tag::v202404alpha1::_FlowTag_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& GetFlowTagResponse::flow_tag() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.GetFlowTagResponse.flow_tag)
  return _internal_flow_tag();
}
inline void GetFlowTagResponse::unsafe_arena_set_allocated_flow_tag(
    ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_tag_);
  }
  flow_tag_ = flow_tag;
  if (flow_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.GetFlowTagResponse.flow_tag)
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* GetFlowTagResponse::release_flow_tag() {
  auto temp = unsafe_arena_release_flow_tag();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* GetFlowTagResponse::unsafe_arena_release_flow_tag() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.GetFlowTagResponse.flow_tag)
  
  ::kentik::flow_tag::v202404alpha1::FlowTag* temp = flow_tag_;
  flow_tag_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* GetFlowTagResponse::_internal_mutable_flow_tag() {
  
  if (flow_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTag>(GetArena());
    flow_tag_ = p;
  }
  return flow_tag_;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* GetFlowTagResponse::mutable_flow_tag() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.GetFlowTagResponse.flow_tag)
  return _internal_mutable_flow_tag();
}
inline void GetFlowTagResponse::set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete flow_tag_;
  }
  if (flow_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(flow_tag);
    if (message_arena != submessage_arena) {
      flow_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_tag, submessage_arena);
    }
    
  } else {
    
  }
  flow_tag_ = flow_tag;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.GetFlowTagResponse.flow_tag)
}

// -------------------------------------------------------------------

// SearchFlowTagRequest

// .kentik.flow_tag.v202404alpha1.FlowTagSearch search = 1[json_name = "search"];
inline bool SearchFlowTagRequest::_internal_has_search() const {
  return this != internal_default_instance() && search_ != nullptr;
}
inline bool SearchFlowTagRequest::has_search() const {
  return _internal_has_search();
}
inline void SearchFlowTagRequest::clear_search() {
  if (GetArena() == nullptr && search_ != nullptr) {
    delete search_;
  }
  search_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTagSearch& SearchFlowTagRequest::_internal_search() const {
  const ::kentik::flow_tag::v202404alpha1::FlowTagSearch* p = search_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::FlowTagSearch*>(
      &::kentik::flow_tag::v202404alpha1::_FlowTagSearch_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTagSearch& SearchFlowTagRequest::search() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest.search)
  return _internal_search();
}
inline void SearchFlowTagRequest::unsafe_arena_set_allocated_search(
    ::kentik::flow_tag::v202404alpha1::FlowTagSearch* search) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(search_);
  }
  search_ = search;
  if (search) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest.search)
}
inline ::kentik::flow_tag::v202404alpha1::FlowTagSearch* SearchFlowTagRequest::release_search() {
  auto temp = unsafe_arena_release_search();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTagSearch* SearchFlowTagRequest::unsafe_arena_release_search() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest.search)
  
  ::kentik::flow_tag::v202404alpha1::FlowTagSearch* temp = search_;
  search_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTagSearch* SearchFlowTagRequest::_internal_mutable_search() {
  
  if (search_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTagSearch>(GetArena());
    search_ = p;
  }
  return search_;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTagSearch* SearchFlowTagRequest::mutable_search() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest.search)
  return _internal_mutable_search();
}
inline void SearchFlowTagRequest::set_allocated_search(::kentik::flow_tag::v202404alpha1::FlowTagSearch* search) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete search_;
  }
  if (search) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(search);
    if (message_arena != submessage_arena) {
      search = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search, submessage_arena);
    }
    
  } else {
    
  }
  search_ = search;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.SearchFlowTagRequest.search)
}

// -------------------------------------------------------------------

// SearchFlowTagResponse

// repeated .kentik.flow_tag.v202404alpha1.FlowTag flow_tags = 1[json_name = "flowTags"];
inline int SearchFlowTagResponse::_internal_flow_tags_size() const {
  return flow_tags_.size();
}
inline int SearchFlowTagResponse::flow_tags_size() const {
  return _internal_flow_tags_size();
}
inline void SearchFlowTagResponse::clear_flow_tags() {
  flow_tags_.Clear();
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* SearchFlowTagResponse::mutable_flow_tags(int index) {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.flow_tags)
  return flow_tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::FlowTag >*
SearchFlowTagResponse::mutable_flow_tags() {
  // @@protoc_insertion_point(field_mutable_list:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.flow_tags)
  return &flow_tags_;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& SearchFlowTagResponse::_internal_flow_tags(int index) const {
  return flow_tags_.Get(index);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& SearchFlowTagResponse::flow_tags(int index) const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.flow_tags)
  return _internal_flow_tags(index);
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* SearchFlowTagResponse::_internal_add_flow_tags() {
  return flow_tags_.Add();
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* SearchFlowTagResponse::add_flow_tags() {
  // @@protoc_insertion_point(field_add:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.flow_tags)
  return _internal_add_flow_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kentik::flow_tag::v202404alpha1::FlowTag >&
SearchFlowTagResponse::flow_tags() const {
  // @@protoc_insertion_point(field_list:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.flow_tags)
  return flow_tags_;
}

// uint32 total_count = 2[json_name = "totalCount"];
inline void SearchFlowTagResponse::clear_total_count() {
  total_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SearchFlowTagResponse::_internal_total_count() const {
  return total_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SearchFlowTagResponse::total_count() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.total_count)
  return _internal_total_count();
}
inline void SearchFlowTagResponse::_internal_set_total_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  total_count_ = value;
}
inline void SearchFlowTagResponse::set_total_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.total_count)
}

// uint32 invalid_count = 3[json_name = "invalidCount"];
inline void SearchFlowTagResponse::clear_invalid_count() {
  invalid_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SearchFlowTagResponse::_internal_invalid_count() const {
  return invalid_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SearchFlowTagResponse::invalid_count() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.invalid_count)
  return _internal_invalid_count();
}
inline void SearchFlowTagResponse::_internal_set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  invalid_count_ = value;
}
inline void SearchFlowTagResponse::set_invalid_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_invalid_count(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.SearchFlowTagResponse.invalid_count)
}

// -------------------------------------------------------------------

// CreateFlowTagRequest

// .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
inline bool CreateFlowTagRequest::_internal_has_flow_tag() const {
  return this != internal_default_instance() && flow_tag_ != nullptr;
}
inline bool CreateFlowTagRequest::has_flow_tag() const {
  return _internal_has_flow_tag();
}
inline void CreateFlowTagRequest::clear_flow_tag() {
  if (GetArena() == nullptr && flow_tag_ != nullptr) {
    delete flow_tag_;
  }
  flow_tag_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& CreateFlowTagRequest::_internal_flow_tag() const {
  const ::kentik::flow_tag::v202404alpha1::FlowTag* p = flow_tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::FlowTag*>(
      &::kentik::flow_tag::v202404alpha1::_FlowTag_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& CreateFlowTagRequest::flow_tag() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest.flow_tag)
  return _internal_flow_tag();
}
inline void CreateFlowTagRequest::unsafe_arena_set_allocated_flow_tag(
    ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_tag_);
  }
  flow_tag_ = flow_tag;
  if (flow_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest.flow_tag)
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagRequest::release_flow_tag() {
  auto temp = unsafe_arena_release_flow_tag();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagRequest::unsafe_arena_release_flow_tag() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest.flow_tag)
  
  ::kentik::flow_tag::v202404alpha1::FlowTag* temp = flow_tag_;
  flow_tag_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagRequest::_internal_mutable_flow_tag() {
  
  if (flow_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTag>(GetArena());
    flow_tag_ = p;
  }
  return flow_tag_;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagRequest::mutable_flow_tag() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest.flow_tag)
  return _internal_mutable_flow_tag();
}
inline void CreateFlowTagRequest::set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete flow_tag_;
  }
  if (flow_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(flow_tag);
    if (message_arena != submessage_arena) {
      flow_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_tag, submessage_arena);
    }
    
  } else {
    
  }
  flow_tag_ = flow_tag;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.CreateFlowTagRequest.flow_tag)
}

// -------------------------------------------------------------------

// CreateFlowTagResponse

// .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
inline bool CreateFlowTagResponse::_internal_has_flow_tag() const {
  return this != internal_default_instance() && flow_tag_ != nullptr;
}
inline bool CreateFlowTagResponse::has_flow_tag() const {
  return _internal_has_flow_tag();
}
inline void CreateFlowTagResponse::clear_flow_tag() {
  if (GetArena() == nullptr && flow_tag_ != nullptr) {
    delete flow_tag_;
  }
  flow_tag_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& CreateFlowTagResponse::_internal_flow_tag() const {
  const ::kentik::flow_tag::v202404alpha1::FlowTag* p = flow_tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::FlowTag*>(
      &::kentik::flow_tag::v202404alpha1::_FlowTag_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& CreateFlowTagResponse::flow_tag() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse.flow_tag)
  return _internal_flow_tag();
}
inline void CreateFlowTagResponse::unsafe_arena_set_allocated_flow_tag(
    ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_tag_);
  }
  flow_tag_ = flow_tag;
  if (flow_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse.flow_tag)
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagResponse::release_flow_tag() {
  auto temp = unsafe_arena_release_flow_tag();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagResponse::unsafe_arena_release_flow_tag() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse.flow_tag)
  
  ::kentik::flow_tag::v202404alpha1::FlowTag* temp = flow_tag_;
  flow_tag_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagResponse::_internal_mutable_flow_tag() {
  
  if (flow_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTag>(GetArena());
    flow_tag_ = p;
  }
  return flow_tag_;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* CreateFlowTagResponse::mutable_flow_tag() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse.flow_tag)
  return _internal_mutable_flow_tag();
}
inline void CreateFlowTagResponse::set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete flow_tag_;
  }
  if (flow_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(flow_tag);
    if (message_arena != submessage_arena) {
      flow_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_tag, submessage_arena);
    }
    
  } else {
    
  }
  flow_tag_ = flow_tag;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.CreateFlowTagResponse.flow_tag)
}

// -------------------------------------------------------------------

// UpdateFlowTagRequest

// .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
inline bool UpdateFlowTagRequest::_internal_has_flow_tag() const {
  return this != internal_default_instance() && flow_tag_ != nullptr;
}
inline bool UpdateFlowTagRequest::has_flow_tag() const {
  return _internal_has_flow_tag();
}
inline void UpdateFlowTagRequest::clear_flow_tag() {
  if (GetArena() == nullptr && flow_tag_ != nullptr) {
    delete flow_tag_;
  }
  flow_tag_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& UpdateFlowTagRequest::_internal_flow_tag() const {
  const ::kentik::flow_tag::v202404alpha1::FlowTag* p = flow_tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::FlowTag*>(
      &::kentik::flow_tag::v202404alpha1::_FlowTag_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& UpdateFlowTagRequest::flow_tag() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest.flow_tag)
  return _internal_flow_tag();
}
inline void UpdateFlowTagRequest::unsafe_arena_set_allocated_flow_tag(
    ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_tag_);
  }
  flow_tag_ = flow_tag;
  if (flow_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest.flow_tag)
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagRequest::release_flow_tag() {
  auto temp = unsafe_arena_release_flow_tag();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagRequest::unsafe_arena_release_flow_tag() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest.flow_tag)
  
  ::kentik::flow_tag::v202404alpha1::FlowTag* temp = flow_tag_;
  flow_tag_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagRequest::_internal_mutable_flow_tag() {
  
  if (flow_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTag>(GetArena());
    flow_tag_ = p;
  }
  return flow_tag_;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagRequest::mutable_flow_tag() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest.flow_tag)
  return _internal_mutable_flow_tag();
}
inline void UpdateFlowTagRequest::set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete flow_tag_;
  }
  if (flow_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(flow_tag);
    if (message_arena != submessage_arena) {
      flow_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_tag, submessage_arena);
    }
    
  } else {
    
  }
  flow_tag_ = flow_tag;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.UpdateFlowTagRequest.flow_tag)
}

// -------------------------------------------------------------------

// UpdateFlowTagResponse

// .kentik.flow_tag.v202404alpha1.FlowTag flow_tag = 1[json_name = "flowTag"];
inline bool UpdateFlowTagResponse::_internal_has_flow_tag() const {
  return this != internal_default_instance() && flow_tag_ != nullptr;
}
inline bool UpdateFlowTagResponse::has_flow_tag() const {
  return _internal_has_flow_tag();
}
inline void UpdateFlowTagResponse::clear_flow_tag() {
  if (GetArena() == nullptr && flow_tag_ != nullptr) {
    delete flow_tag_;
  }
  flow_tag_ = nullptr;
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& UpdateFlowTagResponse::_internal_flow_tag() const {
  const ::kentik::flow_tag::v202404alpha1::FlowTag* p = flow_tag_;
  return p != nullptr ? *p : *reinterpret_cast<const ::kentik::flow_tag::v202404alpha1::FlowTag*>(
      &::kentik::flow_tag::v202404alpha1::_FlowTag_default_instance_);
}
inline const ::kentik::flow_tag::v202404alpha1::FlowTag& UpdateFlowTagResponse::flow_tag() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse.flow_tag)
  return _internal_flow_tag();
}
inline void UpdateFlowTagResponse::unsafe_arena_set_allocated_flow_tag(
    ::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_tag_);
  }
  flow_tag_ = flow_tag;
  if (flow_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse.flow_tag)
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagResponse::release_flow_tag() {
  auto temp = unsafe_arena_release_flow_tag();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagResponse::unsafe_arena_release_flow_tag() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse.flow_tag)
  
  ::kentik::flow_tag::v202404alpha1::FlowTag* temp = flow_tag_;
  flow_tag_ = nullptr;
  return temp;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagResponse::_internal_mutable_flow_tag() {
  
  if (flow_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::kentik::flow_tag::v202404alpha1::FlowTag>(GetArena());
    flow_tag_ = p;
  }
  return flow_tag_;
}
inline ::kentik::flow_tag::v202404alpha1::FlowTag* UpdateFlowTagResponse::mutable_flow_tag() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse.flow_tag)
  return _internal_mutable_flow_tag();
}
inline void UpdateFlowTagResponse::set_allocated_flow_tag(::kentik::flow_tag::v202404alpha1::FlowTag* flow_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete flow_tag_;
  }
  if (flow_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(flow_tag);
    if (message_arena != submessage_arena) {
      flow_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_tag, submessage_arena);
    }
    
  } else {
    
  }
  flow_tag_ = flow_tag;
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.UpdateFlowTagResponse.flow_tag)
}

// -------------------------------------------------------------------

// DeleteFlowTagRequest

// string id = 1[json_name = "id"];
inline void DeleteFlowTagRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteFlowTagRequest::id() const {
  // @@protoc_insertion_point(field_get:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
  return _internal_id();
}
inline void DeleteFlowTagRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
}
inline std::string* DeleteFlowTagRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
  return _internal_mutable_id();
}
inline const std::string& DeleteFlowTagRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteFlowTagRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteFlowTagRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
}
inline void DeleteFlowTagRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
}
inline void DeleteFlowTagRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
}
inline std::string* DeleteFlowTagRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteFlowTagRequest::release_id() {
  // @@protoc_insertion_point(field_release:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteFlowTagRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
}
inline std::string* DeleteFlowTagRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DeleteFlowTagRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kentik.flow_tag.v202404alpha1.DeleteFlowTagRequest.id)
}

// -------------------------------------------------------------------

// DeleteFlowTagResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v202404alpha1
}  // namespace flow_tag
}  // namespace kentik

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kentik::flow_tag::v202404alpha1::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::flow_tag::v202404alpha1::ModelType>() {
  return ::kentik::flow_tag::v202404alpha1::ModelType_descriptor();
}
template <> struct is_proto_enum< ::kentik::flow_tag::v202404alpha1::LookupField> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::flow_tag::v202404alpha1::LookupField>() {
  return ::kentik::flow_tag::v202404alpha1::LookupField_descriptor();
}
template <> struct is_proto_enum< ::kentik::flow_tag::v202404alpha1::OrderDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kentik::flow_tag::v202404alpha1::OrderDirection>() {
  return ::kentik::flow_tag::v202404alpha1::OrderDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kentik_2fflow_5ftag_2fv202404alpha1_2fflow_5ftag_2eproto
