syntax = "proto3";

package kentik.mit2bgp.v202211;
option go_package = "github.com/kentik/api-schema/gen/go/kentik/mit2bgp/v202211;mit2bgp";

import "kentik/core/v202012alpha1/annotations.proto";

// MitigateService lets to mitigate DDoS attacks that triggered alerts using advanced BGP rules
service MitigateService {
        option (kentik.core.v202012alpha1.service_scope) = "mit2bgp.v202211";

        // Mitigate is a transaction stream that allows for starting a mitigation.
        //
        // In more detail, it can:
        // 1. analyze traffic of an alert that fired,
        // 2. check if it makes sense to mitigate using a specific algorithm,
        // 3. and propagate BGP rules to given set of BGP routers.
        //
        // The call is a gRPC stream in order to maintain the state (and server instance)
        // while going through all of the stages of starting a mitigation.
        rpc Mitigate(stream MitigateRequest) returns (stream MitigateResponse) {
                option (kentik.core.v202012alpha1.method_scope) = "mit2bgp.v202211:write";
        }

        // Stop drops matching BGP announcements of mit2bgp
        rpc Stop(StopRequest) returns (StopResponse) {
                option (kentik.core.v202012alpha1.method_scope) = "mit2bgp.v202211:write";
        }
}

// MitigateRequest wraps client messages of Mitigate().
//
// Clients MUST NOT send next requests before receiving a response to their most recent request.
// Clients MAY disconnect from the stream at any point before the final stage, or jump to the first
// stage (fetch), to go back to the starting point (ie. cancel without BGP effects).
message MitigateRequest {
        oneof requests {
                FetchRequest fetch = 1; // first stage: fetch and prepare the data
                CidrRequest cidr = 3;   // for: ALGO_SRCIP, ALGO_DSTIP
                StartRequest start = 2; // last stage: propagate BGP announcements
        }
}

// MitigateResponse wraps server messages of Mitigate().
//
// Server MUST only send the response message corresponding to a received request message.
message MitigateResponse {
        oneof responses {
                FetchResponse fetch = 1;
                CidrResponse cidr = 3;
                StartResponse start = 2;
        }
}

// Algo selects the traffic analysis algorithm for finding BGP rules
enum Algo {
        ALGO_UNSPECIFIED = 0; // invalid
        ALGO_SRCIP = 1;       // mitigate top source IP CIDRs
        ALGO_DSTIP = 2;       // mitigate top destination IP CIDRs
}

// Ipv selects version of the IP protocol
enum Ipv {
        IPV_UNSPECIFIED = 0; // no filter (equals IPv4 + IPv6 merged)
        IPV_4 = 4;           // IPv4
        IPV_6 = 6;           // IPv6
}

// ---

// FetchRequest will fetch alert details, run basic checks to make sure we can proceed,
// and fetch the traffic from KDE to a temporary file (valid for the stream lifetime).
message FetchRequest {
        Algo algo = 1;       // algorithm to use

        uint32 cid = 2;      // company id
        uint32 uid = 3;      // user id; if 0, the first user under cid will be used
        uint32 aid = 4;      // alert id

        // OPTIONAL: CIDRs or IPs (v4/v6) we should exclude from traffic, and never block
        repeated string exclude = 5;

        Ipv ipv = 6;         // OPTIONAL: use given IP version only
        bool pps = 7;        // OPTIONAL: if true, mitigate packets (pps) instead of bytes (bps)
        uint32 limit = 8;    // OPTIONAL: KSQL row LIMIT; if 0, we'll use a default
        string where = 9;    // OPTIONAL: additional KSQL term to add to the WHERE clause

        uint64 tstart = 10;  // OPTIONAL: override KSQL time window start (UNIX timestamp, seconds)
        uint64 tstop = 11;   // OPTIONAL: override KSQL time window end (UNIX timestamp, seconds)
}

// FetchResponse, if comes back without an error, means we're good to launch the algorithm
message FetchResponse {
        string ksql = 1;     // used KSQL query
        uint64 tstart = 2;   // used KSQL time window start (UNIX timestamp, seconds)
        uint64 tstop = 3;    // used KSQL time window end (UNIX timestamp, seconds)

        // summary stats for the traffic in KSQL results:
        uint64 rows = 4;     // total number of rows
        uint64 bytes = 5;    // total sum of bytes
        uint64 pkts = 6;     // total sum of packets
}

// ---

// CidrRequest blocks top IP CIDRs by finding the biggest traffic contributors. Whether we're using
// the source or destination IP addresses depends on the algo set in FetchRequest.
//
// Client MAY send more than one CidrRequests (possibly with different parameters), but each run
// will overwrite previous results; the next stage will only use the last response.
message CidrRequest {
        // maximum number of rules to use
        uint32 rules = 1;

        // target for the minimum volume of traffic to block
        // eg. ratio = 0.8 means 80% of total traffic in FetchResponse
        oneof target {
                uint64 volume = 2;     // absolute count
                float ratio = 3;       // fraction of total
        }

        // skip adding alert dimension values to the final Flowspec rules?
        //
        // by default (false), we will include supported dimensions to the Flowspec rules,
        // eg. IP_dst or Proto, which should more precisely block attack traffic and thus
        // minimize collateral damage
        bool no_dimensions = 4;
}

// CidrResponse tells how many potential rules we found, and how much these would block.
message CidrResponse {
        uint32 rules = 1;         // number of rules we found

        float bytes_ratio = 2;    // fraction of total bytes
        uint64 bytes_vol = 3;     // absolute byte count
        float pkts_ratio = 4;     // fraction of total packets
        uint64 pkts_vol = 5;      // absolute packet count

        uint64 v4blocked = 8;     // number of blocked IPv4 addresses
        uint64 v4damage = 9;      // total number of affected IPv4 addresses on the Internet
        uint64 v6blocked = 10;    // number of blocked /64 IPv6 prefixes
        uint64 v6damage = 11;     // total number of affected /64 IPv6 prefixes on the Internet
}

// ---

// StartRequest announces final BGP rules to given list of devices
message StartRequest {
        // device ids of BGP routers to send announcements to
        repeated uint32 routers = 1;
}

// StartResponse reports if the mitigation was successful
//
// All device ids from StartRequest.routers will be reflected in either done or failed.
message StartResponse {
        // device ids of BGP routers we successfully sent all rules to
        repeated uint32 done = 1;

        // device ids of BGP routers we somehow failed to send all rules to
        repeated uint32 failed = 2;
}

// ---

// StopRequest removes mit2bgp rules from given list of devices that match given alert id
// and/or algo. If no matches are provided, it removes all rules that mit2bgp could have announced.
//
// It is perfectly fine to attempt flushing potentially non-existent rules "just in case",
// eg. as a fail-safe mechanism, to recover from errors, or prepare before new mitigations.
//
// If StopRequest.go is false, this is a check function.
message StopRequest {
        // device ids of BGP routers we should try
        repeated uint32 routers = 1;

        // REQUIRED: must be true to actually go and flush the rules;
        // otherwise, we only check for existence of our rules
        bool go = 2;

        // OPTIONAL: alert id
        uint32 aid = 3;

        // OPTIONAL: algorithm
        string algo = 4;
}

// StopResponse reports how successful the StopRequest was.
//
// All device ids from StopRequest.routers will be reflected in one of done/failed/empty.
message StopResponse {
        // device ids of BGP routers that had matching rules
        repeated uint32 done = 1;

        // device ids of BGP routers we somehow failed on
        repeated uint32 failed = 2;

        // device ids of BGP routers that had no matching rules
        // this is usually "done" when flushing, but "failed" when checking
        repeated uint32 empty = 3;
}
