syntax = "proto3";
package kentik.mit2bgp.v202212;
option go_package = "github.com/kentik/api-schema/gen/go/kentik/mit2bgp/v202212;mbproto";

import "kentik/mit2bgp/v202212/flowspec.proto";
import "kentik/core/v202012alpha1/annotations.proto";

// MitigateService lets to mitigate DDoS attacks that triggered alerts using advanced BGP rules
service MitigateService {
	option (kentik.core.v202012alpha1.visibility) = SERVICE_VISIBILITY_PRIVATE;
	option (kentik.core.v202012alpha1.private_service) = true;

	// Start discovers and deploys Flowspec rules for mitigating DoS attack traffic
	rpc Start(StartRequest) returns (StartResponse) {}

	// Stop drops matching BGP announcements of mit2bgp
	rpc Stop(StopRequest) returns (StopResponse) {}
}

message StartRequest {
	// context id
	// - can be derived from the target, eg. hash value
	// - will be used for chfrib keys, keep it short
	string id = 1;

	// customer
	string company_id = 2;
	uint32 user_id = 3;

	// mitigation target
	Target target = 4;

	// global goal: we must satisfy this or be better
	Goal goal = 5;

	// algorithms to use
	repeated Algo algo = 6; // algorithm list; the order is important
	Select select = 7;      // if more than 1 on the list, which to choose for deploy?
	Algo failsafe = 8;      // unconditionally deploy this if nothing else worked

	// if the goal was met, where to deploy? (can be empty for debug only)
	repeated DeployRequest routers = 9;

	// Flowspec template
	// if missing or empty, the default is to infer every possible match type from the target
	Flowspec template = 10;

	// how many rules to show in the response?
	// normally the caller does not need to see the generated rules, but eg. in case of
	// a need to debug this system, show_rules > 0 will send some rules back in StartResponse
	uint32 show_rules = 11;
}

message StartResponse {
	// if true, the goal was met
	bool success = 1;

	// details on what was achieved
	Goal result = 2;

	// describes the deploy effects
	repeated DeployResponse routers = 3;

	// generated rules, if StartRequest.show_rules was > 0
	repeated Flowspec rules = 4;
}

message StopRequest {
	// mit2bgp id used in StartRequest, or its prefix
	// if empty, it will remove ALL mit2bgp mitigations from routers
	string id = 1;

	// customer
	string company_id = 2;

	// which devices to remove rules from?
	repeated DeployRequest routers = 4;

	// REQUIRED: must be true to actually go and flush the rules;
	// otherwise, we only check for existence of our rules
	bool go = 5;
}

message StopResponse {
	// all matching mit2bgp ids remaining on routers AFTER StopRequest was executed
	// NB: this should be empty for deletes (go=true), non-empty for checks (go=false),
	//     or simply dump all running mitigations when requested id is nil (and go=false).
	repeated string remaining = 1;

	// describes the effects
	repeated DeployResponse routers = 4;
}

// ---

// Target represents the event that we want to mitigate
message Target {
	bool pps = 1;                      // mitigate pps instead of bps
	repeated string dim_values = 2;    // alerting dimension=value strings
	repeated string ksql_where = 3;    // ksql WHERE conditions (will be connected with AND)
	int64 tstart = 4;                  // time window start: 0 means NOW (-5min in KSQL query)
	int64 tend = 5;                    // time window end: 0 means NOW (+5min in KSQL query)
}

// Goal describes how good the results of algorithm must be to consider it a success
message Goal {
	uint32 rules = 1;                  // number of rules this may use (>0)
	float traffic = 2;                 // percentage of the analyzed traffic this must cover (0.0-1.0)
	float v4damage = 3;                // max. possible damage to IPv4 (0.0-1.0); 0 = no limit
	float v6damage = 4;                // max. possible damage to IPv6 (0.0-1.0); 0 = no limit
}

// Algo selects and configures an algorithm for generating mitigation rules
message Algo {
	Goal goal = 1;                     // if max_rules>0, overrides the global goal
	Flowspec template = 2;             // if non-empty, overrides the global template

	oneof algo {
		TopCidr srcip = 10;             // find top source CIDRs
		TopCidr dstip = 11;             // find top destination CIDRs
		Dimvals dimvals = 12;           // just rewrite dim_values; always rules=1 traffic=1 damage=1
		// TODO: srcport/dstport
		// TODO: patterns (ML)
	}
}

// Select chooses algorithm selection strategy
enum Select {
	SELECT_UNSPECIFIED = 0;            // valid for lists of 1 algo
	SELECT_FIRST = 1;                  // first that satisfies the goal wins
	SELECT_DAMAGE = 2;                 // choose the minimum damage from all that satisfy rules+traffic
	SELECT_ALL = 3;                    // deploy each that satisfy the goal
}

// DeployRequest identifies a router device for BGP propagation
message DeployRequest {
	// device id
	uint32 device_id = 1;

	// if true, requests to skip the IPv4 BGP session of the device
	bool v4skip = 2;

	// if true, requests to skip the IPv6 BGP session of the device
	bool v6skip = 3;

	// if non-empty, will be used as chfrib route metadata
	string route_metadata = 4;
}

// DeployResult encodes how successful (or not) was the deploy request
enum DeployResult {
	DEPLOY_RESULT_UNSPECIFIED = 0;  // no attempt
	DEPLOY_RESULT_NO_SESSION = 1;   // wanted to try, but no adequate BGP session was alive
	DEPLOY_RESULT_FAILURE = 2;      // tried but nothing propagated, a retry might help
	DEPLOY_RESULT_PARTIAL = 3;      // not all routes propagated, might need a cleanup
	DEPLOY_RESULT_SUCCESS = 4;      // full success, all routes propagated
}

// DeployResponse describes the result of BGP propagation for a particular router
message DeployResponse {
	// device id
	uint32 device_id = 1;

	// generic errors, ignore IPv4/IPv6 below if err_code != 0
	uint32 err_code = 2; // error code
	string err_msg = 3;  // error message

	// IPv4 deploy result
	DeployResult v4result = 4;  // IPv4 deploy result code
	uint32 v4code = 5;          // optional error code
	string v4error = 6;         // optional error message (details)

	// IPv6 deploy result
	DeployResult v6result = 7;  // IPv6 deploy result code
	uint32 v6code = 8;          // optional error code
	string v6error = 9;         // optional error message (details)
}

// ---

// TopCidrs finds CIDRs that contributed the most bits or packets
message TopCidr {
	uint32 v4min = 1; // minimum IPv4 CIDR length, eg. /4
	uint32 v4max = 2; // maximum IPv4 CIDR length, eg. /32

	uint32 v6min = 3; // minimum IPv6 CIDR length, eg. /28
	uint32 v6max = 4; // maximum IPv6 CIDR length, eg. /64

	repeated string exclude = 5; // CIDRs to exclude from blocking
}

// Dimvals is a pseudo-algorithm that does not query KDE, but instead relies solely
// on the mitigation Target to generate a Flowspec rule that blocks the provided
// dimension values. This is how the classic Flowspec mitigation platform works.
// If additional control over the generated rule is needed, the caller should use
// the Flowspec template in the mitigation StartRequest.
message Dimvals {
	// this is intentionally left blank
}
